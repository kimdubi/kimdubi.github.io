<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ORACLE Architecture 간단히 살펴보기 | kimDuBiA</title><meta name=keywords content="oracle,architecture"><meta name=description content="ORACLE Architecture 간단히 살펴보기 Oracle Architecture Oracle server는 크게 세부분으로 나뉩니다.
( SGA + Background Process + Files)
메모리 영역 (SGA) SGA는 shared global area 라는 이름에서부터 알 수 있듯이 사용자들이 오라클에서 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역을 의미합니다. SGA는 크게 Data buffer cache, Redo log buffer , Shared pool 로 이루어져 있습니다.   Data buffer cache  데이터의 조회와 변경 등의 실제 작업이 일어나는 공간으로 사용자가 찾거나 변경하는 데이터는 반드시 data buffer cache에 존재해야 합니다."><meta name=author content="kimdubi"><link rel=canonical href=/oracle/oracle_architecture/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="ORACLE Architecture 간단히 살펴보기"><meta property="og:description" content="ORACLE Architecture 간단히 살펴보기 Oracle Architecture Oracle server는 크게 세부분으로 나뉩니다.
( SGA + Background Process + Files)
메모리 영역 (SGA) SGA는 shared global area 라는 이름에서부터 알 수 있듯이 사용자들이 오라클에서 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역을 의미합니다. SGA는 크게 Data buffer cache, Redo log buffer , Shared pool 로 이루어져 있습니다.   Data buffer cache  데이터의 조회와 변경 등의 실제 작업이 일어나는 공간으로 사용자가 찾거나 변경하는 데이터는 반드시 data buffer cache에 존재해야 합니다."><meta property="og:type" content="article"><meta property="og:url" content="/oracle/oracle_architecture/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="oracle"><meta property="article:published_time" content="2021-10-04T22:16:47+09:00"><meta property="article:modified_time" content="2021-10-04T22:16:47+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ORACLE Architecture 간단히 살펴보기"><meta name=twitter:description content="ORACLE Architecture 간단히 살펴보기 Oracle Architecture Oracle server는 크게 세부분으로 나뉩니다.
( SGA + Background Process + Files)
메모리 영역 (SGA) SGA는 shared global area 라는 이름에서부터 알 수 있듯이 사용자들이 오라클에서 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역을 의미합니다. SGA는 크게 Data buffer cache, Redo log buffer , Shared pool 로 이루어져 있습니다.   Data buffer cache  데이터의 조회와 변경 등의 실제 작업이 일어나는 공간으로 사용자가 찾거나 변경하는 데이터는 반드시 data buffer cache에 존재해야 합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Oracles","item":"/oracle/"},{"@type":"ListItem","position":3,"name":"ORACLE Architecture 간단히 살펴보기","item":"/oracle/oracle_architecture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ORACLE Architecture 간단히 살펴보기","name":"ORACLE Architecture 간단히 살펴보기","description":"ORACLE Architecture 간단히 살펴보기 Oracle Architecture Oracle server는 크게 세부분으로 나뉩니다.\n( SGA + Background Process + Files)\n메모리 영역 (SGA) SGA는 shared global area 라는 이름에서부터 알 수 있듯이 사용자들이 오라클에서 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역을 의미합니다. SGA는 크게 Data buffer cache, Redo log buffer , Shared pool 로 이루어져 있습니다.   Data buffer cache  데이터의 조회와 변경 등의 실제 작업이 일어나는 공간으로 사용자가 찾거나 변경하는 데이터는 반드시 data buffer cache에 존재해야 합니다.","keywords":["oracle","architecture"],"articleBody":"ORACLE Architecture 간단히 살펴보기 Oracle Architecture Oracle server는 크게 세부분으로 나뉩니다.\n( SGA + Background Process + Files)\n메모리 영역 (SGA) SGA는 shared global area 라는 이름에서부터 알 수 있듯이 사용자들이 오라클에서 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역을 의미합니다. SGA는 크게 Data buffer cache, Redo log buffer , Shared pool 로 이루어져 있습니다.   Data buffer cache  데이터의 조회와 변경 등의 실제 작업이 일어나는 공간으로 사용자가 찾거나 변경하는 데이터는 반드시 data buffer cache에 존재해야 합니다. (없으면 disk에서 읽어옴) Data buffer cache를 사용하는 이유는 데이터는 data file, 즉 디스크에 저장이 되는데 사용자가 데이터를 가져오려고 할 때 마다 디스크에서 가져오면 속도가 정말 느리겠죠? 그래서 자주 쓰이는 데이터, 필요한 데이터 등을 data buffer cache에 올려놓고 사용합니다.  Redo log buffer  데이터에 변경사항이 생길 경우 해당 변경 내용을 기록해 두는 역할을 합니다. 앞으로 다룰 내용인 오라클 백업\u0026복구에서 매우 중요한 역할을 하는 구성요소로서 redo log는 영수증과 같다고 보시면 됩니다. 매장 (Oracle) 에서 물건을 산 뒤 (DDL,DML) 물건의 하자 등의 이유로 교환이나 환불을 원할 때 (Recovery) 매장 측에선 영수증 (redo log) 를 보고 해당 물건과 값에 대해 처리를 해주는 것이죠.  Shared pool  Shared pool은 하나의 데이터베이스에서 수행되는 모든 쿼리를 처리하기 위해 사용됩니다. Library cache는 이미 수행 되었던 쿼리에 대한 실행계획,쿼리문장 등이 저장 되어 있어서 만약 여러 명의 사용자가 같은 쿼리를 수행하는 경우 library cache에서 해당 쿼리에 대한 실행 계획 등을 공유하기 때문에 자원을 절약할 수 있습니다. Dictionary cache에서는 데이터베이스 내 오브젝트, 사용자등에 대한 정보가 저장 되어 있어서 쿼리에 대해 syntax check, semantic check를 수행 할 때 사용됩니다. 백그라운드 프로세스 1) DBWR 2) LGWR 3) PMON 4) SMON 5) CKPT  파일 영역 1) 파라미터 파일 – Instance를 어떻게 설계할지 정보가 담겨져 있는 파일 (initORACLE_SID.ora) 2) 컨트롤파일 – Database 전체의 정보를 갖고 있는 파일 3) 데이터파일 – 실제 테이블들의 데이터 등의 정보가 기록 되는 파일 4) 리두로그파일 – 오라클의 모든 변경사항이 기록되는 파일  쿼리수행 SELECT 문이 어떻게 수행되는지 간단히 살펴보면서 위에서 본 개념들이 어떻게 사용되는지 알아보겠습니다.\nclient 사용자는 User Process (sql plus, orange,toad,oracle client 등)을 통해 SQL문장을 DB서버로 보냅니다.\nDB 서버에는 Listener라는 프로그램이 있는데\n이 listener가 사용자의 접속 요청을 확인하고 조건을 만족하면\nServer process와 User Process (사용자)를 맺어주게 되고 이 Server process를 통해서 DB에서 쿼리를 수행하게 됩니다.\n PARSE  그 후 쿼리는 SGA의 parse 라는 단계를 거칩니다.\n이 때 Shared pool에서 syntax, semantic check 검사를 하는데\nERROR at line 2: ORA-00942: table or view does not exist ERROR at line 2: ORA-00923: FROM keyword not found where expected  문법이 맞는지, 조회하려는 테이블이 실제로 존재하는지에 대한 검사를 parsing 단계에서 하게 됩니다.\n그리고 실행계획을 생성하게 되는데 shared pool에는 수행 했던 쿼리들에 대한 실행계획을 갖고 있어서\n실행계획이 존재하면\nsoft parsing- 기존의 실행계획 재사용\n존재하지 않으면\nhard parsing-optimizer\n단계를 추가로 거쳐 실행계획 생성 을 하게 됩니다.\n Bind  bind 단계는 효율성을 위해 꼭 필요한 단계라고 할 수 있습니다. binding의 개념이 없다면 100명의 학생이 영어점수를 조회하려고 하면 같은 테이블의 같은 컬럼을 조회하고 학번과 이름만 다른 실행계획이 100개 생길 것 입니다. 학번과 이름을 bind 변수로 지정하면 실행계획은 1개만 생성후 100번 실행해 hard parsing하는 리소스를 절약할 수 있습니다.  execute  실행단계는 필요한 데이터를 data buffer cache로 가져옵니다. 데이터가 없으면 위에서 언급했듯이 DISK (data file)에서 필요한 data를 가져오는데 느린 disk에서 빠른 메모리로 옮기는 과정이다 보니 병목현상이 많이 생기기도 합니다.  Fetch  execute 과정에서 data buffer cache로 가져온 데이터를 사용자에게 전달해 주는 과정입니다. 내 쿼리가 hard parsing 되는지 soft parsing 되는지 확인하는 방법  현재 자신의 spid 확인 및 10046 trace 걸기   처음 쿼리 수행 후 trace 결과 화면\n( Select num from trace_test 쿼리 수행 뒤 10046 trace 결과 화면 )  위에서 Misses in library cache during parse : 1 1은 hard parsing 을 의미 합니다.   같은 쿼리 수행 후 trace 결과 화면\n( Select num from trace_test 재수행 뒤 10046 trace 결과 )  위에서 Misses in library cache during parse : 0 0은 soft parsing을 의미합니다  오라클 기동 단계  NOMOUNT  nomount 단계에서는 initORACLE\\_SID.ora 파라미터파일을 바탕으로 인스턴스 (SGA+Background process) 를 생성합니다. 그렇기 때문에 parameter file을 바탕으로 한 아래와 같은 정보만 조회 할 수 있습니다. select * from v$instance; select * from v$parameter; select * from v$version; show sga;  MOUNT  Mount 단계에서는 instance와 Database 가 맞춰지는 단계로 모든 상태 정보를 읽어오게 됩니다. control file을 읽어서 데이터 파일이나 리두 로그 파일등의 위치와 상태만 알 뿐 실제 물리적인 파일이 열린 상태는 아닙니다. select status from v$instance; == (status = mounted) select * from v$database; select * from v$datafile; select * from v$controlfile; select * from v$logfile;  OPEN  Open 단계에서는 컨트롤파일에서 읽은 DATA FILE 이나 ONLINE REDO LOG FILE 의 위치 및 OPEN 가능여부를 확인하고 데이터 베이스 일관성을 검사합니다. 여기서 말하는 일관성이란 모든 데이터 파일과 컨트롤 파일들이 같은 시점의 데이터들 인지 검증하기 위해 SCN을 비교하는 과정으로 recovery가 필요한지 불필요한지를 결정하는 중요한 단계라고 할 수 있습니다. ","wordCount":"750","inLanguage":"en","datePublished":"2021-10-04T22:16:47+09:00","dateModified":"2021-10-04T22:16:47+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/oracle/oracle_architecture/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/oracle/>Oracles</a></div><h1 class=post-title>ORACLE Architecture 간단히 살펴보기</h1><div class=post-meta>October 4, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#oracle-architecture-%ea%b0%84%eb%8b%a8%ed%9e%88-%ec%82%b4%ed%8e%b4%eb%b3%b4%ea%b8%b0 aria-label="ORACLE Architecture 간단히 살펴보기">ORACLE Architecture 간단히 살펴보기</a><ul><li><a href=#oracle-architecture aria-label="Oracle Architecture">Oracle Architecture</a><ul><li><a href=#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%98%81%ec%97%ad-sga aria-label="메모리 영역 (SGA)">메모리 영역 (SGA)</a></li><li><a href=#%eb%b0%b1%ea%b7%b8%eb%9d%bc%ec%9a%b4%eb%93%9c-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4 aria-label="백그라운드 프로세스">백그라운드 프로세스</a></li><li><a href=#%ed%8c%8c%ec%9d%bc-%ec%98%81%ec%97%ad aria-label="파일 영역">파일 영역</a></li></ul></li><li><a href=#%ec%bf%bc%eb%a6%ac%ec%88%98%ed%96%89 aria-label=쿼리수행>쿼리수행</a><ul><li><a href=#%eb%82%b4-%ec%bf%bc%eb%a6%ac%ea%b0%80-hard-parsing-%eb%90%98%eb%8a%94%ec%a7%80-soft-parsing-%eb%90%98%eb%8a%94%ec%a7%80-%ed%99%95%ec%9d%b8%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="내 쿼리가 hard parsing 되는지 soft parsing 되는지 확인하는 방법">내 쿼리가 hard parsing 되는지 soft parsing 되는지 확인하는 방법</a></li></ul></li><li><a href=#%ec%98%a4%eb%9d%bc%ed%81%b4-%ea%b8%b0%eb%8f%99-%eb%8b%a8%ea%b3%84 aria-label="오라클 기동 단계">오라클 기동 단계</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=oracle-architecture-간단히-살펴보기>ORACLE Architecture 간단히 살펴보기<a hidden class=anchor aria-hidden=true href=#oracle-architecture-간단히-살펴보기>#</a></h2><h3 id=oracle-architecture>Oracle Architecture<a hidden class=anchor aria-hidden=true href=#oracle-architecture>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/oracle/oracle_archictecture_1.jpg alt></p><p>Oracle server는 크게 세부분으로 나뉩니다.<br>( SGA + Background Process + Files)</p><h4 id=메모리-영역-sga>메모리 영역 (SGA)<a hidden class=anchor aria-hidden=true href=#메모리-영역-sga>#</a></h4><pre><code>SGA는 shared global area 라는 이름에서부터 알 수 있듯이  
사용자들이 오라클에서 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역을 의미합니다.  
SGA는 크게 Data buffer cache, Redo log buffer , Shared pool 로 이루어져 있습니다.
</code></pre><ul><li>Data buffer cache</li></ul><pre><code>데이터의 조회와 변경 등의 실제 작업이 일어나는 공간으로 
사용자가 찾거나 변경하는 데이터는 반드시 data buffer cache에 존재해야 합니다. 
(없으면 disk에서 읽어옴)  
Data buffer cache를 사용하는 이유는 데이터는 data file, 즉 디스크에 저장이 되는데  
사용자가 데이터를 가져오려고 할 때 마다 디스크에서 가져오면 속도가 정말 느리겠죠?  
그래서 자주 쓰이는 데이터, 필요한 데이터 등을 data buffer cache에 올려놓고 사용합니다.
</code></pre><ul><li>Redo log buffer</li></ul><pre><code>데이터에 변경사항이 생길 경우 해당 변경 내용을 기록해 두는 역할을 합니다.  
앞으로 다룰 내용인 오라클 백업&amp;복구에서 매우 중요한 역할을 하는 구성요소로서  
redo log는 영수증과 같다고 보시면 됩니다.  
매장 (Oracle) 에서 물건을 산 뒤 (DDL,DML) 물건의 하자 등의 이유로 교환이나 환불을 원할 때 (Recovery)  
매장 측에선 영수증 (redo log) 를 보고 해당 물건과 값에 대해 처리를 해주는 것이죠.
</code></pre><ul><li>Shared pool</li></ul><pre><code>Shared pool은 하나의 데이터베이스에서 수행되는 모든 쿼리를 처리하기 위해 사용됩니다.  
Library cache는 이미 수행 되었던 쿼리에 대한 실행계획,쿼리문장 등이 저장 되어 있어서  
만약 여러 명의 사용자가 같은 쿼리를 수행하는 경우  
library cache에서 해당 쿼리에 대한 실행 계획 등을 공유하기 때문에 자원을 절약할 수 있습니다.  
Dictionary cache에서는 데이터베이스 내 오브젝트, 사용자등에 대한 정보가 저장 되어 있어서  
쿼리에 대해 syntax check, semantic check를 수행 할 때 사용됩니다.
</code></pre><h4 id=백그라운드-프로세스>백그라운드 프로세스<a hidden class=anchor aria-hidden=true href=#백그라운드-프로세스>#</a></h4><pre><code>1) DBWR 2) LGWR 3) PMON 4) SMON 5) CKPT
</code></pre><h4 id=파일-영역>파일 영역<a hidden class=anchor aria-hidden=true href=#파일-영역>#</a></h4><pre><code>1) 파라미터 파일 – Instance를 어떻게 설계할지 정보가 담겨져 있는 파일 (initORACLE_SID.ora)
2) 컨트롤파일 – Database 전체의 정보를 갖고 있는 파일
3) 데이터파일 – 실제 테이블들의 데이터 등의 정보가 기록 되는 파일    
4) 리두로그파일 – 오라클의 모든 변경사항이 기록되는 파일
</code></pre><h3 id=쿼리수행>쿼리수행<a hidden class=anchor aria-hidden=true href=#쿼리수행>#</a></h3><p>SELECT 문이 어떻게 수행되는지 간단히 살펴보면서 위에서 본 개념들이 어떻게 사용되는지 알아보겠습니다.</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/oracle/oracle_archi_2.jpg alt></p><p>client 사용자는 User Process (sql plus, orange,toad,oracle client 등)을 통해 SQL문장을 DB서버로 보냅니다.<br>DB 서버에는 Listener라는 프로그램이 있는데</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/oracle/oracle_archi3.png alt></p><p>이 listener가 사용자의 접속 요청을 확인하고 조건을 만족하면<br>Server process와 User Process (사용자)를 맺어주게 되고 이 Server process를 통해서 DB에서 쿼리를 수행하게 됩니다.</p><ul><li>PARSE</li></ul><p>그 후 쿼리는 SGA의 parse 라는 단계를 거칩니다.<br>이 때 Shared pool에서 syntax, semantic check 검사를 하는데</p><pre><code>ERROR at line 2:
ORA-00942: table or view does not exist
 
ERROR at line 2:
ORA-00923: FROM keyword not found where expected
</code></pre><p>문법이 맞는지, 조회하려는 테이블이 실제로 존재하는지에 대한 검사를 parsing 단계에서 하게 됩니다.<br>그리고 실행계획을 생성하게 되는데 shared pool에는 수행 했던 쿼리들에 대한 실행계획을 갖고 있어서<br>실행계획이 존재하면<br>soft parsing-> 기존의 실행계획 재사용</p><p>존재하지 않으면<br>hard parsing->optimizer<br>단계를 추가로 거쳐 실행계획 생성 을 하게 됩니다.</p><ul><li>Bind</li></ul><pre><code>bind 단계는 효율성을 위해 꼭 필요한 단계라고 할 수 있습니다.  
binding의 개념이 없다면 100명의 학생이 영어점수를 조회하려고 하면  
같은 테이블의 같은 컬럼을 조회하고 학번과 이름만 다른 실행계획이 100개 생길 것 입니다.

학번과 이름을 bind 변수로 지정하면  
실행계획은 1개만 생성후 100번 실행해 hard parsing하는 리소스를 절약할 수 있습니다.
</code></pre><ul><li>execute</li></ul><pre><code>실행단계는 필요한 데이터를 data buffer cache로 가져옵니다.  
데이터가 없으면 위에서 언급했듯이 DISK (data file)에서 필요한 data를 가져오는데  
느린 disk에서 빠른 메모리로 옮기는 과정이다 보니 병목현상이 많이 생기기도 합니다.
</code></pre><ul><li>Fetch</li></ul><pre><code>execute 과정에서 data buffer cache로 가져온 데이터를 사용자에게 전달해 주는 과정입니다.
</code></pre><h4 id=내-쿼리가-hard-parsing-되는지-soft-parsing-되는지-확인하는-방법>내 쿼리가 hard parsing 되는지 soft parsing 되는지 확인하는 방법<a hidden class=anchor aria-hidden=true href=#내-쿼리가-hard-parsing-되는지-soft-parsing-되는지-확인하는-방법>#</a></h4><ul><li>현재 자신의 spid 확인 및 10046 trace 걸기</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/oracle/oracle_archi4.png alt></p><ul><li>처음 쿼리 수행 후 trace 결과 화면<br>( Select num from trace_test 쿼리 수행 뒤 10046 trace 결과 화면 )</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/oracle/oracle_archi5.png alt></p><pre><code>위에서
Misses in library cache during parse : 1
1은 hard parsing 을 의미 합니다.
</code></pre><ul><li>같은 쿼리 수행 후 trace 결과 화면<br>( Select num from trace_test 재수행 뒤 10046 trace 결과 )</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/oracle/oracle_archi6.png alt></p><pre><code>위에서
Misses in library cache during parse : 0
0은 soft parsing을 의미합니다
</code></pre><h3 id=오라클-기동-단계>오라클 기동 단계<a hidden class=anchor aria-hidden=true href=#오라클-기동-단계>#</a></h3><ul><li>NOMOUNT</li></ul><pre><code>nomount 단계에서는 initORACLE\_SID.ora 파라미터파일을 바탕으로 인스턴스 (SGA+Background process) 를 생성합니다. 그렇기 때문에 parameter file을 바탕으로 한 아래와 같은 정보만 조회 할 수 있습니다.

select * from v$instance;

select * from v$parameter;

select * from v$version;

show sga;
</code></pre><ul><li>MOUNT</li></ul><pre><code>Mount 단계에서는 instance와 Database 가 맞춰지는 단계로 모든 상태 정보를 읽어오게 됩니다.  
control file을 읽어서 데이터 파일이나 리두 로그 파일등의 위치와 상태만 알 뿐 실제 물리적인 파일이 열린 상태는 아닙니다.

select status from v$instance; ==&gt; (status =&gt; mounted)

select * from v$database;

select * from v$datafile;

select * from v$controlfile;

select * from v$logfile;
</code></pre><ul><li>OPEN</li></ul><pre><code>Open 단계에서는 컨트롤파일에서 읽은 DATA FILE 이나 ONLINE REDO LOG FILE 의 위치 및 OPEN 가능여부를 확인하고 데이터 베이스 일관성을 검사합니다.  
여기서 말하는 일관성이란  
모든 데이터 파일과 컨트롤 파일들이 같은 시점의 데이터들 인지 검증하기 위해 SCN을 비교하는 과정으로 recovery가 필요한지 불필요한지를 결정하는 중요한 단계라고 할 수 있습니다.
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/oracle/>oracle</a></li><li><a href=/tags/architecture/>architecture</a></li></ul></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>