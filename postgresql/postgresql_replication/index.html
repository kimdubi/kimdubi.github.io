<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PostgreSQL Replication 설정-Streaming Replication | kimDuBiA</title><meta name=keywords content="postgresql,replication"><meta name=description content="REPLICATION 방식 log shipping  file-based 복제로 master의 WAL file이 생성되면 이 파일을 scp를 통해 standby서버로 전달하여 반영함 wal file이 생길 때 까지 replication gap 이 발생할 수 있음  logical replication  pub / sub 구조로 양방향 replication 가능 특정 테이블만 복제하는 partial replication 가능 DDL 복제는 안되기 때문에 각각 수행해줘야함  streaming replication  Master는 standyby 에게 transaction log entires 를 전달하고 standby 는 WAL file을 기다리지 않고 record 단위로 복제 수행 일반적으로 가장 많이 사용되는 복제 방식  streaming replication 설정 1."><meta name=author content="kimdubi"><link rel=canonical href=/postgresql/postgresql_replication/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="PostgreSQL Replication 설정-Streaming Replication"><meta property="og:description" content="REPLICATION 방식 log shipping  file-based 복제로 master의 WAL file이 생성되면 이 파일을 scp를 통해 standby서버로 전달하여 반영함 wal file이 생길 때 까지 replication gap 이 발생할 수 있음  logical replication  pub / sub 구조로 양방향 replication 가능 특정 테이블만 복제하는 partial replication 가능 DDL 복제는 안되기 때문에 각각 수행해줘야함  streaming replication  Master는 standyby 에게 transaction log entires 를 전달하고 standby 는 WAL file을 기다리지 않고 record 단위로 복제 수행 일반적으로 가장 많이 사용되는 복제 방식  streaming replication 설정 1."><meta property="og:type" content="article"><meta property="og:url" content="/postgresql/postgresql_replication/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="postgresql"><meta property="article:published_time" content="2021-10-05T22:30:22+09:00"><meta property="article:modified_time" content="2021-10-05T22:30:22+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="PostgreSQL Replication 설정-Streaming Replication"><meta name=twitter:description content="REPLICATION 방식 log shipping  file-based 복제로 master의 WAL file이 생성되면 이 파일을 scp를 통해 standby서버로 전달하여 반영함 wal file이 생길 때 까지 replication gap 이 발생할 수 있음  logical replication  pub / sub 구조로 양방향 replication 가능 특정 테이블만 복제하는 partial replication 가능 DDL 복제는 안되기 때문에 각각 수행해줘야함  streaming replication  Master는 standyby 에게 transaction log entires 를 전달하고 standby 는 WAL file을 기다리지 않고 record 단위로 복제 수행 일반적으로 가장 많이 사용되는 복제 방식  streaming replication 설정 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Postgresqls","item":"/postgresql/"},{"@type":"ListItem","position":3,"name":"PostgreSQL Replication 설정-Streaming Replication","item":"/postgresql/postgresql_replication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL Replication 설정-Streaming Replication","name":"PostgreSQL Replication 설정-Streaming Replication","description":"REPLICATION 방식 log shipping  file-based 복제로 master의 WAL file이 생성되면 이 파일을 scp를 통해 standby서버로 전달하여 반영함 wal file이 생길 때 까지 replication gap 이 발생할 수 있음  logical replication  pub / sub 구조로 양방향 replication 가능 특정 테이블만 복제하는 partial replication 가능 DDL 복제는 안되기 때문에 각각 수행해줘야함  streaming replication  Master는 standyby 에게 transaction log entires 를 전달하고 standby 는 WAL file을 기다리지 않고 record 단위로 복제 수행 일반적으로 가장 많이 사용되는 복제 방식  streaming replication 설정 1.","keywords":["postgresql","replication"],"articleBody":" REPLICATION 방식 log shipping  file-based 복제로 master의 WAL file이 생성되면 이 파일을 scp를 통해 standby서버로 전달하여 반영함 wal file이 생길 때 까지 replication gap 이 발생할 수 있음  logical replication  pub / sub 구조로 양방향 replication 가능 특정 테이블만 복제하는 partial replication 가능 DDL 복제는 안되기 때문에 각각 수행해줘야함  streaming replication  Master는 standyby 에게 transaction log entires 를 전달하고 standby 는 WAL file을 기다리지 않고 record 단위로 복제 수행 일반적으로 가장 많이 사용되는 복제 방식  streaming replication 설정 1. replication 용 user 생성 (master) postgres=# create user repl replication password 'qhdks123'; CREATE ROLE postgres=# \\du List of roles Role name | Attributes | Member of -----------+------------------------------------------------------------+----------- kimdubi | Superuser, Create role, Create DB, Replication, Bypass RLS | {} repl | Replication | {} testuser | No inheritance +| {} | Password valid until infinity |  2. postgresql.conf 수정 (master)  vi /home1/kimdubi/psql/engn/PGSQL/postgresql.conf  wal_level = logical 또는 hot_standby archive_mode = on archive_command = 'cp %p /home1/kimdubi/psql/arch/testdb/%f' #max_wal_senders = 10 #max_replication_slots = 10  쌓이는 archive logfile은 아래와 같이 정리 필요  pg_archivecleanup /home1/kimdubi/psql/arch/testdb 000000010000000000000081.00000028.backup = xxxx.backup 이전의 아카이브 파일 모두 삭제\n postgresql.conf 수정 후 reload  pg_ctl reload -D /home1/kimdubi/psql/engn/PGSQL 3. pg_hba.conf 수정 (master)  vi /home1/kimdubi/psql/engn/PGSQL/postgresql.conf 아래 내용 추가  host replication repl 10.161.78.34/32 md5 = standby server (10.161.78.34) 에서 repl USER로 replication을 위해 오는 커넥션 요청은 md5로 인증해서 허가함\n pg_hba.conf 수정 후 reload  pg_ctl reload -D /home1/kimdubi/psql/engn/PGSQL 4. replication slot 생성 (master) postgres=# SELECT * FROM pg_create_physical_replication_slot('repl_slot_01'); slot_name | lsn --------------+----- repl_slot_01 | (1 row) postgres=# select * from pg_replication_slots; slot_name | plugin | slot_type | datoid | database | temporary | active | active_pid | xmin | catalog_xmin | restart_lsn | confirme d_flush_lsn --------------+--------+-----------+--------+----------+-----------+--------+------------+------+--------------+-------------+--------- ------------ repl_slot_01 | | physical | | | f | f | | | | | (1 row)  = standby 서버가 replication을 따라가지 못하는 경우를 대비하여 WAL 로그를 replication_slot에 두고 보관하겠다는 의미\nreplication_slot을 사용하면 wal_keep_segments 설정이 필요없음\n5. Primary DB server copy (standby) ### 기존 data 영역 삭제 [kimdubi@testserver2 15:37:09 ~/psql/engn ]$ rm -rf /home1/kimdubi/psql/engn/PGSQL ### Primary server = standby server copy [kimdubi@testserver2 15:40:06 ~/psql/engn ]$ pg_basebackup -h 11.111.11.11 -p3000 -D /home1/kimdubi/psql/engn/PGSQL -U repl -P -v -X stream Password: pg_basebackup: initiating base backup, waiting for checkpoint to complete pg_basebackup: checkpoint completed pg_basebackup: write-ahead log start point: 0/6000028 on timeline 1 pg_basebackup: starting background WAL receiver pg_basebackup: created temporary replication slot \"pg_basebackup_64119\" 31584/31584 kB (100%), 5/5 tablespaces pg_basebackup: write-ahead log end point: 0/60000F8 pg_basebackup: waiting for background process to finish streaming ... pg_basebackup: base backup completed   pg_basebackup -h primary_host -p primary_port -D PGDATA -U replication user  6. recovery.conf 설정 (standby)  vi /home1/kimdubi/psql/engn/PGSQL/recovery.conf  standby_mode = on primary_conninfo='host=11.111.11.11 port=3000 user=repl password=qhdks123' primary_slot_name='repl_slot_01' #trigger_file='/home1/kimdubi/psql/engn/PGSQL/failover_trigger' 7. DB 기동 (standby) [kimdubi@testserver2 15:45:23 ~/psql/engn/PGSQL ]$ pg_ctl -D /home1/kimdubi/psql/engn/PGSQL start waiting for server to start....2020-04-08 06:45:25 GMT LOG: listening on IPv4 address \"0.0.0.0\", port 3000 2020-04-08 06:45:25 GMT LOG: listening on IPv6 address \"::\", port 3000 2020-04-08 06:45:25 GMT LOG: listening on Unix socket \"/tmp/.s.PGSQL.3000\" 2020-04-08 06:45:25 GMT LOG: redirecting log output to logging collector process 2020-04-08 06:45:25 GMT HINT: Future log output will appear in directory \"/home1/kimdubi/psql/logs/testdb/error_log\". done server started  8. replication 확인  master  postgres=# select * from pg_stat_replication; -[ RECORD 1 ]----+----------------------------- pid | 65010 usesysid | 16396 usename | repl application_name | walreceiver client_addr | 22.222.22.22 client_hostname | client_port | 56754 backend_start | 2020-04-08 16:05:07.00658+09 backend_xmin | state | streaming sent_lsn | 0/B015A10 write_lsn | 0/B015A10 flush_lsn | 0/B015A10 replay_lsn | 0/B015A10 write_lag | flush_lag | replay_lag | sync_priority | 0 sync_state | async  slave  ### error_log 2020-04-08 07:05:07 GMT LOG: started streaming WAL from primary at 0/B000000 on timeline 1  replication delay 확인 (slave에서 조회)  SELECT CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() THEN 0 ELSE EXTRACT (EPOCH FROM now() - pg_last_xact_replay_timestamp()) END AS log_delay; log_delay ----------- 0 (1 row) replication 구성 중 발생가능 에러  standby = primary 접근 권한 없을 때  2020-04-08 15:23:50.883 KST [44534] FATAL: could not connect to the primary server: FATAL: no pg_hba.conf entry for replication connection from host \"22.222.22.22\", user \"repl\" = primary server의 접근허용 리스트에 standby 서버 정보가 없는 경우 발생함 primary에서 pg_hba.conf 에 standby 서버 추가 후 reload\n standby 서버 초기화 안했을 때  2020-04-08 15:26:51.084 KST [44642] FATAL: database system identifier differs between the primary and standby 2020-04-08 15:26:51.084 KST [44642] DETAIL: The primary's identifier is 6812776914427724112, the standby's identifier is 6813221629551992171. = standby 서버 $PGDATA 영역 삭제 후 다시 pg_basebackup 수행\n","wordCount":"713","inLanguage":"en","datePublished":"2021-10-05T22:30:22+09:00","dateModified":"2021-10-05T22:30:22+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/postgresql/postgresql_replication/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/postgresql/>Postgresqls</a></div><h1 class=post-title>PostgreSQL Replication 설정-Streaming Replication</h1><div class=post-meta>October 5, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#replication-%eb%b0%a9%ec%8b%9d aria-label="REPLICATION 방식">REPLICATION 방식</a><ul><li><a href=#log-shipping aria-label="log shipping">log shipping</a></li><li><a href=#logical-replication aria-label="logical replication">logical replication</a></li><li><a href=#streaming-replication aria-label="streaming replication">streaming replication</a></li></ul></li><li><a href=#streaming-replication-%ec%84%a4%ec%a0%95 aria-label="streaming replication 설정">streaming replication 설정</a><ul><li><a href=#1-replication-%ec%9a%a9-user-%ec%83%9d%ec%84%b1-master aria-label="1. replication 용 user 생성 (master)">1. replication 용 user 생성 (master)</a></li><li><a href=#2-postgresqlconf-%ec%88%98%ec%a0%95-master aria-label="2. postgresql.conf 수정 (master)">2. postgresql.conf 수정 (master)</a></li><li><a href=#3-pg_hbaconf-%ec%88%98%ec%a0%95-master aria-label="3. pg_hba.conf 수정 (master)">3. pg_hba.conf 수정 (master)</a></li><li><a href=#4-replication-slot-%ec%83%9d%ec%84%b1-master aria-label="4. replication slot 생성 (master)">4. replication slot 생성 (master)</a></li><li><a href=#5-primary-db-server-copy-standby aria-label="5. Primary DB server copy (standby)">5. Primary DB server copy (standby)</a></li><li><a href=#6-recoveryconf-%ec%84%a4%ec%a0%95-standby aria-label="6. recovery.conf 설정 (standby)">6. recovery.conf 설정 (standby)</a></li><li><a href=#7-db-%ea%b8%b0%eb%8f%99-standby aria-label="7. DB 기동 (standby)">7. DB 기동 (standby)</a></li><li><a href=#8-replication-%ed%99%95%ec%9d%b8 aria-label="8. replication 확인">8. replication 확인</a></li><li><a href=#replication-%ea%b5%ac%ec%84%b1-%ec%a4%91-%eb%b0%9c%ec%83%9d%ea%b0%80%eb%8a%a5-%ec%97%90%eb%9f%ac aria-label="replication 구성 중 발생가능 에러">replication 구성 중 발생가능 에러</a></li></ul></li></ul></div></details></div><div class=post-content><hr><h2 id=replication-방식>REPLICATION 방식<a hidden class=anchor aria-hidden=true href=#replication-방식>#</a></h2><h3 id=log-shipping>log shipping<a hidden class=anchor aria-hidden=true href=#log-shipping>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_repl1.png alt></p><ul><li>file-based 복제로 master의 WAL file이 생성되면 이 파일을 scp를 통해 standby서버로 전달하여 반영함</li><li>wal file이 생길 때 까지 replication gap 이 발생할 수 있음</li></ul><h3 id=logical-replication>logical replication<a hidden class=anchor aria-hidden=true href=#logical-replication>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_repl2.png alt></p><ul><li>pub / sub 구조로 양방향 replication 가능</li><li>특정 테이블만 복제하는 partial replication 가능</li><li>DDL 복제는 안되기 때문에 각각 수행해줘야함</li></ul><h3 id=streaming-replication>streaming replication<a hidden class=anchor aria-hidden=true href=#streaming-replication>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_repl3.png alt></p><ul><li>Master는 standyby 에게 transaction log entires 를 전달하고 standby 는 WAL file을 기다리지 않고 record 단위로 복제 수행</li><li>일반적으로 가장 많이 사용되는 복제 방식</li></ul><h2 id=streaming-replication-설정>streaming replication 설정<a hidden class=anchor aria-hidden=true href=#streaming-replication-설정>#</a></h2><h3 id=1-replication-용-user-생성-master>1. replication 용 user 생성 (master)<a hidden class=anchor aria-hidden=true href=#1-replication-용-user-생성-master>#</a></h3><pre><code>postgres=# create user repl replication password 'qhdks123';
CREATE ROLE

postgres=# \du
                                   List of roles
 Role name |                         Attributes                         | Member of
-----------+------------------------------------------------------------+-----------
 kimdubi    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 repl      | Replication                                                | {}
 testuser  | No inheritance                                            +| {}
           | Password valid until infinity                              |
</code></pre><h3 id=2-postgresqlconf-수정-master>2. postgresql.conf 수정 (master)<a hidden class=anchor aria-hidden=true href=#2-postgresqlconf-수정-master>#</a></h3><ul><li>vi /home1/kimdubi/psql/engn/PGSQL/postgresql.conf</li></ul><pre><code>wal_level = logical 또는 hot_standby
archive_mode = on
archive_command = 'cp %p /home1/kimdubi/psql/arch/testdb/%f'
#max_wal_senders = 10
#max_replication_slots = 10 
</code></pre><ul><li>쌓이는 archive logfile은 아래와 같이 정리 필요</li></ul><pre><code>pg_archivecleanup /home1/kimdubi/psql/arch/testdb 000000010000000000000081.00000028.backup
</code></pre><p>=> xxxx.backup 이전의 아카이브 파일 모두 삭제</p><ul><li>postgresql.conf 수정 후 reload</li></ul><pre><code>pg_ctl reload -D /home1/kimdubi/psql/engn/PGSQL
</code></pre><h3 id=3-pg_hbaconf-수정-master>3. pg_hba.conf 수정 (master)<a hidden class=anchor aria-hidden=true href=#3-pg_hbaconf-수정-master>#</a></h3><ul><li>vi /home1/kimdubi/psql/engn/PGSQL/postgresql.conf 아래 내용 추가</li></ul><pre><code>host    replication     repl             10.161.78.34/32            md5
</code></pre><p>=> standby server (10.161.78.34) 에서 repl USER로 replication을 위해 오는 커넥션 요청은 md5로 인증해서 허가함</p><ul><li>pg_hba.conf 수정 후 reload</li></ul><pre><code>pg_ctl reload -D /home1/kimdubi/psql/engn/PGSQL
</code></pre><h3 id=4-replication-slot-생성-master>4. replication slot 생성 (master)<a hidden class=anchor aria-hidden=true href=#4-replication-slot-생성-master>#</a></h3><pre><code>postgres=# SELECT * FROM pg_create_physical_replication_slot('repl_slot_01');
  slot_name   | lsn
--------------+-----
 repl_slot_01 |
(1 row)

postgres=# select * from pg_replication_slots;
  slot_name   | plugin | slot_type | datoid | database | temporary | active | active_pid | xmin | catalog_xmin | restart_lsn | confirme
d_flush_lsn
--------------+--------+-----------+--------+----------+-----------+--------+------------+------+--------------+-------------+---------
------------
 repl_slot_01 |        | physical  |        |          | f         | f      |            |      |              |             |
(1 row)
</code></pre><p>=> standby 서버가 replication을 따라가지 못하는 경우를 대비하여 WAL 로그를 replication_slot에 두고 보관하겠다는 의미<br>replication_slot을 사용하면 wal_keep_segments 설정이 필요없음</p><h3 id=5-primary-db-server-copy-standby>5. Primary DB server copy (standby)<a hidden class=anchor aria-hidden=true href=#5-primary-db-server-copy-standby>#</a></h3><pre><code>### 기존 data 영역 삭제 
[kimdubi@testserver2 15:37:09 ~/psql/engn ]$ rm -rf /home1/kimdubi/psql/engn/PGSQL

### Primary server =&gt; standby server copy

[kimdubi@testserver2 15:40:06 ~/psql/engn ]$ pg_basebackup -h 11.111.11.11 -p3000 -D /home1/kimdubi/psql/engn/PGSQL -U repl -P -v -X stream
Password:


pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/6000028 on timeline 1
pg_basebackup: starting background WAL receiver
pg_basebackup: created temporary replication slot &quot;pg_basebackup_64119&quot;
31584/31584 kB (100%), 5/5 tablespaces
pg_basebackup: write-ahead log end point: 0/60000F8
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: base backup completed
</code></pre><ul><li>pg_basebackup -h primary_host -p primary_port -D PGDATA -U replication user</li></ul><h3 id=6-recoveryconf-설정-standby>6. recovery.conf 설정 (standby)<a hidden class=anchor aria-hidden=true href=#6-recoveryconf-설정-standby>#</a></h3><ul><li>vi /home1/kimdubi/psql/engn/PGSQL/recovery.conf</li></ul><pre><code>standby_mode = on
primary_conninfo='host=11.111.11.11 port=3000 user=repl password=qhdks123'
primary_slot_name='repl_slot_01'
#trigger_file='/home1/kimdubi/psql/engn/PGSQL/failover_trigger'
</code></pre><h3 id=7-db-기동-standby>7. DB 기동 (standby)<a hidden class=anchor aria-hidden=true href=#7-db-기동-standby>#</a></h3><pre><code>[kimdubi@testserver2 15:45:23 ~/psql/engn/PGSQL ]$ pg_ctl -D /home1/kimdubi/psql/engn/PGSQL start

waiting for server to start....2020-04-08 06:45:25 GMT LOG:  listening on IPv4 address &quot;0.0.0.0&quot;, port 3000
2020-04-08 06:45:25 GMT LOG:  listening on IPv6 address &quot;::&quot;, port 3000
2020-04-08 06:45:25 GMT LOG:  listening on Unix socket &quot;/tmp/.s.PGSQL.3000&quot;
2020-04-08 06:45:25 GMT LOG:  redirecting log output to logging collector process
2020-04-08 06:45:25 GMT HINT:  Future log output will appear in directory &quot;/home1/kimdubi/psql/logs/testdb/error_log&quot;.
 done
server started
</code></pre><h3 id=8-replication-확인>8. replication 확인<a hidden class=anchor aria-hidden=true href=#8-replication-확인>#</a></h3><ul><li>master</li></ul><pre><code>postgres=# select * from pg_stat_replication;
-[ RECORD 1 ]----+-----------------------------
pid              | 65010
usesysid         | 16396
usename          | repl
application_name | walreceiver
client_addr      | 22.222.22.22
client_hostname  |
client_port      | 56754
backend_start    | 2020-04-08 16:05:07.00658+09
backend_xmin     |
state            | streaming
sent_lsn         | 0/B015A10
write_lsn        | 0/B015A10
flush_lsn        | 0/B015A10
replay_lsn       | 0/B015A10
write_lag        |
flush_lag        |
replay_lag       |
sync_priority    | 0
sync_state       | async
</code></pre><ul><li>slave</li></ul><pre><code>### error_log 
    
2020-04-08 07:05:07 GMT LOG:  started streaming WAL from primary at 0/B000000 on timeline 1
</code></pre><ul><li>replication delay 확인 (slave에서 조회)</li></ul><pre><code>SELECT CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn()
THEN 0
ELSE EXTRACT (EPOCH FROM now() - pg_last_xact_replay_timestamp())
END AS log_delay;


 log_delay
-----------
         0
(1 row)
</code></pre><h3 id=replication-구성-중-발생가능-에러>replication 구성 중 발생가능 에러<a hidden class=anchor aria-hidden=true href=#replication-구성-중-발생가능-에러>#</a></h3><ul><li>standby => primary 접근 권한 없을 때</li></ul><pre><code>2020-04-08 15:23:50.883 KST [44534] FATAL:  could not connect to the primary server: FATAL:  no pg_hba.conf entry for replication connection from host &quot;22.222.22.22&quot;, user &quot;repl&quot;
</code></pre><p>=> primary server의 접근허용 리스트에 standby 서버 정보가 없는 경우 발생함 primary에서 pg_hba.conf 에 standby 서버 추가 후 reload</p><ul><li>standby 서버 초기화 안했을 때</li></ul><pre><code>2020-04-08 15:26:51.084 KST [44642] FATAL:  database system identifier differs between the primary and standby
2020-04-08 15:26:51.084 KST [44642] DETAIL:  The primary's identifier is 6812776914427724112, the standby's identifier is 6813221629551992171.
</code></pre><p>=> standby 서버 $PGDATA 영역 삭제 후 다시 pg_basebackup 수행</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/postgresql/>postgresql</a></li><li><a href=/tags/replication/>replication</a></li></ul></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>