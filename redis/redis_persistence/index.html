<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis AOF와 RDB에 대해 | kimDuBiA</title><meta name=keywords content="redis"><meta name=description content="Redis 와 Memcached 를 가장 크게 구분짓는 특징은 무엇일까요?
간단하게는 아래와 같은 특징들이 있는데
 Key-Value 만 지원하는 Memcached 에 비해 Key-value , list , hash , set , sorted set 다양한 자료구조를 지원 Redis의 데이터를 디스크로 저장하는 Persistent 기능  이번 글에서는 그 중에서도 data 영속성에 대해 다뤄보겠습니다.
RDB Redis 인스턴스의 현재 메모리에 대한 dump (스냅샷) 를 생성하는 기능
RDB 설정 save &#34;&#34; #save 900 1 #save 300 10 #save 60 10000 rdbchecksum yes stop-writes-on-bgsave-error no rdbcompression yes dbfilename redis_6001."><meta name=author content="kimdubi"><link rel=canonical href=/redis/redis_persistence/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="Redis AOF와 RDB에 대해"><meta property="og:description" content="Redis 와 Memcached 를 가장 크게 구분짓는 특징은 무엇일까요?
간단하게는 아래와 같은 특징들이 있는데
 Key-Value 만 지원하는 Memcached 에 비해 Key-value , list , hash , set , sorted set 다양한 자료구조를 지원 Redis의 데이터를 디스크로 저장하는 Persistent 기능  이번 글에서는 그 중에서도 data 영속성에 대해 다뤄보겠습니다.
RDB Redis 인스턴스의 현재 메모리에 대한 dump (스냅샷) 를 생성하는 기능
RDB 설정 save &#34;&#34; #save 900 1 #save 300 10 #save 60 10000 rdbchecksum yes stop-writes-on-bgsave-error no rdbcompression yes dbfilename redis_6001."><meta property="og:type" content="article"><meta property="og:url" content="/redis/redis_persistence/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="redis"><meta property="article:published_time" content="2021-10-04T22:27:34+09:00"><meta property="article:modified_time" content="2021-10-04T22:27:34+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Redis AOF와 RDB에 대해"><meta name=twitter:description content="Redis 와 Memcached 를 가장 크게 구분짓는 특징은 무엇일까요?
간단하게는 아래와 같은 특징들이 있는데
 Key-Value 만 지원하는 Memcached 에 비해 Key-value , list , hash , set , sorted set 다양한 자료구조를 지원 Redis의 데이터를 디스크로 저장하는 Persistent 기능  이번 글에서는 그 중에서도 data 영속성에 대해 다뤄보겠습니다.
RDB Redis 인스턴스의 현재 메모리에 대한 dump (스냅샷) 를 생성하는 기능
RDB 설정 save &#34;&#34; #save 900 1 #save 300 10 #save 60 10000 rdbchecksum yes stop-writes-on-bgsave-error no rdbcompression yes dbfilename redis_6001."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Redis","item":"/redis/"},{"@type":"ListItem","position":3,"name":"Redis AOF와 RDB에 대해","item":"/redis/redis_persistence/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis AOF와 RDB에 대해","name":"Redis AOF와 RDB에 대해","description":"Redis 와 Memcached 를 가장 크게 구분짓는 특징은 무엇일까요?\n간단하게는 아래와 같은 특징들이 있는데\n Key-Value 만 지원하는 Memcached 에 비해 Key-value , list , hash , set , sorted set 다양한 자료구조를 지원 Redis의 데이터를 디스크로 저장하는 Persistent 기능  이번 글에서는 그 중에서도 data 영속성에 대해 다뤄보겠습니다.\nRDB Redis 인스턴스의 현재 메모리에 대한 dump (스냅샷) 를 생성하는 기능\nRDB 설정 save \u0026quot;\u0026quot; #save 900 1 #save 300 10 #save 60 10000 rdbchecksum yes stop-writes-on-bgsave-error no rdbcompression yes dbfilename redis_6001.","keywords":["redis"],"articleBody":" Redis 와 Memcached 를 가장 크게 구분짓는 특징은 무엇일까요?\n간단하게는 아래와 같은 특징들이 있는데\n Key-Value 만 지원하는 Memcached 에 비해 Key-value , list , hash , set , sorted set 다양한 자료구조를 지원 Redis의 데이터를 디스크로 저장하는 Persistent 기능  이번 글에서는 그 중에서도 data 영속성에 대해 다뤄보겠습니다.\nRDB Redis 인스턴스의 현재 메모리에 대한 dump (스냅샷) 를 생성하는 기능\nRDB 설정 save \"\" #save 900 1 #save 300 10 #save 60 10000 rdbchecksum yes stop-writes-on-bgsave-error no rdbcompression yes dbfilename redis_6001.rdb   save : save seconds changes 의 형태  save 900 1 = 900초 안에 1번 이상의 변경이 생기면 RDB 생성하겠다는 의미 save “” = 자동으로 RDB를 생성하지 않고 수동으로 bgsave , save 커맨드를 통해 생성하겠다는 의미 bgsave : RDB 생성 작업을 backgroundd process 로 수행 save : redis의 single thread로 RDB 생성작업을 수행하기 때문에 다른 모든 작업이 대기하게됨   rdbchecksum : rdb 파일이 정상적으로 저장되었는지 checksum 을 파일의 끝에 넣는 옵션 stop-writes-on-bgsave-error : RDB 저장이 실패하는 경우 write blocking 하는 기능으로 read 는 가능함  디스크 여유공간이 없을 때 RDB 생성 중 메모리 부족으로 작업 실패 기타 등등의 이유로 실패함    127.0.0.1:6379 bgsave 102:M 08 Mar 2020 06:11:07.159 * Background saving started by pid 125 Background saving started 127.0.0.1:6379 125:C 08 Mar 2020 06:11:07.160 # Failed opening the RDB file dump.rdb (in server root dir unknown) for saving: No such file or directory 102:M 08 Mar 2020 06:11:07.220 # Background saving error 127.0.0.1:6379 127.0.0.1:6379 set a 1 (error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error. = RDB 작업 실패로 write blocking 된 현상\n rdbcompression : rdb dump파일 압축 여부, 압축 알고리즘은 LZF dbfilename : rdb dump파일의 이름 설정  RDB 관련 info 조회 127.0.0.1:6379 info persistence # Persistence loading:0 rdb_changes_since_last_save:1 rdb_bgsave_in_progress:0 rdb_last_save_time:1583647845 rdb_last_bgsave_status:err rdb_last_bgsave_time_sec:0 rdb_current_bgsave_time_sec:-1 rdb_last_cow_size:180224  = 마지막 RDB 작업 성공 여부, 걸린 시간 등을 파악할 수 있음\nRDB 주의할 점 save 커맨드 수행 시엔 조심 !!  save 는 single thread로 수행하기 때문에 작업이 완료되기 까지 모든 요청이 대기하게됨 bgsave 커맨드로 background 자식 프로세스를 통해 RDB 작업 수행하도록 할 것  bgsave 커맨드 수행 시엔 memory 사용률 조심!!   redis 서비스에서 사용중인 데이터는 모두 메모리 위에 있는데 이를 “서비스 영향 없이” 스냅샷으로 저장하기 위해서는 Copy-on-Write(COW) 방식을 사용함\n자식 프로세스 fork() 후 부모 프로세스의 메모리에서 실제로 변경이 발생한 부분만 복사하게 되는데\nwrite 작업이 많아서 부모 페이지 전부에 변경이 발생하게 되면 부모 페이지 전부를 복사하게 됨   서버 physical memory 10GB, redis memory 6GB 사용하는 서비스에서 RDB 수행 중 COW 발생하여 메모리 두배가 필요하여 2GB 부족한 상황이 되면 swap 이 발생하여 서비스 지연이 발생하게 되므로redis의 max-memory 설정을 주의깊게 할 것!!\n  save 는 redis process가 직접 수행하여 COW 발생하지 않음\n  AOF AOF (Append Only File) 는 redis 에서 데이터 변경이 일어나는 커맨드를 AOF 파일에 기록하는 방식\nRDBMS WAL (Write Ahead Logging) 처럼 아래와 같은 순서로 동작함\n client 가 redis로 데이터 변경 관련 (조회 제외 insert,update,delete) 요청 Redis 는 해당 command 를 AOF buffer 에 저장함 redis memory의 내용 변경 appendfsync 설정에 따라 AOF buffer의 내용을 AOF 파일로 내려씀  AOF 설정 appendonly no appendfsync no auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64MB appendfilename redis_appendonly_6001.aof   appendonly : AOF 기능 사용 여부 appendfsync : AOF buffer 의 내용을 AOF file로 내려쓰는 주기 설정  always : update 관련 커맨드 마다 fsync 호출하여 AOF 로 내려씀, redis 성능을 지연시킬 수 있음 everysec : 매초마다 fsync, 성능 지연은 없으나 1초의 데이터가 유실될 수 있음 no : OS에 맡김   auto-aof-rewrite-percentage : AOF 파일 다시 쓰는 시점 설정하는 옵션으로 100으로 설정시 이전 AOF파일의 크기 100% 도달 시 다시쓰기 수행  AOF 는 데이터 변경 관련 커맨드를 모두 로깅하기 때문에 과거의 데이터 변경 관련 커맨드도 갖고 있어 redis 메모리의 데이터보다도 커질 수 있음 bgrewriteaof 커맨드를 통해 수행되며 bg, background로 수행되기 때문에 마찬가지로 COW 발생   auto-aof-rewrite-min-size : redis 처음 시작 후 AOF 파일 사이즈가 0일 때 auto-aof-rewrite-percentage 대신 적용됨, ex) AOF 파일 64MB되면 다시쓰기 appendfilename : AOF 파일 이름 설정  AOF 관련 info 조회 aof_enabled:1 aof_rewrite_in_progress:0 aof_rewrite_scheduled:0 aof_last_rewrite_time_sec:0 aof_current_rewrite_time_sec:-1 aof_last_bgrewrite_status:ok aof_last_write_status:ok aof_last_cow_size:200704 aof_current_size:152 aof_base_size:102 aof_pending_rewrite:0 aof_buffer_length:0 aof_rewrite_buffer_length:0 aof_pending_bio_fsync:0 aof_delayed_fsync:0   aof_base_size , aof_current_size 를 비교하여 aof_current_size가 auto-aof-rewrite-percentage 이상 되면 bgrewriteaof 수행  AOF 와 RDB 무엇을 먼저 읽을까?  redis config 상 appendonly yes = AOF 파일 읽음 appendonly no = rdb 파일 읽음  void loadDataFromDisk(void) { long long start = ustime(); if (server.aof_state == AOF_ON) { if (loadAppendOnlyFile(server.aof_filename) == C_OK) serverLog(LL_NOTICE,\"DB loaded from append only file: %.3f seconds\",(float)(ustime()-start)/1000000); } else { rdbSaveInfo rsi = RDB_SAVE_INFO_INIT; if (rdbLoad(server.rdb_filename,\u0026rsi) == C_OK) { serverLog(LL_NOTICE,\"DB loaded from disk: %.3f seconds\", (float)(ustime()-start)/1000000); = redis source code를 보면 AOF on 일 땐 AOF 파일을, off 일 땐 RDB을 읽음\n그러나 AOF on 인데 AOF 파일이 없다고 RDB파일을 읽진 않으며 반대도 마찬가지임\n","wordCount":"784","inLanguage":"en","datePublished":"2021-10-04T22:27:34+09:00","dateModified":"2021-10-04T22:27:34+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/redis/redis_persistence/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/redis/>Redis</a></div><h1 class=post-title>Redis AOF와 RDB에 대해</h1><div class=post-meta>October 4, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rdb aria-label=RDB>RDB</a><ul><li><a href=#rdb-%ec%84%a4%ec%a0%95 aria-label="RDB 설정">RDB 설정</a></li><li><a href=#rdb-%ea%b4%80%eb%a0%a8-info-%ec%a1%b0%ed%9a%8c aria-label="RDB 관련 info 조회">RDB 관련 info 조회</a></li></ul></li><li><a href=#rdb-%ec%a3%bc%ec%9d%98%ed%95%a0-%ec%a0%90 aria-label="RDB 주의할 점">RDB 주의할 점</a><ul><li><a href=#save-%ec%bb%a4%eb%a7%a8%eb%93%9c-%ec%88%98%ed%96%89-%ec%8b%9c%ec%97%94-%ec%a1%b0%ec%8b%ac- aria-label="save 커맨드 수행 시엔 조심 !!">save 커맨드 수행 시엔 조심 !!</a></li><li><a href=#bgsave-%ec%bb%a4%eb%a7%a8%eb%93%9c-%ec%88%98%ed%96%89-%ec%8b%9c%ec%97%94-memory-%ec%82%ac%ec%9a%a9%eb%a5%a0-%ec%a1%b0%ec%8b%ac aria-label="bgsave 커맨드 수행 시엔 memory 사용률 조심!!">bgsave 커맨드 수행 시엔 memory 사용률 조심!!</a></li></ul></li><li><a href=#aof aria-label=AOF>AOF</a><ul><li><a href=#aof-%ec%84%a4%ec%a0%95 aria-label="AOF 설정">AOF 설정</a></li><li><a href=#aof-%ea%b4%80%eb%a0%a8-info-%ec%a1%b0%ed%9a%8c aria-label="AOF 관련 info 조회">AOF 관련 info 조회</a></li><li><a href=#aof-%ec%99%80-rdb-%eb%ac%b4%ec%97%87%ec%9d%84-%eb%a8%bc%ec%a0%80-%ec%9d%bd%ec%9d%84%ea%b9%8c aria-label="AOF 와 RDB 무엇을 먼저 읽을까?">AOF 와 RDB 무엇을 먼저 읽을까?</a></li></ul></li></ul></div></details></div><div class=post-content><hr><p>Redis 와 Memcached 를 가장 크게 구분짓는 특징은 무엇일까요?<br>간단하게는 아래와 같은 특징들이 있는데</p><ul><li>Key-Value 만 지원하는 Memcached 에 비해 Key-value , list , hash , set , sorted set 다양한 자료구조를 지원</li><li>Redis의 데이터를 디스크로 저장하는 Persistent 기능</li></ul><p>이번 글에서는 그 중에서도 data 영속성에 대해 다뤄보겠습니다.</p><h3 id=rdb>RDB<a hidden class=anchor aria-hidden=true href=#rdb>#</a></h3><p>Redis 인스턴스의 현재 메모리에 대한 dump (스냅샷) 를 생성하는 기능</p><h4 id=rdb-설정>RDB 설정<a hidden class=anchor aria-hidden=true href=#rdb-설정>#</a></h4><pre><code>save &quot;&quot;
#save 900 1
#save 300 10
#save 60 10000

rdbchecksum yes
stop-writes-on-bgsave-error no
rdbcompression yes

dbfilename redis_6001.rdb
</code></pre><ul><li>save : save seconds changes 의 형태<ul><li>save 900 1 => 900초 안에 1번 이상의 변경이 생기면 RDB 생성하겠다는 의미</li><li>save &ldquo;” => 자동으로 RDB를 생성하지 않고 수동으로 bgsave , save 커맨드를 통해 생성하겠다는 의미</li><li>bgsave : RDB 생성 작업을 backgroundd process 로 수행</li><li>save : redis의 single thread로 RDB 생성작업을 수행하기 때문에 다른 모든 작업이 대기하게됨</li></ul></li><li>rdbchecksum : rdb 파일이 정상적으로 저장되었는지 checksum 을 파일의 끝에 넣는 옵션</li><li>stop-writes-on-bgsave-error : RDB 저장이 실패하는 경우 write blocking 하는 기능으로 read 는 가능함<ul><li>디스크 여유공간이 없을 때</li><li>RDB 생성 중 메모리 부족으로 작업 실패</li><li>기타 등등의 이유로 실패함</li></ul></li></ul><pre><code>127.0.0.1:6379&gt; bgsave
102:M 08 Mar 2020 06:11:07.159 * Background saving started by pid 125
Background saving started
127.0.0.1:6379&gt; 125:C 08 Mar 2020 06:11:07.160 # Failed opening the RDB file dump.rdb (in server root dir unknown) for saving: No such file or directory
102:M 08 Mar 2020 06:11:07.220 # Background saving error


127.0.0.1:6379&gt;
127.0.0.1:6379&gt; set a 1
    
(error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.
</code></pre><p>=> RDB 작업 실패로 write blocking 된 현상</p><ul><li>rdbcompression : rdb dump파일 압축 여부, 압축 알고리즘은 LZF</li><li>dbfilename : rdb dump파일의 이름 설정</li></ul><h4 id=rdb-관련-info-조회>RDB 관련 info 조회<a hidden class=anchor aria-hidden=true href=#rdb-관련-info-조회>#</a></h4><pre><code>127.0.0.1:6379&gt; info persistence
# Persistence
loading:0
rdb_changes_since_last_save:1
rdb_bgsave_in_progress:0
rdb_last_save_time:1583647845
rdb_last_bgsave_status:err
rdb_last_bgsave_time_sec:0
rdb_current_bgsave_time_sec:-1
rdb_last_cow_size:180224
</code></pre><p>=> 마지막 RDB 작업 성공 여부, 걸린 시간 등을 파악할 수 있음</p><h3 id=rdb-주의할-점>RDB 주의할 점<a hidden class=anchor aria-hidden=true href=#rdb-주의할-점>#</a></h3><h4 id=save-커맨드-수행-시엔-조심->save 커맨드 수행 시엔 조심 !!<a hidden class=anchor aria-hidden=true href=#save-커맨드-수행-시엔-조심->#</a></h4><ul><li>save 는 single thread로 수행하기 때문에 작업이 완료되기 까지 모든 요청이 대기하게됨</li><li>bgsave 커맨드로 background 자식 프로세스를 통해 RDB 작업 수행하도록 할 것</li></ul><h4 id=bgsave-커맨드-수행-시엔-memory-사용률-조심>bgsave 커맨드 수행 시엔 memory 사용률 조심!!<a hidden class=anchor aria-hidden=true href=#bgsave-커맨드-수행-시엔-memory-사용률-조심>#</a></h4><ul><li><p>redis 서비스에서 사용중인 데이터는 모두 메모리 위에 있는데 이를 “서비스 영향 없이” 스냅샷으로 저장하기 위해서는 Copy-on-Write(COW) 방식을 사용함<br>자식 프로세스 fork() 후 부모 프로세스의 메모리에서 실제로 변경이 발생한 부분만 복사하게 되는데<br>write 작업이 많아서 부모 페이지 전부에 변경이 발생하게 되면 부모 페이지 전부를 복사하게 됨 <img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_cow1.png alt>
<img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_cow2.png alt></p></li><li><p>서버 physical memory 10GB, redis memory 6GB 사용하는 서비스에서 RDB 수행 중 COW 발생하여 메모리 두배가 필요하여 2GB 부족한 상황이 되면 swap 이 발생하여 서비스 지연이 발생하게 되므로redis의 max-memory 설정을 주의깊게 할 것!!</p></li><li><p>save 는 redis process가 직접 수행하여 COW 발생하지 않음</p></li></ul><h3 id=aof>AOF<a hidden class=anchor aria-hidden=true href=#aof>#</a></h3><p>AOF (Append Only File) 는 redis 에서 데이터 변경이 일어나는 커맨드를 AOF 파일에 기록하는 방식<br>RDBMS WAL (Write Ahead Logging) 처럼 아래와 같은 순서로 동작함</p><ul><li>client 가 redis로 데이터 변경 관련 (조회 제외 insert,update,delete) 요청</li><li>Redis 는 해당 command 를 AOF buffer 에 저장함</li><li>redis memory의 내용 변경</li><li>appendfsync 설정에 따라 AOF buffer의 내용을 AOF 파일로 내려씀</li></ul><h4 id=aof-설정>AOF 설정<a hidden class=anchor aria-hidden=true href=#aof-설정>#</a></h4><pre><code>appendonly no
appendfsync no

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64MB

appendfilename redis_appendonly_6001.aof
</code></pre><ul><li>appendonly : AOF 기능 사용 여부</li><li>appendfsync : AOF buffer 의 내용을 AOF file로 내려쓰는 주기 설정<ul><li>always : update 관련 커맨드 마다 fsync 호출하여 AOF 로 내려씀, redis 성능을 지연시킬 수 있음</li><li>everysec : 매초마다 fsync, 성능 지연은 없으나 1초의 데이터가 유실될 수 있음</li><li>no : OS에 맡김</li></ul></li><li>auto-aof-rewrite-percentage : AOF 파일 다시 쓰는 시점 설정하는 옵션으로 100으로 설정시 이전 AOF파일의 크기 100% 도달 시 다시쓰기 수행<ul><li>AOF 는 데이터 변경 관련 커맨드를 모두 로깅하기 때문에 과거의 데이터 변경 관련 커맨드도 갖고 있어 redis 메모리의 데이터보다도 커질 수 있음</li><li>bgrewriteaof 커맨드를 통해 수행되며 bg, background로 수행되기 때문에 마찬가지로 COW 발생</li></ul></li><li>auto-aof-rewrite-min-size : redis 처음 시작 후 AOF 파일 사이즈가 0일 때 auto-aof-rewrite-percentage 대신 적용됨, ex) AOF 파일 64MB되면 다시쓰기</li><li>appendfilename : AOF 파일 이름 설정</li></ul><h4 id=aof-관련-info-조회>AOF 관련 info 조회<a hidden class=anchor aria-hidden=true href=#aof-관련-info-조회>#</a></h4><pre><code>aof_enabled:1
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:0
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok
aof_last_cow_size:200704
aof_current_size:152
aof_base_size:102
aof_pending_rewrite:0
aof_buffer_length:0
aof_rewrite_buffer_length:0
aof_pending_bio_fsync:0
aof_delayed_fsync:0
</code></pre><ul><li>aof_base_size , aof_current_size 를 비교하여 aof_current_size가 auto-aof-rewrite-percentage 이상 되면 bgrewriteaof 수행</li></ul><h4 id=aof-와-rdb-무엇을-먼저-읽을까>AOF 와 RDB 무엇을 먼저 읽을까?<a hidden class=anchor aria-hidden=true href=#aof-와-rdb-무엇을-먼저-읽을까>#</a></h4><ul><li>redis config 상 appendonly yes => AOF 파일 읽음</li><li>appendonly no => rdb 파일 읽음</li></ul><pre><code>void loadDataFromDisk(void) {
    long long start = ustime();
    if (server.aof_state == AOF_ON) {
        if (loadAppendOnlyFile(server.aof_filename) == C_OK)
            serverLog(LL_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);
    } else {
        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
        if (rdbLoad(server.rdb_filename,&amp;rsi) == C_OK) {
            serverLog(LL_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,
                (float)(ustime()-start)/1000000);
</code></pre><p>=> redis source code를 보면 AOF on 일 땐 AOF 파일을, off 일 땐 RDB을 읽음<br>그러나 AOF on 인데 AOF 파일이 없다고 RDB파일을 읽진 않으며 반대도 마찬가지임</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/redis/>redis</a></li></ul></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>