<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis memory fragmentation 해소하기(activedefrag) | kimDuBiA</title><meta name=keywords content="redis"><meta name=description content="이슈상황  Redis를 maxmemory 까지 쓰는 상황 지속적으로 set 커맨드가 유입되고 이로 인해 key eviction이 발생하면서 memory 단편화가 심해짐 이는 곧 서버 메모리 사용량 상승을 초래하고 심하면 OOME 까지도 유발할 수 있음 Replica도 Master와 같은 데이터를 처리하기 때문에 memory fragmentation 현상도 동일하게 겪게되어 Replica도 동일하게 OOME 발생위험이 있음 아래 모니터링 지표는 NHN cloud의 EasyCache에서 제공하는 기능임  redis memory(rss) 서버 메모리 memory fragmentation key eviction set / get call activedefrag?"><meta name=author content="kimdubi"><link rel=canonical href=/redis/redis_activedefrag/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="Redis memory fragmentation 해소하기(activedefrag)"><meta property="og:description" content="이슈상황  Redis를 maxmemory 까지 쓰는 상황 지속적으로 set 커맨드가 유입되고 이로 인해 key eviction이 발생하면서 memory 단편화가 심해짐 이는 곧 서버 메모리 사용량 상승을 초래하고 심하면 OOME 까지도 유발할 수 있음 Replica도 Master와 같은 데이터를 처리하기 때문에 memory fragmentation 현상도 동일하게 겪게되어 Replica도 동일하게 OOME 발생위험이 있음 아래 모니터링 지표는 NHN cloud의 EasyCache에서 제공하는 기능임  redis memory(rss) 서버 메모리 memory fragmentation key eviction set / get call activedefrag?"><meta property="og:type" content="article"><meta property="og:url" content="/redis/redis_activedefrag/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="redis"><meta property="article:published_time" content="2021-10-04T23:38:09+09:00"><meta property="article:modified_time" content="2021-10-04T23:38:09+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Redis memory fragmentation 해소하기(activedefrag)"><meta name=twitter:description content="이슈상황  Redis를 maxmemory 까지 쓰는 상황 지속적으로 set 커맨드가 유입되고 이로 인해 key eviction이 발생하면서 memory 단편화가 심해짐 이는 곧 서버 메모리 사용량 상승을 초래하고 심하면 OOME 까지도 유발할 수 있음 Replica도 Master와 같은 데이터를 처리하기 때문에 memory fragmentation 현상도 동일하게 겪게되어 Replica도 동일하게 OOME 발생위험이 있음 아래 모니터링 지표는 NHN cloud의 EasyCache에서 제공하는 기능임  redis memory(rss) 서버 메모리 memory fragmentation key eviction set / get call activedefrag?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Redis","item":"/redis/"},{"@type":"ListItem","position":3,"name":"Redis memory fragmentation 해소하기(activedefrag)","item":"/redis/redis_activedefrag/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis memory fragmentation 해소하기(activedefrag)","name":"Redis memory fragmentation 해소하기(activedefrag)","description":"이슈상황  Redis를 maxmemory 까지 쓰는 상황 지속적으로 set 커맨드가 유입되고 이로 인해 key eviction이 발생하면서 memory 단편화가 심해짐 이는 곧 서버 메모리 사용량 상승을 초래하고 심하면 OOME 까지도 유발할 수 있음 Replica도 Master와 같은 데이터를 처리하기 때문에 memory fragmentation 현상도 동일하게 겪게되어 Replica도 동일하게 OOME 발생위험이 있음 아래 모니터링 지표는 NHN cloud의 EasyCache에서 제공하는 기능임  redis memory(rss) 서버 메모리 memory fragmentation key eviction set / get call activedefrag?","keywords":["redis"],"articleBody":" 이슈상황  Redis를 maxmemory 까지 쓰는 상황 지속적으로 set 커맨드가 유입되고 이로 인해 key eviction이 발생하면서 memory 단편화가 심해짐 이는 곧 서버 메모리 사용량 상승을 초래하고 심하면 OOME 까지도 유발할 수 있음 Replica도 Master와 같은 데이터를 처리하기 때문에 memory fragmentation 현상도 동일하게 겪게되어 Replica도 동일하게 OOME 발생위험이 있음 아래 모니터링 지표는 NHN cloud의 EasyCache에서 제공하는 기능임  redis memory(rss) 서버 메모리 memory fragmentation key eviction set / get call activedefrag? Redis key를 메모리에 할당할 때 연속적인 block에 할당하게 되고 key가 삭제되면 그 공간도 비워주게됨\n만약 새로 들어오는 key의 크기가 균일하지 않고 들쭉날쭉하면 비워진 block에 key를 할당할 수 없게되어 새로운 연속된 block을 찾아 key를 할당하게 됨\n이런 현상이 심해지면 군데군데 이 빠진 fragmentation 이 심해져 실제 Redis memory 사용량 보다 더 많은 서버 memory를 차지하게 되는데\n이러한 fragmentation을 online 중에 정리할 수 있는 기능이 activcedefrag 기능임\nRedis 4.0 부터 사용가능하며 5.0부터 많이 안정화 되었다고함\n발동 조건   ACTIVE-DEFRAG-IGNORE-BYTES :\n 조각모음을 시작하기 위한 최소량 info memory에서 조회된 allocator_frag_bytes = active - allocated 값이 설정한 값보다 작으면 activedefrag 하지 않음. default 100MB    ACTIVE-DEFRAG-THRESHOLD-LOWER\n 조각모음을 시작할 최소 조각화 비율 allocator_frag_ratio = active / allocated 값이 설정한 값보다 작으면 activedefrag 수행하지않음 default 10%    mem_allocator\n jemalloc 을 사용해야 하며 linux에서 Redis 설치 시 default임    두 조건이 모두 만족할 때 수행됨\n  127.0.0.1:6379 config get ACTIVE-DEFRAG-IGNORE-BYTES 1) \"active-defrag-ignore-bytes\" 2) \"104857600\" 127.0.0.1:6379 config get ACTIVE-DEFRAG-THRESHOLD-LOWER 1) \"active-defrag-threshold-lower\" 2) \"10\" 원리  연속된 free memory block을 만들어주기 위해 중간에 알박기 하고있는 데이터를 옆으로 이동시키고 memory block을 병합시키는 원리인듯함  효과 빨간선 - REPLICA, activedefrag 비활성\n파란선 - MASTER, activedefrag 활성\nredis memory(rss) 서버메모리 memory fragmentation defrag 수행 전 / 후 지표 수행 전 OS CPU / 메모리  PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 13119 redis 20 0 9570612 6.358g 1380 S 0.0 83.2 1969:27 redis-server  redis info # Memory used_memory_human:5.38G used_memory_rss_human:6.33G used_memory_peak_human:5.39G allocator_allocated:5782084072 allocator_active:6677209088 total_system_memory_human:7.64G maxmemory_human:5.38G allocator_frag_bytes:922989456 allocator_frag_ratio:1.15 mem_fragmentation_ratio:1.18 mem_allocator:jemalloc-5.1.0 active_defrag_running:0 # Stats active_defrag_hits:0 active_defrag_misses:0 active_defrag_key_hits:0 active_defrag_key_misses:0   실제 Redis 메모리 사용량은 used_memory_human:5.38G mem_fragmentation_ratio:1.18 에 달해 서버 메모리 used_memory_rss_human:6.33G 까지 쓰고있는 상황 정리 대상 fragmentation data 크기는 allocator_frag_bytes:922989456, 900MB정도 allocator_frag_ratio:1.15 비율은 10%를 넘긴 상황 발동조건이 만족되었기 때문에 activedefrag yes로 설정 시 activedefrag 기능이 바로 수행될 것임  수행 중 activedefrag yes 127.0.0.1:6379 redisconfig set activedefrag yes OK  OS CPU / 메모리 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 13119 redis 20 0 9570612 6.359g 1408 S 8.8 83.2 1969:28 redis-server  redis info # Memory used_memory_human:5.39G used_memory_rss_human:5.79G used_memory_peak_human:5.39G allocator_allocated:5785638544 allocator_active:6075428864 total_system_memory_human:7.64G maxmemory_human:5.38G allocator_frag_ratio:1.05 mem_fragmentation_ratio:1.07 mem_allocator:jemalloc-5.1.0 active_defrag_running:9   active_defrag_running : 9 , active_defrag가 돌면서 메모리도 많이 정리되는 중임 activedefrag 돌면서 CPU는 조금 쓰는 모습  수행 후 OS CPU / 메모리 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 13119 redis 20 0 9570612 6.359g 1408 S 1.1 72.9 1969:28 redis-server  redis info # Memory used_memory_human:5.38G used_memory_rss_human:5.55G used_memory_peak_human:5.39G allocator_allocated:5781963352 allocator_active:5837156352 total_system_memory_human:7.64G maxmemory_human:5.38G allocator_frag_bytes:83108768 allocator_frag_ratio:1.01 mem_fragmentation_ratio:1.03 mem_allocator:jemalloc-5.1.0 active_defrag_running:0 # Stats active_defrag_hits:5134002 active_defrag_misses:23330219 active_defrag_key_hits:2994915 active_defrag_key_misses:3473898  정리  메모리 단편화가 심할 때 activedefarg 켜주면 효과가 정말 좋음  메모리 빡빡하게 쓰는 서비스는 항시 켜놓는 것이 좋을듯   운영 중 set / get 커맨드가 많이 들어오는 환경에서도 서비스에 이슈 없음 defrag 정리 중 CPU만 조금 쓰는데 미비한 수준, CPU limit 관련 설정도 있는데 굳이 건드릴 필요 없을듯 정확히 시간은 체크 못했으나 6.33G - 5.55G 약 1GB 정리하는데 10분안쪽으로 소요된듯 maxmemory 를 해소하는 건 아님!! maxmeomry 는 별개로 redis 스펙업 해줘야함, activedefrag는 단편화 해소하는 기능 관련 설정은 http://redisgate.kr/redis/server/redis_conf_han.php 참고  ","wordCount":"545","inLanguage":"en","datePublished":"2021-10-04T23:38:09+09:00","dateModified":"2021-10-04T23:38:09+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/redis/redis_activedefrag/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/redis/>Redis</a></div><h1 class=post-title>Redis memory fragmentation 해소하기(activedefrag)</h1><div class=post-meta>October 4, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%9d%b4%ec%8a%88%ec%83%81%ed%99%a9 aria-label=이슈상황>이슈상황</a><ul><ul><li><a href=#redis-memoryrss aria-label="redis memory(rss)">redis memory(rss)</a></li><li><a href=#%ec%84%9c%eb%b2%84-%eb%a9%94%eb%aa%a8%eb%a6%ac aria-label="서버 메모리">서버 메모리</a></li><li><a href=#memory-fragmentation aria-label="memory fragmentation">memory fragmentation</a></li><li><a href=#key-eviction aria-label="key eviction">key eviction</a></li><li><a href=#set--get-call aria-label="set / get call">set / get call</a></li></ul></ul></li><li><a href=#activedefrag aria-label=activedefrag?>activedefrag?</a><ul><ul><li><a href=#%eb%b0%9c%eb%8f%99-%ec%a1%b0%ea%b1%b4 aria-label="발동 조건">발동 조건</a></li><li><a href=#%ec%9b%90%eb%a6%ac aria-label=원리>원리</a></li></ul></ul></li><li><a href=#%ed%9a%a8%ea%b3%bc aria-label=효과>효과</a><ul><ul><li><a href=#redis-memoryrss-1 aria-label="redis memory(rss)">redis memory(rss)</a></li><li><a href=#%ec%84%9c%eb%b2%84%eb%a9%94%eb%aa%a8%eb%a6%ac aria-label=서버메모리>서버메모리</a></li><li><a href=#memory-fragmentation-1 aria-label="memory fragmentation">memory fragmentation</a></li></ul></ul></li><li><a href=#defrag-%ec%88%98%ed%96%89-%ec%a0%84--%ed%9b%84-%ec%a7%80%ed%91%9c aria-label="defrag 수행 전 / 후 지표">defrag 수행 전 / 후 지표</a><ul><li><a href=#%ec%88%98%ed%96%89-%ec%a0%84 aria-label="수행 전">수행 전</a><ul><li><a href=#os-cpu--%eb%a9%94%eb%aa%a8%eb%a6%ac aria-label="OS CPU / 메모리">OS CPU / 메모리</a></li><li><a href=#redis-info aria-label="redis info">redis info</a></li></ul></li><li><a href=#%ec%88%98%ed%96%89-%ec%a4%91 aria-label="수행 중">수행 중</a><ul><li><a href=#activedefrag-yes aria-label="activedefrag yes">activedefrag yes</a></li><li><a href=#os-cpu--%eb%a9%94%eb%aa%a8%eb%a6%ac-1 aria-label="OS CPU / 메모리">OS CPU / 메모리</a></li><li><a href=#redis-info-1 aria-label="redis info">redis info</a></li></ul></li><li><a href=#%ec%88%98%ed%96%89-%ed%9b%84 aria-label="수행 후">수행 후</a><ul><li><a href=#os-cpu--%eb%a9%94%eb%aa%a8%eb%a6%ac-2 aria-label="OS CPU / 메모리">OS CPU / 메모리</a></li><li><a href=#redis-info-2 aria-label="redis info">redis info</a></li></ul></li></ul></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li></ul></div></details></div><div class=post-content><hr><h1 id=이슈상황>이슈상황<a hidden class=anchor aria-hidden=true href=#이슈상황>#</a></h1><ul><li>Redis를 maxmemory 까지 쓰는 상황</li><li>지속적으로 set 커맨드가 유입되고 이로 인해 key eviction이 발생하면서 memory 단편화가 심해짐</li><li>이는 곧 서버 메모리 사용량 상승을 초래하고 심하면 OOME 까지도 유발할 수 있음</li><li>Replica도 Master와 같은 데이터를 처리하기 때문에 memory fragmentation 현상도 동일하게 겪게되어 Replica도 동일하게 OOME 발생위험이 있음</li><li>아래 모니터링 지표는 NHN cloud의 EasyCache에서 제공하는 기능임</li></ul><h3 id=redis-memoryrss>redis memory(rss)<a hidden class=anchor aria-hidden=true href=#redis-memoryrss>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_1.png alt></p><h3 id=서버-메모리>서버 메모리<a hidden class=anchor aria-hidden=true href=#서버-메모리>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_2.png alt></p><h3 id=memory-fragmentation>memory fragmentation<a hidden class=anchor aria-hidden=true href=#memory-fragmentation>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_3.png alt></p><h3 id=key-eviction>key eviction<a hidden class=anchor aria-hidden=true href=#key-eviction>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_4.png alt></p><h3 id=set--get-call>set / get call<a hidden class=anchor aria-hidden=true href=#set--get-call>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_5.png alt></p><h1 id=activedefrag>activedefrag?<a hidden class=anchor aria-hidden=true href=#activedefrag>#</a></h1><p>Redis key를 메모리에 할당할 때 연속적인 block에 할당하게 되고 key가 삭제되면 그 공간도 비워주게됨<br>만약 새로 들어오는 key의 크기가 균일하지 않고 들쭉날쭉하면 비워진 block에 key를 할당할 수 없게되어 새로운 연속된 block을 찾아 key를 할당하게 됨<br>이런 현상이 심해지면 군데군데 이 빠진 fragmentation 이 심해져 실제 Redis memory 사용량 보다 더 많은 서버 memory를 차지하게 되는데<br>이러한 fragmentation을 online 중에 정리할 수 있는 기능이 activcedefrag 기능임<br>Redis 4.0 부터 사용가능하며 5.0부터 많이 안정화 되었다고함</p><h3 id=발동-조건>발동 조건<a hidden class=anchor aria-hidden=true href=#발동-조건>#</a></h3><ul><li><p>ACTIVE-DEFRAG-IGNORE-BYTES :</p><ul><li>조각모음을 시작하기 위한 최소량</li><li>info memory에서 조회된 allocator_frag_bytes = active - allocated 값이 설정한 값보다 작으면 activedefrag 하지 않음. default 100MB</li></ul></li><li><p>ACTIVE-DEFRAG-THRESHOLD-LOWER</p><ul><li>조각모음을 시작할 최소 조각화 비율</li><li>allocator_frag_ratio = active / allocated 값이 설정한 값보다 작으면 activedefrag 수행하지않음 default 10%</li></ul></li><li><p>mem_allocator</p><ul><li>jemalloc 을 사용해야 하며 linux에서 Redis 설치 시 default임</li></ul></li><li><p>두 조건이 모두 만족할 때 수행됨</p></li></ul><pre><code>127.0.0.1:6379&gt; config get ACTIVE-DEFRAG-IGNORE-BYTES 
1) &quot;active-defrag-ignore-bytes&quot;
2) &quot;104857600&quot;

127.0.0.1:6379&gt; config get ACTIVE-DEFRAG-THRESHOLD-LOWER
1) &quot;active-defrag-threshold-lower&quot;
2) &quot;10&quot;
</code></pre><h3 id=원리>원리<a hidden class=anchor aria-hidden=true href=#원리>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag.png alt></p><ul><li>연속된 free memory block을 만들어주기 위해 중간에 알박기 하고있는 데이터를 옆으로 이동시키고 memory block을 병합시키는 원리인듯함</li></ul><h1 id=효과>효과<a hidden class=anchor aria-hidden=true href=#효과>#</a></h1><p>빨간선 -> REPLICA, activedefrag 비활성<br>파란선 -> MASTER, activedefrag 활성</p><h3 id=redis-memoryrss-1>redis memory(rss)<a hidden class=anchor aria-hidden=true href=#redis-memoryrss-1>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_6.png alt></p><h3 id=서버메모리>서버메모리<a hidden class=anchor aria-hidden=true href=#서버메모리>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_7.png alt></p><h3 id=memory-fragmentation-1>memory fragmentation<a hidden class=anchor aria-hidden=true href=#memory-fragmentation-1>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/redis/redis_defrag_8.png alt></p><h1 id=defrag-수행-전--후-지표>defrag 수행 전 / 후 지표<a hidden class=anchor aria-hidden=true href=#defrag-수행-전--후-지표>#</a></h1><h2 id=수행-전>수행 전<a hidden class=anchor aria-hidden=true href=#수행-전>#</a></h2><h3 id=os-cpu--메모리>OS CPU / 메모리<a hidden class=anchor aria-hidden=true href=#os-cpu--메모리>#</a></h3><pre><code>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
13119 redis     20   0 9570612 6.358g   1380 S   0.0 83.2   1969:27 redis-server
</code></pre><h3 id=redis-info>redis info<a hidden class=anchor aria-hidden=true href=#redis-info>#</a></h3><pre><code># Memory

used_memory_human:5.38G
used_memory_rss_human:6.33G
used_memory_peak_human:5.39G

allocator_allocated:5782084072
allocator_active:6677209088

total_system_memory_human:7.64G

maxmemory_human:5.38G

allocator_frag_bytes:922989456
allocator_frag_ratio:1.15

mem_fragmentation_ratio:1.18
mem_allocator:jemalloc-5.1.0
active_defrag_running:0

# Stats
active_defrag_hits:0
active_defrag_misses:0
active_defrag_key_hits:0
active_defrag_key_misses:0
</code></pre><ul><li>실제 Redis 메모리 사용량은 used_memory_human:5.38G</li><li>mem_fragmentation_ratio:1.18 에 달해 서버 메모리 used_memory_rss_human:6.33G 까지 쓰고있는 상황</li><li>정리 대상 fragmentation data 크기는 allocator_frag_bytes:922989456, 900MB정도</li><li>allocator_frag_ratio:1.15 비율은 10%를 넘긴 상황</li><li>발동조건이 만족되었기 때문에 activedefrag yes로 설정 시 activedefrag 기능이 바로 수행될 것임</li></ul><h2 id=수행-중>수행 중<a hidden class=anchor aria-hidden=true href=#수행-중>#</a></h2><h3 id=activedefrag-yes>activedefrag yes<a hidden class=anchor aria-hidden=true href=#activedefrag-yes>#</a></h3><pre><code>127.0.0.1:6379&gt; redisconfig set activedefrag yes
OK
</code></pre><h3 id=os-cpu--메모리-1>OS CPU / 메모리<a hidden class=anchor aria-hidden=true href=#os-cpu--메모리-1>#</a></h3><pre><code>PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
13119 redis     20   0 9570612 6.359g   1408 S   8.8 83.2   1969:28 redis-server
</code></pre><h3 id=redis-info-1>redis info<a hidden class=anchor aria-hidden=true href=#redis-info-1>#</a></h3><pre><code># Memory

used_memory_human:5.39G
used_memory_rss_human:5.79G
used_memory_peak_human:5.39G

allocator_allocated:5785638544
allocator_active:6075428864

total_system_memory_human:7.64G

maxmemory_human:5.38G

allocator_frag_ratio:1.05
mem_fragmentation_ratio:1.07
mem_allocator:jemalloc-5.1.0
active_defrag_running:9
</code></pre><ul><li>active_defrag_running : 9 , active_defrag가 돌면서 메모리도 많이 정리되는 중임</li><li>activedefrag 돌면서 CPU는 조금 쓰는 모습</li></ul><h2 id=수행-후>수행 후<a hidden class=anchor aria-hidden=true href=#수행-후>#</a></h2><h3 id=os-cpu--메모리-2>OS CPU / 메모리<a hidden class=anchor aria-hidden=true href=#os-cpu--메모리-2>#</a></h3><pre><code>PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
13119 redis     20   0 9570612 6.359g   1408 S   1.1 72.9   1969:28 redis-server
</code></pre><h3 id=redis-info-2>redis info<a hidden class=anchor aria-hidden=true href=#redis-info-2>#</a></h3><pre><code># Memory

used_memory_human:5.38G
used_memory_rss_human:5.55G
used_memory_peak_human:5.39G

allocator_allocated:5781963352
allocator_active:5837156352

total_system_memory_human:7.64G

maxmemory_human:5.38G

allocator_frag_bytes:83108768
allocator_frag_ratio:1.01

mem_fragmentation_ratio:1.03
mem_allocator:jemalloc-5.1.0
active_defrag_running:0

# Stats
active_defrag_hits:5134002
active_defrag_misses:23330219
active_defrag_key_hits:2994915
active_defrag_key_misses:3473898
</code></pre><h1 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h1><ul><li>메모리 단편화가 심할 때 activedefarg 켜주면 효과가 정말 좋음<ul><li>메모리 빡빡하게 쓰는 서비스는 항시 켜놓는 것이 좋을듯</li></ul></li><li>운영 중 set / get 커맨드가 많이 들어오는 환경에서도 서비스에 이슈 없음</li><li>defrag 정리 중 CPU만 조금 쓰는데 미비한 수준, CPU limit 관련 설정도 있는데 굳이 건드릴 필요 없을듯</li><li>정확히 시간은 체크 못했으나 6.33G -> 5.55G 약 1GB 정리하는데 10분안쪽으로 소요된듯</li><li>maxmemory 를 해소하는 건 아님!! maxmeomry 는 별개로 redis 스펙업 해줘야함, activedefrag는 단편화 해소하는 기능</li><li>관련 설정은 <a href=http://redisgate.kr/redis/server/redis_conf_han.php>http://redisgate.kr/redis/server/redis_conf_han.php</a> 참고</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/redis/>redis</a></li></ul></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>