<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PostgreSQL을 소개합니다 | kimDuBiA</title><meta name=keywords content="postgresql,architecture"><meta name=description content="시작하며 세상엔 저마다의 특징과 장점을 뽐내는 다양한 DBMS들이 있습니다.
이들 각각의 특장점이 무엇인지 파악하고 자신의 서비스에서 어떤 DBMS가 최고의 퍼포먼스를 낼 수 있는지 파악하는 것이 중요하기 때문에
다양한 DBMS 에 대한 이해가 점점 중요해지고 있습니다.
ORACLE은 강력한 엔터프라이즈 개발 기능과 안정성을, MySQL은 대표적인 오픈소스 DB로 뛰어난 OLTP 성능을 보여주고, CUBRID는 뛰어난 부하 분산 기능을 자랑하는 DBMS입니다.
그리고 이 글에서 소개해드릴 PostgreSQL은 GIS 지리 정보 처리와 엔터프라이즈급 DBMS의 기능을 제공하는 오픈소스 DBMS입니다."><meta name=author content="kimdubi"><link rel=canonical href=/postgresql/pg_intro2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="PostgreSQL을 소개합니다"><meta property="og:description" content="시작하며 세상엔 저마다의 특징과 장점을 뽐내는 다양한 DBMS들이 있습니다.
이들 각각의 특장점이 무엇인지 파악하고 자신의 서비스에서 어떤 DBMS가 최고의 퍼포먼스를 낼 수 있는지 파악하는 것이 중요하기 때문에
다양한 DBMS 에 대한 이해가 점점 중요해지고 있습니다.
ORACLE은 강력한 엔터프라이즈 개발 기능과 안정성을, MySQL은 대표적인 오픈소스 DB로 뛰어난 OLTP 성능을 보여주고, CUBRID는 뛰어난 부하 분산 기능을 자랑하는 DBMS입니다.
그리고 이 글에서 소개해드릴 PostgreSQL은 GIS 지리 정보 처리와 엔터프라이즈급 DBMS의 기능을 제공하는 오픈소스 DBMS입니다."><meta property="og:type" content="article"><meta property="og:url" content="/postgresql/pg_intro2/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="postgresql"><meta property="article:published_time" content="2021-10-05T23:18:30+09:00"><meta property="article:modified_time" content="2021-10-05T23:18:30+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="PostgreSQL을 소개합니다"><meta name=twitter:description content="시작하며 세상엔 저마다의 특징과 장점을 뽐내는 다양한 DBMS들이 있습니다.
이들 각각의 특장점이 무엇인지 파악하고 자신의 서비스에서 어떤 DBMS가 최고의 퍼포먼스를 낼 수 있는지 파악하는 것이 중요하기 때문에
다양한 DBMS 에 대한 이해가 점점 중요해지고 있습니다.
ORACLE은 강력한 엔터프라이즈 개발 기능과 안정성을, MySQL은 대표적인 오픈소스 DB로 뛰어난 OLTP 성능을 보여주고, CUBRID는 뛰어난 부하 분산 기능을 자랑하는 DBMS입니다.
그리고 이 글에서 소개해드릴 PostgreSQL은 GIS 지리 정보 처리와 엔터프라이즈급 DBMS의 기능을 제공하는 오픈소스 DBMS입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Postgresqls","item":"/postgresql/"},{"@type":"ListItem","position":3,"name":"PostgreSQL을 소개합니다","item":"/postgresql/pg_intro2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL을 소개합니다","name":"PostgreSQL을 소개합니다","description":"시작하며 세상엔 저마다의 특징과 장점을 뽐내는 다양한 DBMS들이 있습니다.\n이들 각각의 특장점이 무엇인지 파악하고 자신의 서비스에서 어떤 DBMS가 최고의 퍼포먼스를 낼 수 있는지 파악하는 것이 중요하기 때문에\n다양한 DBMS 에 대한 이해가 점점 중요해지고 있습니다.\nORACLE은 강력한 엔터프라이즈 개발 기능과 안정성을, MySQL은 대표적인 오픈소스 DB로 뛰어난 OLTP 성능을 보여주고, CUBRID는 뛰어난 부하 분산 기능을 자랑하는 DBMS입니다.\n그리고 이 글에서 소개해드릴 PostgreSQL은 GIS 지리 정보 처리와 엔터프라이즈급 DBMS의 기능을 제공하는 오픈소스 DBMS입니다.","keywords":["postgresql","architecture"],"articleBody":" 시작하며 세상엔 저마다의 특징과 장점을 뽐내는 다양한 DBMS들이 있습니다.\n이들 각각의 특장점이 무엇인지 파악하고 자신의 서비스에서 어떤 DBMS가 최고의 퍼포먼스를 낼 수 있는지 파악하는 것이 중요하기 때문에\n다양한 DBMS 에 대한 이해가 점점 중요해지고 있습니다.\nORACLE은 강력한 엔터프라이즈 개발 기능과 안정성을, MySQL은 대표적인 오픈소스 DB로 뛰어난 OLTP 성능을 보여주고, CUBRID는 뛰어난 부하 분산 기능을 자랑하는 DBMS입니다.\n그리고 이 글에서 소개해드릴 PostgreSQL은 GIS 지리 정보 처리와 엔터프라이즈급 DBMS의 기능을 제공하는 오픈소스 DBMS입니다.\nPostgreSQL은 이미 북미와 일본쪽에서는 굉장히 인기가 많은 DB로 자리잡은데 비해\n우리나라에서는 GIS 용도로 굳어버린 이미지 때문인지 활용도가 높은 DB는 아닌데요.\nGIS 외에도 기능과 성능면에서 굉장히 뛰어난 오픈소스 DB이기 때문에 알아둘 가치가 충분한 DB입니다.\n이번 글에서는 PostgreSQL의 Architecture에 대해 다루면서 이게 어떤 DBMS인지 알아보겠습니다.\nPostgreSQL PostgreSQL은 객체관계형 데이터베이스 (ORDBMS) 로 엔터프라이즈급 DBMS의 기능과 뛰어난 GIS 기능으로 유명한 오픈소스DB입니다.\n객체지향 모델을 지원하기 때문에 개발자 스스로 어플리케이션에 필요한 data type과 method를 정의할 수 있습니다.\nPostgreSQL이 GIS 분야에서 뛰어난 이유도 ORDBMS의 특성을 살려 Native 수준으로 Spatial SQL 요소들을 구현한 PostGIS 라는 Add-on 이 있기 때문입니다.\n1986년부터 30년이상 활발하게 개발되고 있는 PostgreSQL은 현재 13.1 beta 버전이 출시되었으며\nMVCC, 트랜잭션 ACID 등 기본적인 RDBMS 기능 뿐만 아니라 extension이라 불리는 확장 모듈 API를 통해 다양한 기능을 제공하고 있습니다.\n PostgreSQL 소개 : https://www.postgresql.org/about/ PostgreSQL extension list : https://postgresql.kr/docs/current/contrib.html  PostgreSQL Architecture PostgreSQL의 아키텍처입니다\nORACLE 아키텍처에 대해 공부해보신 분이라면 바로 느끼시겠지만 전체적인 아키텍처가 ORACLE과 굉장히 유사합니다.\nShared Memory라는 공유메모리가 있고 PostgreSQL 운영에 필요한 Background process들과 Data file들로 구성됩니다.\nShared Memory Shared Memory에서 가장 중요한 요소는 Shared Buffer와 WAL buffer입니다.\n Shared Buffer : Disk IO를 최소화하기 위해 데이터를 캐싱하는 공간 WAL buffer : Write Ahead Logging 을 위한 공간으로 데이터베이스의 변경 사항을 WAL file로 내리기 전까지 보관  PostgreSQL은 데이터를 변경하기 전에 항상 변경 로그부터 기록하는데요\nShared Buffer의 데이터를 변경하기 전에 먼저 WAL buffer에 로그를 기록하고, writer process 가 dirty block 을 disk로 내려쓰기 전에\nWAL writer process가 WAL logfile로 내려쓰는 작업을 먼저 하는데 변경 로그부터 작업한다하여 이를 Write Ahead Logging 이라고 부릅니다.\nShared Memory에서 가장 중요한 공간인만큼 관련 parameter의 적절한 설정도 중요한데요\n권장값과 관련 설정은 이전 글을 참고하시기 바랍니다.\nhttps://kimdubi.github.io/postgresql/psql_conf/\nPostgreSQL Process  Postmaster Process  Shared Memory 위에 보이는 Postmaster process 는 PostgreSQL을 기동할 때 가장 먼저 시작되는 Daemon 프로세스로 DB 기동 시에 recovery 작업, Shared Memory 초기화 작업 그리고 다른 background process 구동 작업을 수행하는 역할을 합니다. 또한 클라이언트 프로세스(JDBC,ODBC등..)의 접속 요청이 있을 때 backend process 를 fork하여 client process와 연결시켜주는 역할을 합니다.  Background Process  운영에 필요한 PostgreSQL background process는 아래와 같습니다.\n   Process 명 역할     writer 주기적으로 Shared Buffers 내 dirty 버퍼를 data file로 내려씁니다   WAL writer WAL buffer 내용을 WAL file에 기록합니다   Checkpointer 체크포인트 발생 시 dirty 버퍼를 data file에 기록합니다   Archiver Archive log 모드 일 때 WAL 파일을 지정된 archive 디렉토리에 복사합니다   Logging collector error 메시지를 log file에 기록합니다   Stats collector DBMS의 세션 정보, 테이블 통계 같은 정보를 수집합니다   Autovaccum vacuum이 필요한 시점에 autovacuum worker를 fork하여 vacuum 작업을 수행합니다     Backend Process  Backend process 는 client process 의 쿼리 요청을 수행하고 그 결과를 전송하는 프로세스입니다.\n이 때 쿼리 수행에 필요한 메모리가 필요한데 이를 backend process의 local memory라고 부릅니다.\nShared Memory와 마찬가지로 적절한 parameter 튜닝을 통해 성능을 최적화하는 것이 중요합니다.\n여기까지 PostgreSQL의 Architecture에 대해 살펴보았는데 어떠신가요?\n개인적으로는 ORACLE의 아키텍처와 유사해서 친숙하기도 했고 혹시 차이점은 없읕까 더 궁금하기도 했습니다.\n다음으로는 제가 생각하는 ORACLE과 PostgreSQL의 가장 큰 차이점을 살펴보며 PostgreSQL Architecture에 대해 조금 더 알아보도록 하겠습니다.\nORACLE과 PostgreSQL Architecture 차이점 MVCC 모델 구현 대다수의 RDBMS는 동시성을 위해 MVCC(Multi-Version Concurrency Control) 기능을 제공합니다.\nMVCC란, 쿼리 수행 시점의 데이터를 제공하는 기법으로 기본 원리는 쿼리가 시작된 시점의 트랜잭션ID와 같거나 작은 데이터 버전을 읽는 것 입니다.\nORACLE과 MySQL 같은 경우에는 UNDO segment를 사용하며 쿼리가 시작된 이후에\n다른 트랜잭션에 의해 변경된 블록을 만나면 원본 블록으로부터 복사본 블록 (CR copy)를 만들고\n그 복사본 블록에 UNDO segment를 적용하여 쿼리가 시작된 시점으로 되돌려서 읽는 방식을 사용합니다.\n[ORACLE 의 UNDO 동작방식]\n반면에 PostgreSQL은 데이터 페이지 내에 변경되기 이전 레코드를 저장 하고\n레코드 별로 생성된 시점과 변경된 시점을 기록 및 비교하는 방식 으로 MVCC를 제공합니다.\n이 방식은 ORACLE의 UNDO segment 같은 복잡성 없이 MVCC를 매우 단순하게 구현할 수 있도록 하는 장점이 있습니다.\n다만 이전 데이터와 현재의 데이터를 동일한 테이블 내에 저장하기 때문에 테이블 공간이 비효율적으로 사용될 수 있습니다.\n또한 사용할 수 있는 트랜잭션 ID가 고갈되고 덮어써져 (wrap around) 오래된 데이터가 손실될 가능성이 있습니다.\nPostgreSQL에서는 이전의 데이터와 현재의 데이터를 구분하고 시점에 맞는 데이터를 사용하기 위해서는 레코드별로 트랜잭션ID (이하 XID)가 필요한데\nPostgreSQL에서는 XID를 위해 4바이트를 사용하고 있어 최대 43억건의 XID를 표현할수 있습니다.\n만약 43억건 이후 XID 를 1부터 다시 시작하게 되면 어떻게 될까요?\n아래의 새로 시작된 XID 1은 43억보다 이후의 트랜잭션이지만\nXID가 작아서 더 오래된 트랜잭션으로 인식되어 순서가 꼬여버리는 치명적인 문제가 발생할 수 있습니다.\n 불필요한 데이터로 인한 테이블 공간 사용의 비효율성 XID를 4bytes 로 관리함에 따른 XID 고갈  이 두가지 이슈를 해결하기 위한 PostgreSQL의 내부 동작이 vacuum 입니다.\n위에서 언급한 autovacuum 백그라운드 프로세스는 테이블에 일정량 이상의 변경이 발생한 경우\n자동으로 vacuum을 수행하면서 더 이상 사용하지 않는 dead-rows 를 회수하고 오래된 XID 를 정리하는 역할을 수행합니다.\n즉 vacuum은 PostgreSQL 특유의 MVCC 모델에서 비롯될 수 있는 문제점을 해결하기 위해 나온 개념인 것입니다.\nShared Pool의 부재 PostgreSQL은 ORACLE의 Shared Pool같은 기능을 제공하지 않습니다.\nShared pool은 수행한 쿼리의 Parse tree나 Execution plan, 데이터베이스 내 오브젝트 정보를 갖고 있는 공간으로\nORACLE에서는 굉장히 중요한 구성요소이기 때문에 개인적으로 놀라운 부분이기도 했는데요.\nPostgreSQL은 공유 메모리 레벨이 아닌 프로세스 레벨에서 SQL 정보를 공유합니다.\n이를 통해 Shared pool 리소스나 Shared pool latch 경합 같은 관리 포인트를 줄일 수 있지만 신규 커넥션 마다 수행하는 SQL에 대해 최초 1회는 hard-parsing 이 필요하게 됩니다.\n그렇기 때문에 Connection pool 기능을 사용하면 도움이 되겠죠?\nPgpool-II , PGbouncer 같이 connection pooling, load balancing 등을 지원하는 PostgreSQL 오픈소스 툴을 도입해서 사용하면 더 좋은 성능을 이끌어 낼 수 있습니다.\n","wordCount":"907","inLanguage":"en","datePublished":"2021-10-05T23:18:30+09:00","dateModified":"2021-10-05T23:18:30+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/postgresql/pg_intro2/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/postgresql/>Postgresqls</a></div><h1 class=post-title>PostgreSQL을 소개합니다</h1><div class=post-meta>October 5, 2021&nbsp;·&nbsp;5 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%8b%9c%ec%9e%91%ed%95%98%eb%a9%b0 aria-label=시작하며>시작하며</a></li><li><a href=#postgresql aria-label=PostgreSQL>PostgreSQL</a></li><li><a href=#postgresql-architecture aria-label="PostgreSQL Architecture">PostgreSQL Architecture</a><ul><li><a href=#shared-memory aria-label="Shared Memory"><strong>Shared Memory</strong></a></li><li><a href=#postgresql-process aria-label="PostgreSQL Process"><strong>PostgreSQL Process</strong></a></li></ul></li><li><a href=#oracle%ea%b3%bc-postgresql-architecture-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="ORACLE과 PostgreSQL Architecture 차이점">ORACLE과 PostgreSQL Architecture 차이점</a><ul><ul><li><a href=#mvcc-%eb%aa%a8%eb%8d%b8-%ea%b5%ac%ed%98%84 aria-label="MVCC 모델 구현"><strong>MVCC 모델 구현</strong></a></li><li><a href=#shared-pool%ec%9d%98-%eb%b6%80%ec%9e%ac aria-label="Shared Pool의 부재"><strong>Shared Pool의 부재</strong></a></li></ul></ul></li></ul></div></details></div><div class=post-content><hr><h2 id=시작하며>시작하며<a hidden class=anchor aria-hidden=true href=#시작하며>#</a></h2><p>세상엔 저마다의 특징과 장점을 뽐내는 다양한 DBMS들이 있습니다.<br>이들 각각의 특장점이 무엇인지 파악하고 자신의 서비스에서 어떤 DBMS가 최고의 퍼포먼스를 낼 수 있는지 파악하는 것이 중요하기 때문에<br>다양한 DBMS 에 대한 이해가 점점 중요해지고 있습니다.</p><p>ORACLE은 강력한 엔터프라이즈 개발 기능과 안정성을, MySQL은 대표적인 오픈소스 DB로 뛰어난 OLTP 성능을 보여주고, CUBRID는 뛰어난 부하 분산 기능을 자랑하는 DBMS입니다.<br>그리고 이 글에서 소개해드릴 PostgreSQL은 GIS 지리 정보 처리와 엔터프라이즈급 DBMS의 기능을 제공하는 오픈소스 DBMS입니다.</p><p>PostgreSQL은 이미 북미와 일본쪽에서는 굉장히 인기가 많은 DB로 자리잡은데 비해<br>우리나라에서는 GIS 용도로 굳어버린 이미지 때문인지 활용도가 높은 DB는 아닌데요.<br>GIS 외에도 기능과 성능면에서 굉장히 뛰어난 오픈소스 DB이기 때문에 알아둘 가치가 충분한 DB입니다.</p><p>이번 글에서는 PostgreSQL의 Architecture에 대해 다루면서 이게 어떤 DBMS인지 알아보겠습니다.</p><h2 id=postgresql>PostgreSQL<a hidden class=anchor aria-hidden=true href=#postgresql>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_0808_1.png alt></p><p><strong>PostgreSQL</strong>은 객체관계형 데이터베이스 (ORDBMS) 로 엔터프라이즈급 DBMS의 기능과 뛰어난 GIS 기능으로 유명한 오픈소스DB입니다.<br>객체지향 모델을 지원하기 때문에 개발자 스스로 어플리케이션에 필요한 data type과 method를 정의할 수 있습니다.<br>PostgreSQL이 GIS 분야에서 뛰어난 이유도 ORDBMS의 특성을 살려 Native 수준으로 Spatial SQL 요소들을 구현한 <strong>PostGIS</strong> 라는 Add-on 이 있기 때문입니다.</p><p>1986년부터 30년이상 활발하게 개발되고 있는 PostgreSQL은 현재 13.1 beta 버전이 출시되었으며<br>MVCC, 트랜잭션 ACID 등 기본적인 RDBMS 기능 뿐만 아니라 <strong>extension</strong>이라 불리는 확장 모듈 API를 통해 다양한 기능을 제공하고 있습니다.</p><ul><li>PostgreSQL 소개 : <a href=https://www.postgresql.org/about/>https://www.postgresql.org/about/</a></li><li>PostgreSQL extension list : <a href=https://postgresql.kr/docs/current/contrib.html>https://postgresql.kr/docs/current/contrib.html</a></li></ul><h2 id=postgresql-architecture>PostgreSQL Architecture<a hidden class=anchor aria-hidden=true href=#postgresql-architecture>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_0808_2.png alt></p><p>PostgreSQL의 아키텍처입니다</p><p>ORACLE 아키텍처에 대해 공부해보신 분이라면 바로 느끼시겠지만 전체적인 아키텍처가 ORACLE과 굉장히 유사합니다.<br><strong>Shared Memory</strong>라는 공유메모리가 있고 PostgreSQL 운영에 필요한 <strong>Background process</strong>들과 <strong>Data file</strong>들로 구성됩니다.</p><h3 id=shared-memory><strong>Shared Memory</strong><a hidden class=anchor aria-hidden=true href=#shared-memory>#</a></h3><p>Shared Memory에서 가장 중요한 요소는 <strong>Shared Buffer</strong>와 <strong>WAL buffer</strong>입니다.</p><ul><li>Shared Buffer : Disk IO를 최소화하기 위해 데이터를 캐싱하는 공간</li><li>WAL buffer : <strong>Write Ahead Logging</strong> 을 위한 공간으로 데이터베이스의 변경 사항을 WAL file로 내리기 전까지 보관</li></ul><p>PostgreSQL은 데이터를 변경하기 전에 항상 변경 로그부터 기록하는데요<br>Shared Buffer의 데이터를 변경하기 전에 먼저 WAL buffer에 로그를 기록하고, writer process 가 dirty block 을 disk로 내려쓰기 전에<br>WAL writer process가 WAL logfile로 내려쓰는 작업을 먼저 하는데 변경 로그부터 작업한다하여 이를 <strong>Write Ahead Logging</strong> 이라고 부릅니다.</p><p>Shared Memory에서 가장 중요한 공간인만큼 관련 parameter의 적절한 설정도 중요한데요<br>권장값과 관련 설정은 이전 글을 참고하시기 바랍니다.<br><a href=https://kimdubi.github.io/postgresql/psql_conf/>https://kimdubi.github.io/postgresql/psql_conf/</a></p><h3 id=postgresql-process><strong>PostgreSQL Process</strong><a hidden class=anchor aria-hidden=true href=#postgresql-process>#</a></h3><ul><li>Postmaster Process</li></ul><pre><code>Shared Memory 위에 보이는 Postmaster process 는 
PostgreSQL을 기동할 때 가장 먼저 시작되는 Daemon 프로세스로  
DB 기동 시에 recovery 작업, Shared Memory 초기화 작업 
그리고 다른 background process 구동 작업을 수행하는 역할을 합니다.  
또한 클라이언트 프로세스(JDBC,ODBC등..)의 접속 요청이 있을 때 
backend process 를 fork하여 client process와 연결시켜주는 역할을 합니다.
</code></pre><ul><li>Background Process</li></ul><p>운영에 필요한 <strong>PostgreSQL background process</strong>는 아래와 같습니다.</p><table><thead><tr><th>Process 명</th><th>역할</th></tr></thead><tbody><tr><td>writer</td><td>주기적으로 Shared Buffers 내 dirty 버퍼를 data file로 내려씁니다</td></tr><tr><td>WAL writer</td><td>WAL buffer 내용을 WAL file에 기록합니다</td></tr><tr><td>Checkpointer</td><td>체크포인트 발생 시 dirty 버퍼를 data file에 기록합니다</td></tr><tr><td>Archiver</td><td>Archive log 모드 일 때 WAL 파일을 지정된 archive 디렉토리에 복사합니다</td></tr><tr><td>Logging collector</td><td>error 메시지를 log file에 기록합니다</td></tr><tr><td>Stats collector</td><td>DBMS의 세션 정보, 테이블 통계 같은 정보를 수집합니다</td></tr><tr><td>Autovaccum</td><td>vacuum이 필요한 시점에 autovacuum worker를 fork하여 vacuum 작업을 수행합니다</td></tr></tbody></table><ul><li>Backend Process</li></ul><p><strong>Backend process</strong> 는 client process 의 쿼리 요청을 수행하고 그 결과를 전송하는 프로세스입니다.<br>이 때 쿼리 수행에 필요한 메모리가 필요한데 이를 backend process의 <strong>local memory</strong>라고 부릅니다.<br>Shared Memory와 마찬가지로 적절한 parameter 튜닝을 통해 성능을 최적화하는 것이 중요합니다.</p><p>여기까지 PostgreSQL의 Architecture에 대해 살펴보았는데 어떠신가요?<br>개인적으로는 ORACLE의 아키텍처와 유사해서 친숙하기도 했고 혹시 차이점은 없읕까 더 궁금하기도 했습니다.<br>다음으로는 제가 생각하는 ORACLE과 PostgreSQL의 가장 큰 차이점을 살펴보며 PostgreSQL Architecture에 대해 조금 더 알아보도록 하겠습니다.</p><h2 id=oracle과-postgresql-architecture-차이점>ORACLE과 PostgreSQL Architecture 차이점<a hidden class=anchor aria-hidden=true href=#oracle과-postgresql-architecture-차이점>#</a></h2><h4 id=mvcc-모델-구현><strong>MVCC 모델 구현</strong><a hidden class=anchor aria-hidden=true href=#mvcc-모델-구현>#</a></h4><p>대다수의 RDBMS는 동시성을 위해 MVCC(Multi-Version Concurrency Control) 기능을 제공합니다.<br>MVCC란, 쿼리 수행 시점의 데이터를 제공하는 기법으로 기본 원리는 쿼리가 시작된 시점의 트랜잭션ID와 같거나 작은 데이터 버전을 읽는 것 입니다.</p><p>ORACLE과 MySQL 같은 경우에는 <strong>UNDO segment</strong>를 사용하며 쿼리가 시작된 이후에<br>다른 트랜잭션에 의해 변경된 블록을 만나면 원본 블록으로부터 복사본 블록 (CR copy)를 만들고<br>그 복사본 블록에 UNDO segment를 적용하여 쿼리가 시작된 시점으로 되돌려서 읽는 방식을 사용합니다.</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_0808_3.png alt></p><p>[ORACLE 의 UNDO 동작방식]</p><p>반면에 PostgreSQL은 <strong>데이터 페이지 내에 변경되기 이전 레코드를 저장</strong> 하고<br>레코드 별로 생성된 시점과 변경된 시점을 기록 및 비교하는 방식 으로 MVCC를 제공합니다.<br>이 방식은 ORACLE의 UNDO segment 같은 복잡성 없이 MVCC를 매우 단순하게 구현할 수 있도록 하는 장점이 있습니다.</p><p>다만 이전 데이터와 현재의 데이터를 동일한 테이블 내에 저장하기 때문에 <strong>테이블 공간이 비효율적</strong>으로 사용될 수 있습니다.<br>또한 사용할 수 있는 트랜잭션 ID가 고갈되고 덮어써져 (wrap around) <strong>오래된 데이터가 손실될 가능성</strong>이 있습니다.</p><p>PostgreSQL에서는 이전의 데이터와 현재의 데이터를 구분하고 시점에 맞는 데이터를 사용하기 위해서는 레코드별로 트랜잭션ID (이하 XID)가 필요한데<br>PostgreSQL에서는 XID를 위해 4바이트를 사용하고 있어 최대 43억건의 XID를 표현할수 있습니다.<br>만약 43억건 이후 XID 를 1부터 다시 시작하게 되면 어떻게 될까요?</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/psql_0808_4.png alt></p><p>아래의 새로 시작된 XID 1은 43억보다 이후의 트랜잭션이지만<br>XID가 작아서 더 오래된 트랜잭션으로 인식되어 순서가 꼬여버리는 치명적인 문제가 발생할 수 있습니다.</p><ul><li>불필요한 데이터로 인한 테이블 공간 사용의 비효율성</li><li>XID를 4bytes 로 관리함에 따른 XID 고갈</li></ul><p>이 두가지 이슈를 해결하기 위한 PostgreSQL의 내부 동작이 <strong>vacuum</strong> 입니다.<br>위에서 언급한 <strong>autovacuum</strong> 백그라운드 프로세스는 테이블에 일정량 이상의 변경이 발생한 경우<br>자동으로 vacuum을 수행하면서 더 이상 사용하지 않는 dead-rows 를 회수하고 오래된 XID 를 정리하는 역할을 수행합니다.</p><p>즉 vacuum은 PostgreSQL 특유의 MVCC 모델에서 비롯될 수 있는 문제점을 해결하기 위해 나온 개념인 것입니다.</p><h4 id=shared-pool의-부재><strong>Shared Pool의 부재</strong><a hidden class=anchor aria-hidden=true href=#shared-pool의-부재>#</a></h4><p>PostgreSQL은 ORACLE의 Shared Pool같은 기능을 제공하지 않습니다.<br>Shared pool은 수행한 쿼리의 Parse tree나 Execution plan, 데이터베이스 내 오브젝트 정보를 갖고 있는 공간으로<br>ORACLE에서는 굉장히 중요한 구성요소이기 때문에 개인적으로 놀라운 부분이기도 했는데요.</p><p>PostgreSQL은 공유 메모리 레벨이 아닌 프로세스 레벨에서 SQL 정보를 공유합니다.<br>이를 통해 Shared pool 리소스나 Shared pool latch 경합 같은 관리 포인트를 줄일 수 있지만 신규 커넥션 마다 수행하는 SQL에 대해 최초 1회는 hard-parsing 이 필요하게 됩니다.<br>그렇기 때문에 Connection pool 기능을 사용하면 도움이 되겠죠?</p><p>Pgpool-II , PGbouncer 같이 connection pooling, load balancing 등을 지원하는 PostgreSQL 오픈소스 툴을 도입해서 사용하면 더 좋은 성능을 이끌어 낼 수 있습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/postgresql/>postgresql</a></li><li><a href=/tags/architecture/>architecture</a></li></ul></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>