<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PostgreSQL Index only scan과 vacuum | kimDuBiA</title><meta name=keywords content="postgresql"><meta name=description content="PostgreSQL의 테이블 스캔에는 크게 네종류가 있으며 MySQL과는 다르게 동작하는 scan방식이 있습니다.
 Sequential Scan Index Scan Index Only Scan Bitmap Scan  이 중 MySQL의 full scan, index range scan과 동일한 Sequential Scan,Index Scan은 건너뛰고
Index Only Scan에 대해서 알아보겠습니다.
Bitmap Scan은 간단히 언급만 하자면, index scan하거나 full scan하기엔 많은 데이터를 bitmap이라는 자료구조를 통해 스캔하는 방법입니다.
Index Only Scan Index Only Scan은 흔히 말하는 covering index와 동일한 개념입니다.
SELECT 절과 WHERE절에서 사용하는 컬럼과 조건이 모두 index를 사용할 수 있어서 테이블(heap)에 접근할 필요없이 index에서 필요한 모든 데이터를 가져올 수 있을 때"><meta name=author content="kimdubi"><link rel=canonical href=/postgresql/index_only_scan/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="PostgreSQL Index only scan과 vacuum"><meta property="og:description" content="PostgreSQL의 테이블 스캔에는 크게 네종류가 있으며 MySQL과는 다르게 동작하는 scan방식이 있습니다.
 Sequential Scan Index Scan Index Only Scan Bitmap Scan  이 중 MySQL의 full scan, index range scan과 동일한 Sequential Scan,Index Scan은 건너뛰고
Index Only Scan에 대해서 알아보겠습니다.
Bitmap Scan은 간단히 언급만 하자면, index scan하거나 full scan하기엔 많은 데이터를 bitmap이라는 자료구조를 통해 스캔하는 방법입니다.
Index Only Scan Index Only Scan은 흔히 말하는 covering index와 동일한 개념입니다.
SELECT 절과 WHERE절에서 사용하는 컬럼과 조건이 모두 index를 사용할 수 있어서 테이블(heap)에 접근할 필요없이 index에서 필요한 모든 데이터를 가져올 수 있을 때"><meta property="og:type" content="article"><meta property="og:url" content="/postgresql/index_only_scan/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="postgresql"><meta property="article:published_time" content="2022-10-30T06:33:49+09:00"><meta property="article:modified_time" content="2022-10-30T06:33:49+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="PostgreSQL Index only scan과 vacuum"><meta name=twitter:description content="PostgreSQL의 테이블 스캔에는 크게 네종류가 있으며 MySQL과는 다르게 동작하는 scan방식이 있습니다.
 Sequential Scan Index Scan Index Only Scan Bitmap Scan  이 중 MySQL의 full scan, index range scan과 동일한 Sequential Scan,Index Scan은 건너뛰고
Index Only Scan에 대해서 알아보겠습니다.
Bitmap Scan은 간단히 언급만 하자면, index scan하거나 full scan하기엔 많은 데이터를 bitmap이라는 자료구조를 통해 스캔하는 방법입니다.
Index Only Scan Index Only Scan은 흔히 말하는 covering index와 동일한 개념입니다.
SELECT 절과 WHERE절에서 사용하는 컬럼과 조건이 모두 index를 사용할 수 있어서 테이블(heap)에 접근할 필요없이 index에서 필요한 모든 데이터를 가져올 수 있을 때"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Postgresqls","item":"/postgresql/"},{"@type":"ListItem","position":3,"name":"PostgreSQL Index only scan과 vacuum","item":"/postgresql/index_only_scan/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL Index only scan과 vacuum","name":"PostgreSQL Index only scan과 vacuum","description":"PostgreSQL의 테이블 스캔에는 크게 네종류가 있으며 MySQL과는 다르게 동작하는 scan방식이 있습니다.\n Sequential Scan Index Scan Index Only Scan Bitmap Scan  이 중 MySQL의 full scan, index range scan과 동일한 Sequential Scan,Index Scan은 건너뛰고\nIndex Only Scan에 대해서 알아보겠습니다.\nBitmap Scan은 간단히 언급만 하자면, index scan하거나 full scan하기엔 많은 데이터를 bitmap이라는 자료구조를 통해 스캔하는 방법입니다.\nIndex Only Scan Index Only Scan은 흔히 말하는 covering index와 동일한 개념입니다.\nSELECT 절과 WHERE절에서 사용하는 컬럼과 조건이 모두 index를 사용할 수 있어서 테이블(heap)에 접근할 필요없이 index에서 필요한 모든 데이터를 가져올 수 있을 때","keywords":["postgresql"],"articleBody":"PostgreSQL의 테이블 스캔에는 크게 네종류가 있으며 MySQL과는 다르게 동작하는 scan방식이 있습니다.\n Sequential Scan Index Scan Index Only Scan Bitmap Scan  이 중 MySQL의 full scan, index range scan과 동일한 Sequential Scan,Index Scan은 건너뛰고\nIndex Only Scan에 대해서 알아보겠습니다.\nBitmap Scan은 간단히 언급만 하자면, index scan하거나 full scan하기엔 많은 데이터를 bitmap이라는 자료구조를 통해 스캔하는 방법입니다.\nIndex Only Scan Index Only Scan은 흔히 말하는 covering index와 동일한 개념입니다.\nSELECT 절과 WHERE절에서 사용하는 컬럼과 조건이 모두 index를 사용할 수 있어서 테이블(heap)에 접근할 필요없이 index에서 필요한 모든 데이터를 가져올 수 있을 때\n이 인덱스는 이 쿼리의 covering index 라고 합니다.\ncovering index는 테이블에 접근하지 않기 때문에 성능이 굉장히 좋은 것이 일반적이지만\nPostgreSQL에서는 한가지 더 고려해야하는 점이 있는데 그것은 PostgreSQL의 MVCC 구현방식에 따른 visibility map 입니다.\n아래에서 테스트와 데이터를 통해 자세히 살펴보겠습니다.\n 테스트 환경 세팅  testdb= create extension pg_visibility; CREATE EXTENSION testdb= create table tb_test (id serial, a varchar(100), b int); create index on tb_test(a,b); CREATE TABLE CREATE INDEX testdb= insert into tb_test(a,b) select 'test' || generate_series(1,1000000), (random()*100)::int % 100; INSERT 0 1000000 testdb= vacuum tb_test; VACUUM testdb= vacuum analyze tb_test; VACUUM testdb= set enable_seqscan = off; SET testdb= set enable_bitmapscan = off; SET  실행계획 확인  testdb= explain analyze select a from tb_test where b between 1 and 10; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------- Index Only Scan using tb_test_a_b_idx on tb_test (cost=0.42..37421.76 rows=98933 width=10) (actual time=29.327..294.907 rows=99957 loops=1) Index Cond: ((b = 1) AND (b 위에서 실행계획을 봤을 땐 Index Only Scan plan을 제대로 타고 있고 별 문제 없어보입니다. 다만 Heap Fetches: 0 이라는 라인을 기억해두었다가 다시 한번 쿼리를 수행해보겠습니다.\n아래와 같이 업데이트가 발생하고 어떤 무언가의 이슈로 vacuum이 돌지 않았다고 가정해보겠습니다.\n dead tuple 발생 후 실행계획 확인  testdb= alter table tb_test set (autovacuum_enabled = off); ALTER TABLE testdb= update tb_test set b = b + 1; UPDATE 1000000 testdb= explain analyze select a from tb_test where b between 1 and 10; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------- Index Only Scan using tb_test_a_b_idx on tb_test (cost=0.43..67404.75 rows=197851 width=10) (actual time=0.095..336.188 rows=99921 loops=1) Index Cond: ((b = 1) AND (b 동일한 Index Only Scan의 플랜이지만\n무언가 위는 Heap Fetches: 0인데 아래는 Heap Fetches 양이 엄청 늘었습니다.\n여기서 Heap 은 PostgreSQL에서 테이블의 데이터 저장구조라고 보시면 됩니다.\n즉 테이블을 의미하므로 Heap Fetches가 늘어났다는 것은 covering index를 이용했음에도 테이블에 접근, 곧 I/O가 발생했다는 의미입니다.\nVisibility Map 이 현상을 이해하기 위해서는 Visibility Map을 이해해야하는데 간단히 말하면,\n각 테이블의 데이터를 갖고 있고 테이블을 구성하는 page에 변경사항이 있는지 없는지를 체크해둔 메타데이터라고 생각하면 됩니다.\n이것은 vacuum 의 성능을 개선하기 위해 나온 개념인데, Visibilit Map이 없었던 시절에는 vacuum을 할 때 모든 테이블을 풀스캔을 했습니다.\n근데 Visibility Map이 나오면서, 데이터가 변경된 페이지, 변경되지 않은 페이지를 구분할 수 있게 되고, vacuum은 데이터가 변경된 페이지만 골라다 스캔을 할 수 있게 된 것입니다.\nVisibility Map은 2bit로 구성됩니다.\n  VISIBILITYMAP_ALL_VISIBLE : 페이지에 저장된 tuple들이 모든 트랜잭션에게 보이는지 안보이는지에 대한 여부를 의미합니다.\n 1 : 해당 페이지의 모든 tuple들이 모든 트랜잭션에게 보이는 상태, dead tuple이 없음 0 : 해당 페이지에 dead tuple이 있거나, vacuum이 수행되지 않아 아직 모르는 상태임    VISIBILITYMAP_ALL_FROZEN : 페이지에 저장된 tuple들이 freeze 되었는지에 대한 여부를 의미합니다.\n 1 : 해당 페이지의 모든 tuple들이 freeze되어 vacuum freeze가 발생했을 때 해당 페이지는 스킵함 0 : 해당 페이지에 dead tuple이 있꺼나, vacuum이 수행되지 않아 아직 모르는 상태임    Visibility Map 변화 확인\n  ### 위에서 update 후 dead tuple이 있는 상태 testdb= select blkno, all_visible, all_frozen from pg_visibility('tb_test') limit 10; blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | f | f 2 | f | f 3 | f | f 4 | f | f 5 | f | f 6 | f | f 7 | f | f 8 | f | f 9 | f | f (10 rows) ### vacuum 후 정리된 상태 testdb= vacuum freeze tb_test; VACUUM testdb= select blkno, all_visible, all_frozen from pg_visibility('tb_test') limit 10; blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | t 1 | t | t 2 | t | t 3 | t | t 4 | t | t 5 | t | t 6 | t | t 7 | t | t 8 | t | t 9 | t | t (10 rows) 정리 정리하면, VISIBILITYMAP_ALL_VISIBLE = 0 인 상태, 데이터 페이지에 변경사항이 있다면 인덱스만 읽어서 될 게 아니라 테이블에 접근하여 해당 로우의 버전을 확인해야합니다.\n나의 트랜잭션 아이디와 해당 로우의 버전을 비교하여 읽을 수 있는 데이터인지 읽을 수 없는 데이터인지를 확인해야 하기 때문입니다.\n이것은 covering index인 Index Only Scan에서도 마찬가지라서 covering index임에도 불구하고 테이블 i/o가 발생할 수 있습니다.\nindex plan은 이슈없는데 테이블 스캔이 느리면 vacuum을 확인해보자!\n","wordCount":"767","inLanguage":"en","datePublished":"2022-10-30T06:33:49+09:00","dateModified":"2022-10-30T06:33:49+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/postgresql/index_only_scan/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/postgresql/>Postgresqls</a></div><h1 class=post-title>PostgreSQL Index only scan과 vacuum</h1><div class=post-meta>October 30, 2022&nbsp;·&nbsp;4 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#index-only-scan aria-label="Index Only Scan">Index Only Scan</a></li><li><a href=#visibility-map aria-label="Visibility Map">Visibility Map</a></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li></ul></div></details></div><div class=post-content><p>PostgreSQL의 테이블 스캔에는 크게 네종류가 있으며 MySQL과는 다르게 동작하는 scan방식이 있습니다.</p><ul><li>Sequential Scan</li><li>Index Scan</li><li>Index Only Scan</li><li>Bitmap Scan</li></ul><p>이 중 MySQL의 full scan, index range scan과 동일한 Sequential Scan,Index Scan은 건너뛰고<br>Index Only Scan에 대해서 알아보겠습니다.<br>Bitmap Scan은 간단히 언급만 하자면, index scan하거나 full scan하기엔 많은 데이터를 bitmap이라는 자료구조를 통해 스캔하는 방법입니다.</p><h1 id=index-only-scan>Index Only Scan<a hidden class=anchor aria-hidden=true href=#index-only-scan>#</a></h1><p>Index Only Scan은 흔히 말하는 covering index와 동일한 개념입니다.<br>SELECT 절과 WHERE절에서 사용하는 컬럼과 조건이 모두 index를 사용할 수 있어서 테이블(heap)에 접근할 필요없이 index에서 필요한 모든 데이터를 가져올 수 있을 때<br>이 인덱스는 이 쿼리의 covering index 라고 합니다.<br>covering index는 테이블에 접근하지 않기 때문에 성능이 굉장히 좋은 것이 일반적이지만<br>PostgreSQL에서는 한가지 더 고려해야하는 점이 있는데 그것은 PostgreSQL의 MVCC 구현방식에 따른 visibility map 입니다.<br>아래에서 테스트와 데이터를 통해 자세히 살펴보겠습니다.</p><ul><li>테스트 환경 세팅</li></ul><pre><code>testdb=&gt; create extension pg_visibility;
CREATE EXTENSION

testdb=&gt; create table tb_test (id serial, a varchar(100), b int);
create index on tb_test(a,b);
CREATE TABLE
CREATE INDEX
testdb=&gt; insert into tb_test(a,b) select 'test' || generate_series(1,1000000),
(random()*100)::int % 100;
INSERT 0 1000000

testdb=&gt; vacuum tb_test;
VACUUM
testdb=&gt; vacuum analyze tb_test;
VACUUM

testdb=&gt; set enable_seqscan = off;
SET
testdb=&gt; set enable_bitmapscan = off;
SET
</code></pre><ul><li>실행계획 확인</li></ul><pre><code>testdb=&gt; explain analyze select a from tb_test where b between 1 and  10;
                                                                  QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tb_test_a_b_idx on tb_test  (cost=0.42..37421.76 rows=98933 width=10) (actual time=29.327..294.907 rows=99957 loops=1)
   Index Cond: ((b &gt;= 1) AND (b &lt;= 10))
   Heap Fetches: 0
 Planning Time: 0.081 ms
 Execution Time: 301.603 ms
(5 rows)

</code></pre><p>위에서 실행계획을 봤을 땐 Index Only Scan plan을 제대로 타고 있고 별 문제 없어보입니다.<br>다만 Heap Fetches: 0 이라는 라인을 기억해두었다가 다시 한번 쿼리를 수행해보겠습니다.<br>아래와 같이 업데이트가 발생하고 어떤 무언가의 이슈로 vacuum이 돌지 않았다고 가정해보겠습니다.</p><ul><li>dead tuple 발생 후 실행계획 확인</li></ul><pre><code>testdb=&gt; alter table tb_test set (autovacuum_enabled = off);
ALTER TABLE

testdb=&gt; update tb_test set b = b + 1;
UPDATE 1000000
testdb=&gt; explain analyze select a from tb_test where b between 1 and  10;
                                                                  QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tb_test_a_b_idx on tb_test  (cost=0.43..67404.75 rows=197851 width=10) (actual time=0.095..336.188 rows=99921 loops=1)
   Index Cond: ((b &gt;= 1) AND (b &lt;= 10))
   Heap Fetches: 199878
 Planning Time: 0.073 ms
 Execution Time: 340.998 ms
(5 rows)

</code></pre><p>동일한 Index Only Scan의 플랜이지만<br>무언가 위는 Heap Fetches: 0인데 아래는 Heap Fetches 양이 엄청 늘었습니다.<br>여기서 Heap 은 PostgreSQL에서 테이블의 데이터 저장구조라고 보시면 됩니다.<br>즉 테이블을 의미하므로 Heap Fetches가 늘어났다는 것은 covering index를 이용했음에도 테이블에 접근, 곧 I/O가 발생했다는 의미입니다.</p><h1 id=visibility-map>Visibility Map<a hidden class=anchor aria-hidden=true href=#visibility-map>#</a></h1><p>이 현상을 이해하기 위해서는 Visibility Map을 이해해야하는데 간단히 말하면,<br>각 테이블의 데이터를 갖고 있고 테이블을 구성하는 page에 변경사항이 있는지 없는지를 체크해둔 메타데이터라고 생각하면 됩니다.</p><p>이것은 vacuum 의 성능을 개선하기 위해 나온 개념인데, Visibilit Map이 없었던 시절에는 vacuum을 할 때 모든 테이블을 풀스캔을 했습니다.<br>근데 Visibility Map이 나오면서, 데이터가 변경된 페이지, 변경되지 않은 페이지를 구분할 수 있게 되고, vacuum은 데이터가 변경된 페이지만 골라다 스캔을 할 수 있게 된 것입니다.</p><p>Visibility Map은 2bit로 구성됩니다.</p><ul><li><p>VISIBILITYMAP_ALL_VISIBLE : 페이지에 저장된 tuple들이 모든 트랜잭션에게 보이는지 안보이는지에 대한 여부를 의미합니다.</p><ul><li>1 : 해당 페이지의 모든 tuple들이 모든 트랜잭션에게 보이는 상태, dead tuple이 없음</li><li>0 : 해당 페이지에 dead tuple이 있거나, vacuum이 수행되지 않아 아직 모르는 상태임</li></ul></li><li><p>VISIBILITYMAP_ALL_FROZEN : 페이지에 저장된 tuple들이 freeze 되었는지에 대한 여부를 의미합니다.</p><ul><li>1 : 해당 페이지의 모든 tuple들이 freeze되어 vacuum freeze가 발생했을 때 해당 페이지는 스킵함</li><li>0 : 해당 페이지에 dead tuple이 있꺼나, vacuum이 수행되지 않아 아직 모르는 상태임</li></ul></li><li><p>Visibility Map 변화 확인</p></li></ul><pre><code>### 위에서 update 후 dead tuple이 있는 상태 

testdb=&gt; select blkno, all_visible, all_frozen from pg_visibility('tb_test') limit 10;
 blkno | all_visible | all_frozen
-------+-------------+------------
     0 | f           | f
     1 | f           | f
     2 | f           | f
     3 | f           | f
     4 | f           | f
     5 | f           | f
     6 | f           | f
     7 | f           | f
     8 | f           | f
     9 | f           | f
(10 rows)

### vacuum 후 정리된 상태
testdb=&gt; vacuum freeze tb_test;
VACUUM
testdb=&gt; select blkno, all_visible, all_frozen from pg_visibility('tb_test') limit 10;
 blkno | all_visible | all_frozen
-------+-------------+------------
     0 | t           | t
     1 | t           | t
     2 | t           | t
     3 | t           | t
     4 | t           | t
     5 | t           | t
     6 | t           | t
     7 | t           | t
     8 | t           | t
     9 | t           | t
(10 rows)
</code></pre><h1 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h1><p>정리하면, VISIBILITYMAP_ALL_VISIBLE = 0 인 상태, 데이터 페이지에 변경사항이 있다면
인덱스만 읽어서 될 게 아니라 테이블에 접근하여 해당 로우의 버전을 확인해야합니다.</p><p>나의 트랜잭션 아이디와 해당 로우의 버전을 비교하여 읽을 수 있는 데이터인지 읽을 수 없는 데이터인지를 확인해야 하기 때문입니다.</p><p>이것은 covering index인 Index Only Scan에서도 마찬가지라서 covering index임에도 불구하고 테이블 i/o가 발생할 수 있습니다.</p><p>index plan은 이슈없는데 테이블 스캔이 느리면 vacuum을 확인해보자!</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/postgresql/>postgresql</a></li></ul></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>