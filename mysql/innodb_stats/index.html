<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL index 생성 시 주의할점 | kimDuBiA</title><meta name=keywords content="mysql,운영"><meta name=description content="꽤 오래전 일이지만 재미있었던 장애 사례를 공유드리고자 합니다.
간단히 요약하자면, 신규로 컬럼을 추가하고 쿼리를 검수하여 인덱스를 생성했지만 인덱스에 대한 통계가 갱신되지 않아서
기대했던 대로 인덱스를 타지 못하고 풀스캔을 하면서 발생했던 장애입니다.
MySQL의 통계와 DDL 작업에 대해 다시한번 생각해보고 좀 더 꼼꼼히 작업할 수 있게 된 계기가 된 장애입니다
장애 개요  테이블의 통계 갱신이 안된 상태에서 신규 쿼리가 유입되어 적절한 인덱스를 타지 못하고 풀스캔한 현상 데이터 변화량이 MySQL의 통계 수집 기준에 못미쳐서 자동갱신이 안되었음 ( 기준 10%이상, 실제 변경량 4% ) 동일한 컬럼을 인덱싱하는 인덱스를 재생성하여 통계를 새로 반영하면서 해소됨  문제의 slowquery select tb_test0_."><meta name=author content="kimdubi"><link rel=canonical href=/mysql/innodb_stats/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL index 생성 시 주의할점"><meta property="og:description" content="꽤 오래전 일이지만 재미있었던 장애 사례를 공유드리고자 합니다.
간단히 요약하자면, 신규로 컬럼을 추가하고 쿼리를 검수하여 인덱스를 생성했지만 인덱스에 대한 통계가 갱신되지 않아서
기대했던 대로 인덱스를 타지 못하고 풀스캔을 하면서 발생했던 장애입니다.
MySQL의 통계와 DDL 작업에 대해 다시한번 생각해보고 좀 더 꼼꼼히 작업할 수 있게 된 계기가 된 장애입니다
장애 개요  테이블의 통계 갱신이 안된 상태에서 신규 쿼리가 유입되어 적절한 인덱스를 타지 못하고 풀스캔한 현상 데이터 변화량이 MySQL의 통계 수집 기준에 못미쳐서 자동갱신이 안되었음 ( 기준 10%이상, 실제 변경량 4% ) 동일한 컬럼을 인덱싱하는 인덱스를 재생성하여 통계를 새로 반영하면서 해소됨  문제의 slowquery select tb_test0_."><meta property="og:type" content="article"><meta property="og:url" content="/mysql/innodb_stats/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2022-09-04T15:05:50+09:00"><meta property="article:modified_time" content="2022-09-04T15:05:50+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL index 생성 시 주의할점"><meta name=twitter:description content="꽤 오래전 일이지만 재미있었던 장애 사례를 공유드리고자 합니다.
간단히 요약하자면, 신규로 컬럼을 추가하고 쿼리를 검수하여 인덱스를 생성했지만 인덱스에 대한 통계가 갱신되지 않아서
기대했던 대로 인덱스를 타지 못하고 풀스캔을 하면서 발생했던 장애입니다.
MySQL의 통계와 DDL 작업에 대해 다시한번 생각해보고 좀 더 꼼꼼히 작업할 수 있게 된 계기가 된 장애입니다
장애 개요  테이블의 통계 갱신이 안된 상태에서 신규 쿼리가 유입되어 적절한 인덱스를 타지 못하고 풀스캔한 현상 데이터 변화량이 MySQL의 통계 수집 기준에 못미쳐서 자동갱신이 안되었음 ( 기준 10%이상, 실제 변경량 4% ) 동일한 컬럼을 인덱싱하는 인덱스를 재생성하여 통계를 새로 반영하면서 해소됨  문제의 slowquery select tb_test0_."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL index 생성 시 주의할점","item":"/mysql/innodb_stats/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL index 생성 시 주의할점","name":"MySQL index 생성 시 주의할점","description":"꽤 오래전 일이지만 재미있었던 장애 사례를 공유드리고자 합니다.\n간단히 요약하자면, 신규로 컬럼을 추가하고 쿼리를 검수하여 인덱스를 생성했지만 인덱스에 대한 통계가 갱신되지 않아서\n기대했던 대로 인덱스를 타지 못하고 풀스캔을 하면서 발생했던 장애입니다.\nMySQL의 통계와 DDL 작업에 대해 다시한번 생각해보고 좀 더 꼼꼼히 작업할 수 있게 된 계기가 된 장애입니다\n장애 개요  테이블의 통계 갱신이 안된 상태에서 신규 쿼리가 유입되어 적절한 인덱스를 타지 못하고 풀스캔한 현상 데이터 변화량이 MySQL의 통계 수집 기준에 못미쳐서 자동갱신이 안되었음 ( 기준 10%이상, 실제 변경량 4% ) 동일한 컬럼을 인덱싱하는 인덱스를 재생성하여 통계를 새로 반영하면서 해소됨  문제의 slowquery select tb_test0_.","keywords":["mysql","운영"],"articleBody":"꽤 오래전 일이지만 재미있었던 장애 사례를 공유드리고자 합니다.\n간단히 요약하자면, 신규로 컬럼을 추가하고 쿼리를 검수하여 인덱스를 생성했지만 인덱스에 대한 통계가 갱신되지 않아서\n기대했던 대로 인덱스를 타지 못하고 풀스캔을 하면서 발생했던 장애입니다.\nMySQL의 통계와 DDL 작업에 대해 다시한번 생각해보고 좀 더 꼼꼼히 작업할 수 있게 된 계기가 된 장애입니다\n장애 개요  테이블의 통계 갱신이 안된 상태에서 신규 쿼리가 유입되어 적절한 인덱스를 타지 못하고 풀스캔한 현상 데이터 변화량이 MySQL의 통계 수집 기준에 못미쳐서 자동갱신이 안되었음 ( 기준 10%이상, 실제 변경량 4% ) 동일한 컬럼을 인덱싱하는 인덱스를 재생성하여 통계를 새로 반영하면서 해소됨  문제의 slowquery select tb_test0_.`id` as id1_53_, tb_test0_.`amt` as amt2_53_, tb_test0_.`intr_inv_id` as intr_inv5_53_, tb_test0_.manual_version as manual_v3_53_, tb_test0_.`version` as version4_53_ from `tb_test` tb_test0_ inner join `tb_test1` tb_test1 on tb_test0_.`intr_inv_id` = tb_test1.`id` inner join `tb_test2` tb_test2 on tb_test1.`lct_id` = tb_test2.`id` left outer join `tb_test3` tb_test3 on tb_test2.`tb_test3_id` = tb_test3.`id` inner join `tb_test4` tb_test4 on tb_test1.`intr_sku_id` = tb_test4.`id` inner join tb_test5 tb_test5 on tb_test5.id = tb_test4.tb_test5_id where tb_test2.`slbl` = 1 and tb_test5.inventory_id = 530123 and tb_test0_.`amt`  0 order by tb_test4.`exp_dt` asc, tb_test4.`rcv_date` asc, tb_test3.`seq` asc, tb_test2.`code` asc 실행계획 +----+-------------+--------------+------------+--------+------------------------------------------------------------------+----------------------------+---------+--------------------------------------------+--------+----------+--------------------------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------------+------------+--------+------------------------------------------------------------------+----------------------------+---------+--------------------------------------------+--------+----------+--------------------------------------------------------------+ | 1 | SIMPLE | tb_test5 | NULL | ref | PRIMARY,ix_sale_group_inventory_id | ix_sale_group_inventory_id | 8 | const | 1 | 100.00 | Using index; Using temporary; Using filesort | | 1 | SIMPLE | tb_test0_ | NULL | range | uix_tb_test_tb_test1,ix_tb_test_amt | ix_tb_test_amt | 9 | NULL | 918574 | 100.00 | Using index condition; Using join buffer (Block Nested Loop) | | 1 | SIMPLE | tb_test1 | NULL | eq_ref | PRIMARY,uix_tb_test1_tb_test2_sku,fk_intr_inv_intr_sku | PRIMARY | 8 | baemin_market_wms.tb_test0_.intr_inv_id | 1 | 100.00 | NULL | | 1 | SIMPLE | tb_test2 | NULL | eq_ref | PRIMARY,idx_tb_test2_01 | PRIMARY | 8 | baemin_market_wms.tb_test1.lct_id | 1 | 50.00 | Using where | | 1 | SIMPLE | tb_test3 | NULL | eq_ref | PRIMARY | PRIMARY | 8 | baemin_market_wms.tb_test2.tb_test3_id | 1 | 100.00 | NULL | | 1 | SIMPLE | tb_test4 | NULL | eq_ref | PRIMARY,ix_tb_test4_tb_test5_id | PRIMARY | 8 | baemin_market_wms.tb_test1.intr_sku_id | 1 | 100.00 | Using where | +----+-------------+--------------+------------+--------+------------------------------------------------------------------+----------------------------+---------+--------------------------------------------+--------+----------+--------------------------------------------------------------+ 6 rows in set, 1 warning (0.01 sec) 장애 원인 ## tb_test5 tb_test4 테이블 조인 시 인덱스를 못타서 쿼리가 비효율적으로 풀리는 현상\nselect * from tb_test5 tb_test5 inner join `tb_test4` tb_test4 use index(ix_tb_test4_tb_test5_id) on tb_test4.tb_test5_id = tb_test5.id where tb_test5.inventory_id = 530123 +----+-------------+--------------+------------+------+-----------------------------------------+----------------------------+---------+-------+----------+----------+----------------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------------+------------+------+-----------------------------------------+----------------------------+---------+-------+----------+----------+----------------------------------------------------+ | 1 | SIMPLE | tb_test5 | NULL | ref | PRIMARY,ix_sale_group_inventory_id | ix_sale_group_inventory_id | 8 | const | 1 | 100.00 | NULL | | 1 | SIMPLE | tb_test4 | NULL | ALL | ix_tb_test4_tb_test5_id | NULL | NULL | NULL | 11609224 | 100.00 | Using where; Using join buffer (Block Nested Loop) | +----+-------------+--------------+------------+------+-----------------------------------------+----------------------------+---------+-------+----------+----------+----------------------------------------------------+ 2 rows in set, 1 warning (0.00 sec) 비효율 플랜 원인 mysql show index from tb_test4; +--------------+------------+-----------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +--------------+------------+-----------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | tb_test4 | 0 | PRIMARY | 1 | id | A | 11609224 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 1 | sku_id | A | 16611 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 2 | crtd_cntr_id | A | 526440 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 3 | rcv_date | A | 11340375 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 4 | exp_dt | A | 11562687 | NULL | NULL | YES | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 5 | mnf_dt | A | 11552975 | NULL | NULL | YES | BTREE | | | | tb_test4 | 1 | fk_intr_sku_crtd_center | 1 | crtd_cntr_id | A | 56 | NULL | NULL | | BTREE | | | | tb_test4 | 1 | ix_tb_test4_tb_test5_id | 1 | tb_test5_id | A | 1 | NULL | NULL | YES | BTREE | | | +--------------+------------+-----------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ ix_tb_test4_tb_test5_id index의 cardinality 가 1로 optimizer는 해당 인덱스를 타는 것이 비효율적이라고 판단하여 fullscan을 하였음 장애 조치내용 alter table tb_test4 add key idx_tb_test4_tb_test5_id (tb_test5_id),algorithm=inplace,lock=none; mysql show index from tb_test4; +--------------+------------+------------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +--------------+------------+------------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | tb_test4 | 0 | PRIMARY | 1 | id | A | 11609224 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 1 | sku_id | A | 16611 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 2 | crtd_cntr_id | A | 526440 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 3 | rcv_date | A | 11340374 | NULL | NULL | | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 4 | exp_dt | A | 11562688 | NULL | NULL | YES | BTREE | | | | tb_test4 | 0 | uix_tb_test4 | 5 | mnf_dt | A | 11552976 | NULL | NULL | YES | BTREE | | | | tb_test4 | 1 | fk_intr_sku_crtd_center | 1 | crtd_cntr_id | A | 56 | NULL | NULL | | BTREE | | | | tb_test4 | 1 | ix_tb_test4_tb_test5_id | 1 | tb_test5_id | A | 1 | NULL | NULL | YES | BTREE | | | | tb_test4 | 1 | idx_tb_test4_tb_test5_id | 1 | tb_test5_id | A | 262408 | NULL | NULL | YES | BTREE | | | +--------------+------------+------------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ = tb_test5_id 컬럼을 인덱싱 하는 인덱스를 새로 생성하여 테이블 통계를 새로 반영함\nindex cardinality가 1 이었던 이유 ? mysql select count(*) from tb_test4 where tb_test5_id is null; +----------+ | count(*) | +----------+ | 11225307 | +----------+ 1 row in set (4.12 sec) mysql select count(*) from tb_test4 where tb_test5_id is not null; +----------+ | count(*) | +----------+ | 442238 | +----------+ 1 row in set (0.14 sec) mysql select 442238/11225307 * 100; +-----------------------+ | 442238/11225307 * 100 | +-----------------------+ | 3.9397 | +-----------------------+ 1 row in set (0.00 sec)  tb_test4 문제 테이블의 컬럼과 인덱스는 12/20일날 추가되었음 MySQL의 통계정보 갱신 정책은 테이블의 변경되는 row가 10% 혹은 6.25% 이상이어야 변경됨 (hard coding 되어있음) 1,000만건 테이블에 컬럼과 인덱스를 추가했을 땐 NULL 값으로 cardinality가 1로 index가 생성되었음 (정상) 그 이후 신규 데이터가 들어왔지만 44만건으로, 전체 테이블 중 4%정도밖에 되지 않기 때문에 인덱스의 통계가 갱신되지 않은 상태에서 문제가 되는 신규 쿼리가 유입됨 이후 9:43 분, 인덱스를 새로 생성하면서 통계가 갱신되어 이슈 해소  MySQL 통계 관련 코드 vi mysql-8.0.25/storage/innobase/row/row0mysql.cc 1100번째 라인 /** Updates the table modification counter and calculates new estimates for table and index statistics if necessary. */ UNIV_INLINE void row_update_statistics_if_needed(dict_table_t *table) /*!stat_initialized) { DBUG_EXECUTE_IF(\"test_upd_stats_if_needed_not_inited\", fprintf(stderr, \"test_upd_stats_if_needed_not_inited\" \" was executed\\n\");); return; } counter = table-stat_modified_counter++; n_rows = dict_table_get_n_rows(table); if (dict_stats_is_persistent_enabled(table)) { if (counter  n_rows / 10 /* 10% */ \u0026\u0026 dict_stats_auto_recalc_is_enabled(table)) { dict_stats_recalc_pool_add(table); table-stat_modified_counter = 0; } return; } /* Calculate new statistics if 1 / 16 of table has been modified since the last time a statistics batch was run. We calculate statistics at most every 16th round, since we may have a counter table which is very small and updated very often. */ if (counter  16 + n_rows / 16 /* 6.25% */) { ut_ad(!mutex_own(\u0026dict_sys-mutex)); /* this will reset table-stat_modified_counter to 0 */ dict_stats_update(table, DICT_STATS_RECALC_TRANSIENT); } } 관련 파라미터  innodb_stats_persistent  ON - 테이블 변경 10% 발생시 통계 갱신  optimizer가 사용할 통계를 disk에 저장하여 서버가 재시작되어도 통계정보를 지속적으로 유지할 수 있음 (mysql.innodb_table_stats , mysql.innodb_index_stats)   OFF - 6.25% 이상 발생시 통계 갱신    ","wordCount":"1351","inLanguage":"en","datePublished":"2022-09-04T15:05:50+09:00","dateModified":"2022-09-04T15:05:50+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/innodb_stats/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL index 생성 시 주의할점</h1><div class=post-meta>September 4, 2022&nbsp;·&nbsp;7 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%9e%a5%ec%95%a0-%ea%b0%9c%ec%9a%94 aria-label="장애 개요">장애 개요</a><ul><li><a href=#%eb%ac%b8%ec%a0%9c%ec%9d%98-slowquery aria-label="문제의 slowquery">문제의 slowquery</a><ul><li><a href=#%ec%8b%a4%ed%96%89%ea%b3%84%ed%9a%8d aria-label=실행계획>실행계획</a></li></ul></li></ul></li><li><a href=#%ec%9e%a5%ec%95%a0-%ec%9b%90%ec%9d%b8 aria-label="장애 원인">장애 원인</a><ul><li><a href=#%eb%b9%84%ed%9a%a8%ec%9c%a8-%ed%94%8c%eb%9e%9c-%ec%9b%90%ec%9d%b8 aria-label="비효율 플랜 원인">비효율 플랜 원인</a></li></ul></li><li><a href=#%ec%9e%a5%ec%95%a0-%ec%a1%b0%ec%b9%98%eb%82%b4%ec%9a%a9 aria-label="장애 조치내용">장애 조치내용</a><ul><li><a href=#index-cardinality%ea%b0%80-1-%ec%9d%b4%ec%97%88%eb%8d%98-%ec%9d%b4%ec%9c%a0- aria-label="index cardinality가 1 이었던 이유 ?">index cardinality가 1 이었던 이유 ?</a></li><li><a href=#mysql-%ed%86%b5%ea%b3%84-%ea%b4%80%eb%a0%a8-%ec%bd%94%eb%93%9c aria-label="MySQL 통계 관련 코드">MySQL 통계 관련 코드</a></li><li><a href=#%ea%b4%80%eb%a0%a8-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0 aria-label="관련 파라미터">관련 파라미터</a></li></ul></li></ul></div></details></div><div class=post-content><p>꽤 오래전 일이지만 재미있었던 장애 사례를 공유드리고자 합니다.<br>간단히 요약하자면, 신규로 컬럼을 추가하고 쿼리를 검수하여 인덱스를 생성했지만 인덱스에 대한 통계가 갱신되지 않아서<br>기대했던 대로 인덱스를 타지 못하고 풀스캔을 하면서 발생했던 장애입니다.<br>MySQL의 통계와 DDL 작업에 대해 다시한번 생각해보고 좀 더 꼼꼼히 작업할 수 있게 된 계기가 된 장애입니다</p><h1 id=장애-개요>장애 개요<a hidden class=anchor aria-hidden=true href=#장애-개요>#</a></h1><ul><li>테이블의 통계 갱신이 안된 상태에서 신규 쿼리가 유입되어 적절한 인덱스를 타지 못하고 풀스캔한 현상</li><li>데이터 변화량이 MySQL의 통계 수집 기준에 못미쳐서 자동갱신이 안되었음 ( 기준 10%이상, 실제 변경량 4% )</li><li>동일한 컬럼을 인덱싱하는 인덱스를 재생성하여 통계를 새로 반영하면서 해소됨</li></ul><h2 id=문제의-slowquery>문제의 slowquery<a hidden class=anchor aria-hidden=true href=#문제의-slowquery>#</a></h2><pre><code>select 
  tb_test0_.`id` as id1_53_, 
  tb_test0_.`amt` as amt2_53_, 
  tb_test0_.`intr_inv_id` as intr_inv5_53_, 
  tb_test0_.manual_version as manual_v3_53_, 
  tb_test0_.`version` as version4_53_ 
from 
  `tb_test` tb_test0_ 
  inner join `tb_test1` tb_test1 on tb_test0_.`intr_inv_id` = tb_test1.`id` 
  inner join `tb_test2` tb_test2   on tb_test1.`lct_id` = tb_test2.`id` 
  left outer join `tb_test3` tb_test3 on tb_test2.`tb_test3_id` = tb_test3.`id` 
  inner join `tb_test4` tb_test4 on tb_test1.`intr_sku_id` = tb_test4.`id` 
  inner join tb_test5 tb_test5 on tb_test5.id = tb_test4.tb_test5_id
where 
  tb_test2.`slbl` = 1 
  and tb_test5.inventory_id = 530123 
  and tb_test0_.`amt` &gt; 0 
order by 
  tb_test4.`exp_dt` asc, 
  tb_test4.`rcv_date` asc, 
  tb_test3.`seq` asc, 
  tb_test2.`code` asc
</code></pre><h3 id=실행계획>실행계획<a hidden class=anchor aria-hidden=true href=#실행계획>#</a></h3><pre><code>+----+-------------+--------------+------------+--------+------------------------------------------------------------------+----------------------------+---------+--------------------------------------------+--------+----------+--------------------------------------------------------------+
| id | select_type | table        | partitions | type   | possible_keys                                                    | key                        | key_len | ref                                        | rows   | filtered | Extra                                                        |
+----+-------------+--------------+------------+--------+------------------------------------------------------------------+----------------------------+---------+--------------------------------------------+--------+----------+--------------------------------------------------------------+
|  1 | SIMPLE      | tb_test5 | NULL       | ref    | PRIMARY,ix_sale_group_inventory_id                               | ix_sale_group_inventory_id | 8       | const                                      |      1 |   100.00 | Using index; Using temporary; Using filesort                 |
|  1 | SIMPLE      | tb_test0_ | NULL       | range  | uix_tb_test_tb_test1,ix_tb_test_amt      | ix_tb_test_amt      | 9       | NULL                                       | 918574 |   100.00 | Using index condition; Using join buffer (Block Nested Loop) |
|  1 | SIMPLE      | tb_test1 | NULL       | eq_ref | PRIMARY,uix_tb_test1_tb_test2_sku,fk_intr_inv_intr_sku | PRIMARY                    | 8       | baemin_market_wms.tb_test0_.intr_inv_id |      1 |   100.00 | NULL                                                         |
|  1 | SIMPLE      | tb_test2   | NULL       | eq_ref | PRIMARY,idx_tb_test2_01                                          | PRIMARY                    | 8       | baemin_market_wms.tb_test1.lct_id      |      1 |    50.00 | Using where                                                  |
|  1 | SIMPLE      | tb_test3       | NULL       | eq_ref | PRIMARY                                                          | PRIMARY                    | 8       | baemin_market_wms.tb_test2.tb_test3_id       |      1 |   100.00 | NULL                                                         |
|  1 | SIMPLE      | tb_test4 | NULL       | eq_ref | PRIMARY,ix_tb_test4_tb_test5_id                  | PRIMARY                    | 8       | baemin_market_wms.tb_test1.intr_sku_id |      1 |   100.00 | Using where                                                  |
+----+-------------+--------------+------------+--------+------------------------------------------------------------------+----------------------------+---------+--------------------------------------------+--------+----------+--------------------------------------------------------------+
6 rows in set, 1 warning (0.01 sec)
</code></pre><h1 id=장애-원인>장애 원인<a hidden class=anchor aria-hidden=true href=#장애-원인>#</a></h1><p>## tb_test5 tb_test4 테이블 조인 시 인덱스를 못타서 쿼리가 비효율적으로 풀리는 현상</p><pre><code>select 
  *
from tb_test5 tb_test5 
  inner join `tb_test4` tb_test4 use index(ix_tb_test4_tb_test5_id) on tb_test4.tb_test5_id = tb_test5.id 
where 
   tb_test5.inventory_id = 530123 

+----+-------------+--------------+------------+------+-----------------------------------------+----------------------------+---------+-------+----------+----------+----------------------------------------------------+
| id | select_type | table        | partitions | type | possible_keys                           | key                        | key_len | ref   | rows     | filtered | Extra                                              |
+----+-------------+--------------+------------+------+-----------------------------------------+----------------------------+---------+-------+----------+----------+----------------------------------------------------+
|  1 | SIMPLE      | tb_test5 | NULL       | ref  | PRIMARY,ix_sale_group_inventory_id      | ix_sale_group_inventory_id | 8       | const |        1 |   100.00 | NULL                                               |
|  1 | SIMPLE      | tb_test4 | NULL       | ALL  | ix_tb_test4_tb_test5_id | NULL                       | NULL    | NULL  | 11609224 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+--------------+------------+------+-----------------------------------------+----------------------------+---------+-------+----------+----------+----------------------------------------------------+
2 rows in set, 1 warning (0.00 sec)
</code></pre><h2 id=비효율-플랜-원인>비효율 플랜 원인<a hidden class=anchor aria-hidden=true href=#비효율-플랜-원인>#</a></h2><pre><code>mysql&gt; show index from tb_test4;
+--------------+------------+-----------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table        | Non_unique | Key_name                                | Seq_in_index | Column_name             | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+--------------+------------+-----------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| tb_test4 |          0 | PRIMARY                                 |            1 | id                      | A         |    11609224 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                        |            1 | sku_id                  | A         |       16611 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                        |            2 | crtd_cntr_id            | A         |      526440 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                        |            3 | rcv_date                | A         |    11340375 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                        |            4 | exp_dt                  | A         |    11562687 |     NULL | NULL   | YES  | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                        |            5 | mnf_dt                  | A         |    11552975 |     NULL | NULL   | YES  | BTREE      |         |               |
| tb_test4 |          1 | fk_intr_sku_crtd_center                 |            1 | crtd_cntr_id            | A         |          56 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          1 | ix_tb_test4_tb_test5_id |            1 | tb_test5_id | A         |           1 |     NULL | NULL   | YES  | BTREE      |         |               |
+--------------+------------+-----------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
ix_tb_test4_tb_test5_id index의 cardinality 가 1로 optimizer는 해당 인덱스를 타는 것이 비효율적이라고 판단하여 fullscan을 하였음  
</code></pre><h1 id=장애-조치내용>장애 조치내용<a hidden class=anchor aria-hidden=true href=#장애-조치내용>#</a></h1><pre><code>alter table tb_test4 add key idx_tb_test4_tb_test5_id  (tb_test5_id),algorithm=inplace,lock=none;  


mysql&gt; show index from tb_test4;
+--------------+------------+------------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table        | Non_unique | Key_name                                 | Seq_in_index | Column_name             | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+--------------+------------+------------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| tb_test4 |          0 | PRIMARY                                  |            1 | id                      | A         |    11609224 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                         |            1 | sku_id                  | A         |       16611 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                         |            2 | crtd_cntr_id            | A         |      526440 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                         |            3 | rcv_date                | A         |    11340374 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                         |            4 | exp_dt                  | A         |    11562688 |     NULL | NULL   | YES  | BTREE      |         |               |
| tb_test4 |          0 | uix_tb_test4                         |            5 | mnf_dt                  | A         |    11552976 |     NULL | NULL   | YES  | BTREE      |         |               |
| tb_test4 |          1 | fk_intr_sku_crtd_center                  |            1 | crtd_cntr_id            | A         |          56 |     NULL | NULL   |      | BTREE      |         |               |
| tb_test4 |          1 | ix_tb_test4_tb_test5_id  |            1 | tb_test5_id | A         |           1 |     NULL | NULL   | YES  | BTREE      |         |               |
| tb_test4 |          1 | idx_tb_test4_tb_test5_id |            1 | tb_test5_id | A         |      262408 |     NULL | NULL   | YES  | BTREE      |         |               |
+--------------+------------+------------------------------------------+--------------+-------------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</code></pre><p>=> tb_test5_id 컬럼을 인덱싱 하는 인덱스를 새로 생성하여 테이블 통계를 새로 반영함</p><h2 id=index-cardinality가-1-이었던-이유->index cardinality가 1 이었던 이유 ?<a hidden class=anchor aria-hidden=true href=#index-cardinality가-1-이었던-이유->#</a></h2><pre><code>mysql&gt; select count(*) from tb_test4 where tb_test5_id is null;  
+----------+
| count(*) |
+----------+
| 11225307 |
+----------+
1 row in set (4.12 sec)

mysql&gt; select count(*) from tb_test4 where tb_test5_id is not null;
+----------+
| count(*) |
+----------+
|   442238 |
+----------+
1 row in set (0.14 sec)

mysql&gt; select 442238/11225307 * 100;
+-----------------------+
| 442238/11225307 * 100 |
+-----------------------+
|                3.9397 |
+-----------------------+
1 row in set (0.00 sec)
</code></pre><ul><li>tb_test4 문제 테이블의 컬럼과 인덱스는 12/20일날 추가되었음</li><li>MySQL의 통계정보 갱신 정책은 테이블의 변경되는 row가 10% 혹은 6.25% 이상이어야 변경됨 (hard coding 되어있음)</li><li>1,000만건 테이블에 컬럼과 인덱스를 추가했을 땐 NULL 값으로 cardinality가 1로 index가 생성되었음 (정상)</li><li>그 이후 신규 데이터가 들어왔지만 44만건으로, 전체 테이블 중 4%정도밖에 되지 않기 때문에 인덱스의 통계가 갱신되지 않은 상태에서 문제가 되는 신규 쿼리가 유입됨</li><li>이후 9:43 분, 인덱스를 새로 생성하면서 통계가 갱신되어 이슈 해소</li></ul><h2 id=mysql-통계-관련-코드>MySQL 통계 관련 코드<a hidden class=anchor aria-hidden=true href=#mysql-통계-관련-코드>#</a></h2><pre><code>vi mysql-8.0.25/storage/innobase/row/row0mysql.cc 1100번째 라인
/** Updates the table modification counter and calculates new estimates
 for table and index statistics if necessary. */
UNIV_INLINE
void row_update_statistics_if_needed(dict_table_t *table) /*!&lt; in: table */
{
  ib_uint64_t counter;
  ib_uint64_t n_rows;

  if (!table-&gt;stat_initialized) {
    DBUG_EXECUTE_IF(&quot;test_upd_stats_if_needed_not_inited&quot;,
                    fprintf(stderr,
                            &quot;test_upd_stats_if_needed_not_inited&quot;
                            &quot; was executed\n&quot;););
    return;
  }

  counter = table-&gt;stat_modified_counter++;
  n_rows = dict_table_get_n_rows(table);

  if (dict_stats_is_persistent_enabled(table)) {
    if (counter &gt; n_rows / 10 /* 10% */
        &amp;&amp; dict_stats_auto_recalc_is_enabled(table)) {
      dict_stats_recalc_pool_add(table);
      table-&gt;stat_modified_counter = 0;
    }
    return;
  }

  /* Calculate new statistics if 1 / 16 of table has been modified
  since the last time a statistics batch was run.
  We calculate statistics at most every 16th round, since we may have
  a counter table which is very small and updated very often. */

  if (counter &gt; 16 + n_rows / 16 /* 6.25% */) {
    ut_ad(!mutex_own(&amp;dict_sys-&gt;mutex));
    /* this will reset table-&gt;stat_modified_counter to 0 */
    dict_stats_update(table, DICT_STATS_RECALC_TRANSIENT);
  }
}
</code></pre><h2 id=관련-파라미터>관련 파라미터<a hidden class=anchor aria-hidden=true href=#관련-파라미터>#</a></h2><ul><li>innodb_stats_persistent<ul><li>ON -> 테이블 변경 10% 발생시 통계 갱신<ul><li>optimizer가 사용할 통계를 disk에 저장하여 서버가 재시작되어도 통계정보를 지속적으로 유지할 수 있음</li><li>(mysql.innodb_table_stats , mysql.innodb_index_stats)</li></ul></li><li>OFF -> 6.25% 이상 발생시 통계 갱신</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/%EC%9A%B4%EC%98%81/>운영</a></li></ul><nav class=paginav><a class=prev href=/redis/riot_redis/><span class=title>« Prev Page</span><br><span>ElastiCache(Redis) migration tool RIOT-REDIS</span></a>
<a class=next href=/mysql/replication_8/><span class=title>Next Page »</span><br><span>MySQL 5.7 vs 8 replication 비교</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>