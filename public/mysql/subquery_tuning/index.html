<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Subquery Tuning | kimDuBiA</title><meta name=keywords content="mysql,sql"><meta name=description content="Subquery Tuning 서브쿼리 동작 방식 filter  서브쿼리의 결과 건수가 몇건이건 상관 없이 전체 쿼리의 결과는 최대 메인쿼리 결과만큼나옴 메인 쿼리 수행 결과 만큼 서브쿼리를 실행함, 쿼리 순서는 메인쿼리 -> 서브쿼리 고정 메인 쿼리 실행 결과 건 수 + 서브쿼리로 input 되는 값 에 따라 경우의 수 나뉠 수 있음  메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 적음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 하지 않고 중복되는 값이 많음 2>3>1 순으로 성능 나올 것 Filter 동작 방식은 메인쿼리의 실행 결과 건수가 많고 (조인 시도 횟수 증가),서브 쿼리에 제공하는 input 값의 종류가 많을 수록 성능이 좋지않음 (캐싱 효율 떨어짐)"><meta name=author content="kimdubi"><link rel=canonical href=/mysql/subquery_tuning/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><link rel=preload href=/apple-touch-icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="Subquery Tuning"><meta property="og:description" content="Subquery Tuning 서브쿼리 동작 방식 filter  서브쿼리의 결과 건수가 몇건이건 상관 없이 전체 쿼리의 결과는 최대 메인쿼리 결과만큼나옴 메인 쿼리 수행 결과 만큼 서브쿼리를 실행함, 쿼리 순서는 메인쿼리 -> 서브쿼리 고정 메인 쿼리 실행 결과 건 수 + 서브쿼리로 input 되는 값 에 따라 경우의 수 나뉠 수 있음  메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 적음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 하지 않고 중복되는 값이 많음 2>3>1 순으로 성능 나올 것 Filter 동작 방식은 메인쿼리의 실행 결과 건수가 많고 (조인 시도 횟수 증가),서브 쿼리에 제공하는 input 값의 종류가 많을 수록 성능이 좋지않음 (캐싱 효율 떨어짐)"><meta property="og:type" content="article"><meta property="og:url" content="/mysql/subquery_tuning/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2021-10-04T20:50:50+09:00"><meta property="article:modified_time" content="2021-10-04T20:50:50+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Subquery Tuning"><meta name=twitter:description content="Subquery Tuning 서브쿼리 동작 방식 filter  서브쿼리의 결과 건수가 몇건이건 상관 없이 전체 쿼리의 결과는 최대 메인쿼리 결과만큼나옴 메인 쿼리 수행 결과 만큼 서브쿼리를 실행함, 쿼리 순서는 메인쿼리 -> 서브쿼리 고정 메인 쿼리 실행 결과 건 수 + 서브쿼리로 input 되는 값 에 따라 경우의 수 나뉠 수 있음  메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 적음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 하지 않고 중복되는 값이 많음 2>3>1 순으로 성능 나올 것 Filter 동작 방식은 메인쿼리의 실행 결과 건수가 많고 (조인 시도 횟수 증가),서브 쿼리에 제공하는 input 값의 종류가 많을 수록 성능이 좋지않음 (캐싱 효율 떨어짐)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"Subquery Tuning","item":"/mysql/subquery_tuning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Subquery Tuning","name":"Subquery Tuning","description":"Subquery Tuning 서브쿼리 동작 방식 filter  서브쿼리의 결과 건수가 몇건이건 상관 없이 전체 쿼리의 결과는 최대 메인쿼리 결과만큼나옴 메인 쿼리 수행 결과 만큼 서브쿼리를 실행함, 쿼리 순서는 메인쿼리 -\u0026gt; 서브쿼리 고정 메인 쿼리 실행 결과 건 수 + 서브쿼리로 input 되는 값 에 따라 경우의 수 나뉠 수 있음  메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 적음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 하지 않고 중복되는 값이 많음 2\u0026gt;3\u0026gt;1 순으로 성능 나올 것 Filter 동작 방식은 메인쿼리의 실행 결과 건수가 많고 (조인 시도 횟수 증가),서브 쿼리에 제공하는 input 값의 종류가 많을 수록 성능이 좋지않음 (캐싱 효율 떨어짐)","keywords":["mysql","sql"],"articleBody":"Subquery Tuning 서브쿼리 동작 방식 filter  서브쿼리의 결과 건수가 몇건이건 상관 없이 전체 쿼리의 결과는 최대 메인쿼리 결과만큼나옴 메인 쿼리 수행 결과 만큼 서브쿼리를 실행함, 쿼리 순서는 메인쿼리 - 서브쿼리 고정 메인 쿼리 실행 결과 건 수 + 서브쿼리로 input 되는 값 에 따라 경우의 수 나뉠 수 있음  메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 적음 + input 되는 값이 unique 한 경우 메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 하지 않고 중복되는 값이 많음 231 순으로 성능 나올 것 Filter 동작 방식은 메인쿼리의 실행 결과 건수가 많고 (조인 시도 횟수 증가),서브 쿼리에 제공하는 input 값의 종류가 많을 수록 성능이 좋지않음 (캐싱 효율 떨어짐)\n메인 쿼리의 결과 건수가 적거나,많더라도 서브 쿼리에 제공하는 input 값의 종류가 적을 수록 성능이 양호함    join  서브쿼리를 join 방식으로 바꾸면서 전체 결과 건 수가 달라질 수 있음, PK로 1:1 JOIN 되는 경우 상관없지만 1:M 관계라면 distinct를 추가할것 join 방식으로 변경하면서 쿼리 JOIN 순서도 제어 가능  서브쿼리 튜닝 유형 확인자 역할을 하는 테이블이 JOIN 으로 수행될 때 확인자 역할이란 FROM 절에 나오는 테이블 중 SELECT 절에서 사용되는 컬럼은 없고 단순히 WHERE절의 JOIN 조건이나, FILTER 조건으로만 사용되는 테이블을 뜻함\n이러한 확인자 역할의 테이블을 JOIN으로 처리할 때 아래 케이스와 같은 경우 비효율이 발생할 수 있음\n 다른 테이블과 확인자 역할의 테이블이 1:M 관계라 JOIN을 수행할 때 데이터 건수를 증가시켜 결국 전체 조인 연결 시도횟수를 증가시키게 되는 경우 확인자 역할 테이블 자체가 느리게 풀리는 경우  select a.*,b.* from tb_test1 a inner join tb_test2 b on a.id1=b.id1 inner join (SELECT id1 id2, min(mod_ymdt) FROM tb_test3 GROUP BY id1,id2) c on a.id2=c.id2 where a.id3='test' 튜닝 후 ### in select a.*,b.* from tb_test1 a inner join tb_test2 b on a.id1=b.id1 where a.id3='test' and a.id2 in ( select id2 from tb_test3 ) ### exists select a.*,b.* from tb_test1 a inner join tb_test2 b on a.id1=b.id1 where a.id3='test' and exists ( SELECT id1, id2 FROM tb_test3 where id2=a.id2 )  메인쿼리에 효율적인 조건이 없고 서브쿼리엔 좋은 조건이 있을 때 바로 위에서 JOIN 으로 풀리는 확인자 테이블을 in, exists 를 사용하는 서브쿼리로 수정했으나 아래와 같은 경우엔 오히려 서브쿼리를 JOIN으로 풀어줘야 성능이 향상됨\n 메인 쿼리에 서브쿼리 외에는 WHERE 조건이 없지만 서브쿼리에는 id1=1 같은 결과 건 수를 확 줄여줄 수 있는 조건이 있을 때  select a.*,b.* from tb_test1 a inner join tb_test2 b on a.id1=b.id1 where exists ( SELECT id1, id2 FROM tb_test3 where id2=a.id2 and id1=1 ) and exists ( SELECT id1, id2 FROM tb_test4 where id2=a.id2 ) and exists ( SELECT id1, id2 FROM tb_test3 where id2=a.id2 ) 튜닝 후 select distinct a.*,b.* from tb_test1 a inner join tb_test2 b on a.id1=b.id1 inner join (select distinct id1,id2 from tb_test3 where id1=1 ) c on a.id2=c.id2 where exists exists ( SELECT id1, id2 FROM tb_test4 where id2=a.id2 ) and exists ( SELECT id1, id2 FROM tb_test3 where id2=a.id2 )  = subquery 를 JOIN 으로 변경했기 때문에 distinct 를 추가해야한다\nminus  minus - not exists 로 변경 시엔 데이터 정합성을 위해 select 절에 나열된 컬럼들이 unique한지 체크할 것  distinct 를 추가하면 되긴 하지만 추가적으로 정렬 작업이 발생하기 때문에 피할 수 있으면 좋음    스칼라 서브쿼리 특징  스칼라 서브쿼리는 SELECT 절에 사용되는 서브쿼리로, 최대 반복 수행되는 횟수는 메인 쿼리의 결과 건수만큼임 스칼라 서브쿼리는 동일한 input에 대해서는 결과값을 캐싱하여 리턴하기 때문에 최초 1는 스칼라 서브쿼리를 직접 수행하게 되지만 그 이후의 동일한 값에 대해서는 실행을 스킵함 스칼라 서브쿼리의 결과값은 무조건 1건이거나 NULL 이어야함 = 메인 쿼리의 결과 건 수 에 영향을 미치지 않음 스칼라 서브쿼리를 JOIN 으로 변경할 때는 JOIN column은 distinct한 값을 가지기 위해 UNIQUE한 column 이어야 하며 LEFT OUTER JOIN으로 수행되어야함  스칼라 서브쿼리 튜닝 유형 스칼라 서브쿼리의 수행 위치 스칼라 서브쿼리는 메인 쿼리의 결과 건 수 만큼 실행되기 때문에 스칼라 서브쿼리의 수행위치에 크게 영향을 받음\nSELECT c1,c2,c3, (SELECT t2.c3 FROM tb_test2 t2 WHERE t2.c1=t1.c1 ) as t2_c3 FROM tb_test t1 order by c1,c2 limit 10;  튜닝 후 SELECT a.*, (SELECT t2.c3 FROM tb_test2 t2 WHERE t2.c1=a.c1 ) as t2_c3 FROM ( SELECT c1,c2,c3 FROM tb_test t1 order by c1,c2 limit 10 ) a  =tb_test 의 건 수가 100건이라 할때 첫번째 쿼리는 스칼라 서브쿼리를 100번 수행하여 나온 결과를 정렬 후 10건 추출,\n두번째 쿼리는 스칼라 서브쿼리를 10번만 수행하여 I/O 처리량에서 훨씬 효율적이게 됨\n스칼라 서브쿼리를 JOIN 으로 변경 배치 프로그램처럼 데이터 건 수가 많은 경우엔 비례해서 스칼라 서브쿼리의 수행횟수도 많아지기 때문에 성능이 나오기 어려움\n스칼라 서브쿼리를 JOIN으로 변경하여 HASH JOIN으로 유도하는 게 가장 효율적이나 MySQL에는 8.0.18 버전 부터 HASH JOIN을 지원하기 때문에 NL 조인으로 풀리도록 유도함\nhttps://sarc.io/index.php/mariadb/1768-mysql-8-0-18-hash-join\n변경 전 SELECT c1,c2,c3, (SELECT t2.c3 FROM tb_test2 t2 WHERE t2.c1=t1.c1 ) as t2_c3 FROM tb_test t1 order by c1,c2  변경 후 SELECT c1,c2,c3,t2.c3 FROM tb_test t1 LEFT OUTER JOIN tb_test2 t2 on t1.c1=t2.c1 order by c1,c2  변경 전 SELECT t1.EMPNO, t1.DEPT_NO FROM (SELECT E.EMPNO, (SELECT D.DEPTNO FROM DEPT D WHERE D.DEPTNO = E.DEPTNO) DEPT_NO FROM EMP E) t1 WHERE t1.DEPT_NO = 10 ;  = view 안에 스칼라 서브쿼리 컬럼이 있고 이 컬럼을 밖에서 where 조건으로 사용하는 경우, 해당 컬럼에 인덱스가 있어도 인덱스를 탈 수 없음\nt1.DEPT_NO 는 서브쿼리의 결과를 의미하기 때문에 가공된 컬럼처럼 동작함\n변경 후 SELECT t1.EMPNO, t1.DEPT_NO FROM (SELECT E.EMPNO, D.DEPTNO DEPT_NO FROM EMP E LEFT OUTER JOIN DEPT D ON D.DEPTNO = E.DEPTNO ) t1 WHERE DEPT_NO = 10 ;  = view 안의 서브쿼리를 OUTER JOIN으로 풀었고 필요 시 view 밖의 DEPT_NO=10 조건을 view 안으로 밀어넣어 인덱스를 타도록 유도 가능\n단 MySQL은 ORACLE과 달리 complex view(아래 조건이 포함된 view) 에 대해서는 위와 같은 view merging을 지원하지 않음  UNION GROUP BY DISTINCT Aggregation LIMIT 사용자 생성 변수 ORACLE에서는 GROUP BY, DISTINCT 을 포함해도 비용 비교 후 view merging을 할 수 있음\n= OUTER JOIN 으로 푼 것 보다 스칼라 서브쿼리가 더 빠를 수 있음  변경 전 mysql explain - SELECT (SELECT SUM(E_1.EMPNO) SUM_EMPNO FROM EMP E_1 WHERE E_1.EMPNO = E.EMPNO) SUM_EMPNO_1, - E.HIREDATE, - E.DEPTNO - FROM EMP E - WHERE E.DEPTNO = 10; +----+--------------------+-------+------------+--------+---------------+-----------+---------+--------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------------+-------+------------+--------+---------------+-----------+---------+--------------+------+----------+-------------+ | 1 | PRIMARY | E | NULL | ref | FK_DEPTNO | FK_DEPTNO | 2 | const | 3 | 100.00 | NULL | | 2 | DEPENDENT SUBQUERY | E_1 | NULL | eq_ref | PRIMARY | PRIMARY | 2 | test.E.EMPNO | 1 | 100.00 | Using index | +----+--------------------+-------+------------+--------+---------------+-----------+---------+--------------+------+----------+-------------+  변경 후 mysql explain - SELECT T_1.SUM_EMPNO SUM_EMPNO_1, - E.HIREDATE, - E.DEPTNO - FROM EMP E LEFT OUTER JOIN - (SELECT E_1.EMPNO, SUM(E_1.EMPNO) SUM_EMPNO - FROM EMP E_1 - GROUP BY E_1.EMPNO) T_1 on E.EMPNO = T_1.EMPNO - WHERE E.DEPTNO = 10; +----+-------------+------------+------------+-------+-------------------+-------------+---------+--------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+------------+------------+-------+-------------------+-------------+---------+--------------+------+----------+-------------+ | 1 | PRIMARY | E | NULL | ref | FK_DEPTNO | FK_DEPTNO | 2 | const | 3 | 100.00 | NULL | | 1 | PRIMARY |  | NULL | ref |  |  | 2 | test.E.EMPNO | 2 | 100.00 | NULL | | 2 | DERIVED | E_1 | NULL | index | PRIMARY,FK_DEPTNO | PRIMARY | 2 | NULL | 14 | 100.00 | Using index | +----+-------------+------------+------------+-------+-------------------+-------------+---------+--------------+------+----------+-------------+  = 집계함수를 포함한 스칼라 서브쿼리를 LEFT JOIN 으로 변경하면서 inline view에 group by가 포함됨\ngroup by 를 포함한 inline view는 view merging이 불가능하여 id=2 DERIVED 로 풀려 index 풀스캔을 하여 임시테이블을 생성한 뒤 조인하게 됨\n근데 ORACLE처럼 view merging 실패하면 E.DEPTNO=10 조건이 자동으로 inline view 안으로 pushdown 될 줄 알았는데 이것도 안되네..?\nOUTER JOIN하는 inline view 안에 group by 가 포함되어있으면 스칼라 조인으로 변환시키는 게 성능 상 이득일 수 있음\n","wordCount":"1256","inLanguage":"en","datePublished":"2021-10-04T20:50:50+09:00","dateModified":"2021-10-04T20:50:50+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/subquery_tuning/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>Subquery Tuning</h1><div class=post-meta>October 4, 2021&nbsp;·&nbsp;6 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#subquery-tuning aria-label="Subquery Tuning">Subquery Tuning</a></li><li><a href=#%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac-%eb%8f%99%ec%9e%91-%eb%b0%a9%ec%8b%9d aria-label="서브쿼리 동작 방식">서브쿼리 동작 방식</a><ul><li><a href=#filter aria-label=filter>filter</a></li><li><a href=#join aria-label=join>join</a></li></ul></li><li><a href=#%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac-%ed%8a%9c%eb%8b%9d-%ec%9c%a0%ed%98%95 aria-label="서브쿼리 튜닝 유형">서브쿼리 튜닝 유형</a><ul><li><a href=#%ed%99%95%ec%9d%b8%ec%9e%90-%ec%97%ad%ed%95%a0%ec%9d%84-%ed%95%98%eb%8a%94-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%9d%b4-join-%ec%9c%bc%eb%a1%9c-%ec%88%98%ed%96%89%eb%90%a0-%eb%95%8c aria-label="확인자 역할을 하는 테이블이 JOIN 으로 수행될 때">확인자 역할을 하는 테이블이 JOIN 으로 수행될 때</a><ul><li><a href=#%ed%8a%9c%eb%8b%9d-%ed%9b%84 aria-label="튜닝 후">튜닝 후</a></li></ul></li><li><a href=#%eb%a9%94%ec%9d%b8%ec%bf%bc%eb%a6%ac%ec%97%90-%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ec%a1%b0%ea%b1%b4%ec%9d%b4-%ec%97%86%ea%b3%a0-%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac%ec%97%94-%ec%a2%8b%ec%9d%80-%ec%a1%b0%ea%b1%b4%ec%9d%b4-%ec%9e%88%ec%9d%84-%eb%95%8c aria-label="메인쿼리에 효율적인 조건이 없고 서브쿼리엔 좋은 조건이 있을 때">메인쿼리에 효율적인 조건이 없고 서브쿼리엔 좋은 조건이 있을 때</a><ul><li><a href=#%ed%8a%9c%eb%8b%9d-%ed%9b%84-1 aria-label="튜닝 후">튜닝 후</a></li></ul></li><li><a href=#minus aria-label=minus>minus</a></li></ul></li><li><a href=#%ec%8a%a4%ec%b9%bc%eb%9d%bc-%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac-%ed%8a%b9%ec%a7%95 aria-label="스칼라 서브쿼리 특징">스칼라 서브쿼리 특징</a></li><li><a href=#%ec%8a%a4%ec%b9%bc%eb%9d%bc-%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac-%ed%8a%9c%eb%8b%9d-%ec%9c%a0%ed%98%95 aria-label="스칼라 서브쿼리 튜닝 유형">스칼라 서브쿼리 튜닝 유형</a><ul><li><a href=#%ec%8a%a4%ec%b9%bc%eb%9d%bc-%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac%ec%9d%98-%ec%88%98%ed%96%89-%ec%9c%84%ec%b9%98 aria-label="스칼라 서브쿼리의 수행 위치">스칼라 서브쿼리의 수행 위치</a><ul><li><a href=#%ed%8a%9c%eb%8b%9d-%ed%9b%84-2 aria-label="튜닝 후">튜닝 후</a></li></ul></li><li><a href=#%ec%8a%a4%ec%b9%bc%eb%9d%bc-%ec%84%9c%eb%b8%8c%ec%bf%bc%eb%a6%ac%eb%a5%bc-join-%ec%9c%bc%eb%a1%9c-%eb%b3%80%ea%b2%bd aria-label="스칼라 서브쿼리를 JOIN 으로 변경">스칼라 서브쿼리를 JOIN 으로 변경</a><ul><li><a href=#%eb%b3%80%ea%b2%bd-%ec%a0%84 aria-label="변경 전">변경 전</a></li><li><a href=#%eb%b3%80%ea%b2%bd-%ed%9b%84 aria-label="변경 후">변경 후</a></li><li><a href=#%eb%b3%80%ea%b2%bd-%ec%a0%84-1 aria-label="변경 전">변경 전</a></li><li><a href=#%eb%b3%80%ea%b2%bd-%ed%9b%84-1 aria-label="변경 후">변경 후</a></li></ul></li><li><a href=#%eb%8b%a8-mysql%ec%9d%80-oracle%ea%b3%bc-%eb%8b%ac%eb%a6%ac-complex-view%ec%95%84%eb%9e%98-%ec%a1%b0%ea%b1%b4%ec%9d%b4-%ed%8f%ac%ed%95%a8%eb%90%9c-view-%ec%97%90-%eb%8c%80%ed%95%b4%ec%84%9c%eb%8a%94-%ec%9c%84%ec%99%80-%ea%b0%99%ec%9d%80-view-merging%ec%9d%84-%ec%a7%80%ec%9b%90%ed%95%98%ec%a7%80-%ec%95%8a%ec%9d%8c aria-label="단 MySQL은 ORACLE과 달리 complex view(아래 조건이 포함된 view) 에 대해서는 위와 같은 view merging을 지원하지 않음">단 MySQL은 ORACLE과 달리 complex view(아래 조건이 포함된 view) 에 대해서는 위와 같은 view merging을 지원하지 않음</a><ul><li><a href=#%eb%b3%80%ea%b2%bd-%ec%a0%84-2 aria-label="변경 전">변경 전</a></li><li><a href=#%eb%b3%80%ea%b2%bd-%ed%9b%84-2 aria-label="변경 후">변경 후</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=subquery-tuning>Subquery Tuning<a hidden class=anchor aria-hidden=true href=#subquery-tuning>#</a></h2><h2 id=서브쿼리-동작-방식>서브쿼리 동작 방식<a hidden class=anchor aria-hidden=true href=#서브쿼리-동작-방식>#</a></h2><h3 id=filter>filter<a hidden class=anchor aria-hidden=true href=#filter>#</a></h3><ul><li>서브쿼리의 결과 건수가 몇건이건 상관 없이 전체 쿼리의 결과는 최대 메인쿼리 결과만큼나옴</li><li>메인 쿼리 수행 결과 만큼 서브쿼리를 실행함, 쿼리 순서는 메인쿼리 -> 서브쿼리 고정</li><li>메인 쿼리 실행 결과 건 수 + 서브쿼리로 input 되는 값 에 따라 경우의 수 나뉠 수 있음<ul><li>메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 한 경우</li><li>메인 쿼리 실행 결과 건 수 적음 + input 되는 값이 unique 한 경우</li><li>메인 쿼리 실행 결과 건 수 많음 + input 되는 값이 unique 하지 않고 중복되는 값이 많음</li><li>2>3>1 순으로 성능 나올 것</li><li>Filter 동작 방식은 메인쿼리의 실행 결과 건수가 많고 (조인 시도 횟수 증가),서브 쿼리에 제공하는 input 값의 종류가 많을 수록 성능이 좋지않음 (캐싱 효율 떨어짐)<br>메인 쿼리의 결과 건수가 적거나,많더라도 서브 쿼리에 제공하는 input 값의 종류가 적을 수록 성능이 양호함</li></ul></li></ul><h3 id=join>join<a hidden class=anchor aria-hidden=true href=#join>#</a></h3><ul><li>서브쿼리를 join 방식으로 바꾸면서 전체 결과 건 수가 달라질 수 있음, PK로 1:1 JOIN 되는 경우 상관없지만 1:M 관계라면 distinct를 추가할것</li><li>join 방식으로 변경하면서 쿼리 JOIN 순서도 제어 가능</li></ul><h2 id=서브쿼리-튜닝-유형>서브쿼리 튜닝 유형<a hidden class=anchor aria-hidden=true href=#서브쿼리-튜닝-유형>#</a></h2><h3 id=확인자-역할을-하는-테이블이-join-으로-수행될-때>확인자 역할을 하는 테이블이 JOIN 으로 수행될 때<a hidden class=anchor aria-hidden=true href=#확인자-역할을-하는-테이블이-join-으로-수행될-때>#</a></h3><p>확인자 역할이란 FROM 절에 나오는 테이블 중 SELECT 절에서 사용되는 컬럼은 없고 단순히 WHERE절의 JOIN 조건이나, FILTER 조건으로만 사용되는 테이블을 뜻함<br>이러한 확인자 역할의 테이블을 JOIN으로 처리할 때 아래 케이스와 같은 경우 비효율이 발생할 수 있음</p><ul><li>다른 테이블과 확인자 역할의 테이블이 1:M 관계라 JOIN을 수행할 때 데이터 건수를 증가시켜 결국 전체 조인 연결 시도횟수를 증가시키게 되는 경우</li><li>확인자 역할 테이블 자체가 느리게 풀리는 경우</li></ul><pre><code>select a.*,b.*
from tb_test1 a 
inner join tb_test2 b on a.id1=b.id1
inner join 
    (SELECT id1 id2, min(mod_ymdt)
        FROM   tb_test3
        GROUP  BY id1,id2) c on a.id2=c.id2
where a.id3='test' 
</code></pre><h4 id=튜닝-후>튜닝 후<a hidden class=anchor aria-hidden=true href=#튜닝-후>#</a></h4><pre><code>### in
select a.*,b.*
from tb_test1 a inner join tb_test2 b on a.id1=b.id1
where a.id3='test' 
and a.id2 in ( select id2 from tb_test3 )

### exists
select a.*,b.*
from tb_test1 a inner join tb_test2 b on a.id1=b.id1
where a.id3='test' 
and exists (
    SELECT id1, id2
    FROM   tb_test3
    where  id2=a.id2    
)
</code></pre><h3 id=메인쿼리에-효율적인-조건이-없고-서브쿼리엔-좋은-조건이-있을-때>메인쿼리에 효율적인 조건이 없고 서브쿼리엔 좋은 조건이 있을 때<a hidden class=anchor aria-hidden=true href=#메인쿼리에-효율적인-조건이-없고-서브쿼리엔-좋은-조건이-있을-때>#</a></h3><p>바로 위에서 JOIN 으로 풀리는 확인자 테이블을 in, exists 를 사용하는 서브쿼리로 수정했으나 아래와 같은 경우엔 오히려 서브쿼리를 JOIN으로 풀어줘야 성능이 향상됨</p><ul><li>메인 쿼리에 서브쿼리 외에는 WHERE 조건이 없지만 서브쿼리에는 id1=1 같은 결과 건 수를 확 줄여줄 수 있는 조건이 있을 때</li></ul><pre><code>select a.*,b.*
from tb_test1 a inner join tb_test2 b on a.id1=b.id1
where exists (
    SELECT id1, id2
    FROM   tb_test3
    where  id2=a.id2    
    and id1=1
)
and exists (
    SELECT id1, id2
    FROM   tb_test4
    where  id2=a.id2    
)
and exists (
    SELECT id1, id2
    FROM   tb_test3
    where  id2=a.id2    
)
</code></pre><h4 id=튜닝-후-1>튜닝 후<a hidden class=anchor aria-hidden=true href=#튜닝-후-1>#</a></h4><pre><code>select distinct a.*,b.*
from tb_test1 a inner join tb_test2 b on a.id1=b.id1
inner join (select distinct id1,id2 
            from tb_test3 
            where id1=1 ) c on a.id2=c.id2
where exists exists (
    SELECT id1, id2
    FROM   tb_test4
    where  id2=a.id2    
)
and exists (
    SELECT id1, id2
    FROM   tb_test3
    where  id2=a.id2    
)
</code></pre><p>=> subquery 를 JOIN 으로 변경했기 때문에 distinct 를 추가해야한다</p><h3 id=minus>minus<a hidden class=anchor aria-hidden=true href=#minus>#</a></h3><ul><li>minus -> not exists 로 변경 시엔 데이터 정합성을 위해 select 절에 나열된 컬럼들이 unique한지 체크할 것<ul><li>distinct 를 추가하면 되긴 하지만 추가적으로 정렬 작업이 발생하기 때문에 피할 수 있으면 좋음</li></ul></li></ul><h2 id=스칼라-서브쿼리-특징>스칼라 서브쿼리 특징<a hidden class=anchor aria-hidden=true href=#스칼라-서브쿼리-특징>#</a></h2><ul><li>스칼라 서브쿼리는 SELECT 절에 사용되는 서브쿼리로, 최대 반복 수행되는 횟수는 메인 쿼리의 결과 건수만큼임</li><li>스칼라 서브쿼리는 동일한 input에 대해서는 결과값을 캐싱하여 리턴하기 때문에 최초 1는 스칼라 서브쿼리를 직접 수행하게 되지만 그 이후의 동일한 값에 대해서는 실행을 스킵함</li><li>스칼라 서브쿼리의 결과값은 무조건 1건이거나 NULL 이어야함 => 메인 쿼리의 결과 건 수 에 영향을 미치지 않음</li><li>스칼라 서브쿼리를 JOIN 으로 변경할 때는 JOIN column은 distinct한 값을 가지기 위해 UNIQUE한 column 이어야 하며 LEFT OUTER JOIN으로 수행되어야함</li></ul><h2 id=스칼라-서브쿼리-튜닝-유형>스칼라 서브쿼리 튜닝 유형<a hidden class=anchor aria-hidden=true href=#스칼라-서브쿼리-튜닝-유형>#</a></h2><h3 id=스칼라-서브쿼리의-수행-위치>스칼라 서브쿼리의 수행 위치<a hidden class=anchor aria-hidden=true href=#스칼라-서브쿼리의-수행-위치>#</a></h3><p>스칼라 서브쿼리는 메인 쿼리의 결과 건 수 만큼 실행되기 때문에 스칼라 서브쿼리의 수행위치에 크게 영향을 받음</p><pre><code>SELECT c1,c2,c3, (SELECT t2.c3 FROM tb_test2 t2 WHERE t2.c1=t1.c1 ) as t2_c3
FROM tb_test t1
order by c1,c2
limit 10;
</code></pre><h4 id=튜닝-후-2>튜닝 후<a hidden class=anchor aria-hidden=true href=#튜닝-후-2>#</a></h4><pre><code>SELECT a.*, (SELECT t2.c3 FROM tb_test2 t2 WHERE t2.c1=a.c1 ) as t2_c3
FROM (
    SELECT c1,c2,c3
    FROM tb_test t1
    order by c1,c2
    limit 10
) a
</code></pre><p>=>tb_test 의 건 수가 100건이라 할때 첫번째 쿼리는 스칼라 서브쿼리를 100번 수행하여 나온 결과를 정렬 후 10건 추출,<br>두번째 쿼리는 스칼라 서브쿼리를 10번만 수행하여 I/O 처리량에서 훨씬 효율적이게 됨</p><h3 id=스칼라-서브쿼리를-join-으로-변경>스칼라 서브쿼리를 JOIN 으로 변경<a hidden class=anchor aria-hidden=true href=#스칼라-서브쿼리를-join-으로-변경>#</a></h3><p>배치 프로그램처럼 데이터 건 수가 많은 경우엔 비례해서 스칼라 서브쿼리의 수행횟수도 많아지기 때문에 성능이 나오기 어려움<br>스칼라 서브쿼리를 JOIN으로 변경하여 HASH JOIN으로 유도하는 게 가장 효율적이나 MySQL에는 8.0.18 버전 부터 HASH JOIN을 지원하기 때문에 NL 조인으로 풀리도록 유도함<br><a href=https://sarc.io/index.php/mariadb/1768-mysql-8-0-18-hash-join>https://sarc.io/index.php/mariadb/1768-mysql-8-0-18-hash-join</a></p><h4 id=변경-전>변경 전<a hidden class=anchor aria-hidden=true href=#변경-전>#</a></h4><pre><code>SELECT c1,c2,c3, (SELECT t2.c3 FROM tb_test2 t2 WHERE t2.c1=t1.c1 ) as t2_c3
FROM tb_test t1
order by c1,c2
</code></pre><h4 id=변경-후>변경 후<a hidden class=anchor aria-hidden=true href=#변경-후>#</a></h4><pre><code>SELECT c1,c2,c3,t2.c3
FROM tb_test t1 LEFT OUTER JOIN tb_test2 t2 on t1.c1=t2.c1
order by c1,c2
</code></pre><h4 id=변경-전-1>변경 전<a hidden class=anchor aria-hidden=true href=#변경-전-1>#</a></h4><pre><code>SELECT t1.EMPNO,
       t1.DEPT_NO
FROM   (SELECT E.EMPNO,
               (SELECT D.DEPTNO
                FROM   DEPT D
                WHERE  D.DEPTNO = E.DEPTNO) DEPT_NO
        FROM   EMP E) t1
WHERE  t1.DEPT_NO = 10 ;
</code></pre><p>=> view 안에 스칼라 서브쿼리 컬럼이 있고 이 컬럼을 밖에서 where 조건으로 사용하는 경우, 해당 컬럼에 인덱스가 있어도 인덱스를 탈 수 없음<br>t1.DEPT_NO 는 서브쿼리의 결과를 의미하기 때문에 가공된 컬럼처럼 동작함</p><h4 id=변경-후-1>변경 후<a hidden class=anchor aria-hidden=true href=#변경-후-1>#</a></h4><pre><code>SELECT t1.EMPNO,
       t1.DEPT_NO
FROM   (SELECT E.EMPNO,
               D.DEPTNO DEPT_NO
        FROM   EMP  E LEFT OUTER JOIN DEPT D ON D.DEPTNO = E.DEPTNO
        ) t1
WHERE  DEPT_NO = 10 ;
</code></pre><p>=> view 안의 서브쿼리를 OUTER JOIN으로 풀었고 필요 시 view 밖의 DEPT_NO=10 조건을 view 안으로 밀어넣어 인덱스를 타도록 유도 가능</p><h3 id=단-mysql은-oracle과-달리-complex-view아래-조건이-포함된-view-에-대해서는-위와-같은-view-merging을-지원하지-않음>단 MySQL은 ORACLE과 달리 complex view(아래 조건이 포함된 view) 에 대해서는 위와 같은 view merging을 지원하지 않음<a hidden class=anchor aria-hidden=true href=#단-mysql은-oracle과-달리-complex-view아래-조건이-포함된-view-에-대해서는-위와-같은-view-merging을-지원하지-않음>#</a></h3><ul><li>UNION</li><li>GROUP BY</li><li>DISTINCT</li><li>Aggregation</li><li>LIMIT</li><li>사용자 생성 변수</li><li>ORACLE에서는 GROUP BY, DISTINCT 을 포함해도 비용 비교 후 view merging을 할 수 있음<br>=> OUTER JOIN 으로 푼 것 보다 스칼라 서브쿼리가 더 빠를 수 있음</li></ul><h4 id=변경-전-2>변경 전<a hidden class=anchor aria-hidden=true href=#변경-전-2>#</a></h4><pre><code>mysql&gt; explain
    -&gt; SELECT (SELECT SUM(E_1.EMPNO) SUM_EMPNO FROM   EMP E_1 WHERE E_1.EMPNO = E.EMPNO) SUM_EMPNO_1,
    -&gt;        E.HIREDATE,
    -&gt;        E.DEPTNO
    -&gt; FROM   EMP E
    -&gt; WHERE      E.DEPTNO = 10;
+----+--------------------+-------+------------+--------+---------------+-----------+---------+--------------+------+----------+-------------+
| id | select_type        | table | partitions | type   | possible_keys | key       | key_len | ref          | rows | filtered | Extra       |
+----+--------------------+-------+------------+--------+---------------+-----------+---------+--------------+------+----------+-------------+
|  1 | PRIMARY            | E     | NULL       | ref    | FK_DEPTNO     | FK_DEPTNO | 2       | const        |    3 |   100.00 | NULL        |
|  2 | DEPENDENT SUBQUERY | E_1   | NULL       | eq_ref | PRIMARY       | PRIMARY   | 2       | test.E.EMPNO |    1 |   100.00 | Using index |
+----+--------------------+-------+------------+--------+---------------+-----------+---------+--------------+------+----------+-------------+
</code></pre><h4 id=변경-후-2>변경 후<a hidden class=anchor aria-hidden=true href=#변경-후-2>#</a></h4><pre><code>mysql&gt; explain
    -&gt; SELECT T_1.SUM_EMPNO SUM_EMPNO_1,
    -&gt;        E.HIREDATE,
    -&gt;        E.DEPTNO
    -&gt; FROM   EMP E LEFT OUTER JOIN
    -&gt;         (SELECT E_1.EMPNO, SUM(E_1.EMPNO) SUM_EMPNO
    -&gt;         FROM   EMP E_1
    -&gt;         GROUP BY E_1.EMPNO) T_1 on E.EMPNO = T_1.EMPNO
    -&gt; WHERE      E.DEPTNO = 10;
+----+-------------+------------+------------+-------+-------------------+-------------+---------+--------------+------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys     | key         | key_len | ref          | rows | filtered | Extra       |
+----+-------------+------------+------------+-------+-------------------+-------------+---------+--------------+------+----------+-------------+
|  1 | PRIMARY     | E          | NULL       | ref   | FK_DEPTNO         | FK_DEPTNO   | 2       | const        |    3 |   100.00 | NULL        |
|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ref   | &lt;auto_key0&gt;       | &lt;auto_key0&gt; | 2       | test.E.EMPNO |    2 |   100.00 | NULL        |
|  2 | DERIVED     | E_1        | NULL       | index | PRIMARY,FK_DEPTNO | PRIMARY     | 2       | NULL         |   14 |   100.00 | Using index |
+----+-------------+------------+------------+-------+-------------------+-------------+---------+--------------+------+----------+-------------+
</code></pre><p>=> 집계함수를 포함한 스칼라 서브쿼리를 LEFT JOIN 으로 변경하면서 inline view에 group by가 포함됨<br>group by 를 포함한 inline view는 view merging이 불가능하여 id=2 DERIVED 로 풀려 index 풀스캔을 하여 임시테이블을 생성한 뒤 조인하게 됨<br>근데 ORACLE처럼 view merging 실패하면 E.DEPTNO=10 조건이 자동으로 inline view 안으로 pushdown 될 줄 알았는데 이것도 안되네..?<br>OUTER JOIN하는 inline view 안에 group by 가 포함되어있으면 스칼라 조인으로 변환시키는 게 성능 상 이득일 수 있음</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/sql/>sql</a></li></ul><nav class=paginav><a class=prev href=/mysql/mysql_window_function/><span class=title>« Prev Page</span><br><span>MySQL5.7에서 window function 구현하기</span></a>
<a class=next href=/mysql/mysql8to57_collation/><span class=title>Next Page »</span><br><span>MySQL 8.0 to MySQL 5.7 replication 구성 시 collation issue</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>