<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PostgreSQL replication을 위한 WAL 전달과정 | kimDuBiA</title><meta name=keywords content="postgresql,replication,architecture"><meta name=description content="PostgreSQL replication을 위한 WAL 전달과정 ORACLE의 RAC 처럼 공유디스크를 사용하지 않는 이상 DBMS는 Master - Slave 구성을 위해 어떤 방식으로든 Master에서 수행한 트랜잭션을 Slave로 전파해야 합니다.
MySQL은 SQL 커맨드를 전파하는 방식으로 하는 반면, PostgreSQL은 트랜잭션 로그를 전달하는 방식으로 replication을 수행합니다.
이 두개의 방식은 비슷한듯, 아래와 같이 다르게 조금은 동작합니다.
 MySQL   PostgreSQL  왜 이런 차이가 발생하는 건지 이번 글에서는 PostgreSQL의 Streaming Replication 기준으로 복제 방식을 살펴보겠습니다.
MySQL의 replication 방식은 아래 글을 참고해주세요"><meta name=author content="kimdubi"><link rel=canonical href=/postgresql/pg_replication_wal/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><link rel=preload href=/apple-touch-icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="PostgreSQL replication을 위한 WAL 전달과정"><meta property="og:description" content="PostgreSQL replication을 위한 WAL 전달과정 ORACLE의 RAC 처럼 공유디스크를 사용하지 않는 이상 DBMS는 Master - Slave 구성을 위해 어떤 방식으로든 Master에서 수행한 트랜잭션을 Slave로 전파해야 합니다.
MySQL은 SQL 커맨드를 전파하는 방식으로 하는 반면, PostgreSQL은 트랜잭션 로그를 전달하는 방식으로 replication을 수행합니다.
이 두개의 방식은 비슷한듯, 아래와 같이 다르게 조금은 동작합니다.
 MySQL   PostgreSQL  왜 이런 차이가 발생하는 건지 이번 글에서는 PostgreSQL의 Streaming Replication 기준으로 복제 방식을 살펴보겠습니다.
MySQL의 replication 방식은 아래 글을 참고해주세요"><meta property="og:type" content="article"><meta property="og:url" content="/postgresql/pg_replication_wal/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="postgresql"><meta property="article:published_time" content="2021-10-05T23:42:16+09:00"><meta property="article:modified_time" content="2021-10-05T23:42:16+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="PostgreSQL replication을 위한 WAL 전달과정"><meta name=twitter:description content="PostgreSQL replication을 위한 WAL 전달과정 ORACLE의 RAC 처럼 공유디스크를 사용하지 않는 이상 DBMS는 Master - Slave 구성을 위해 어떤 방식으로든 Master에서 수행한 트랜잭션을 Slave로 전파해야 합니다.
MySQL은 SQL 커맨드를 전파하는 방식으로 하는 반면, PostgreSQL은 트랜잭션 로그를 전달하는 방식으로 replication을 수행합니다.
이 두개의 방식은 비슷한듯, 아래와 같이 다르게 조금은 동작합니다.
 MySQL   PostgreSQL  왜 이런 차이가 발생하는 건지 이번 글에서는 PostgreSQL의 Streaming Replication 기준으로 복제 방식을 살펴보겠습니다.
MySQL의 replication 방식은 아래 글을 참고해주세요"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Postgresqls","item":"/postgresql/"},{"@type":"ListItem","position":3,"name":"PostgreSQL replication을 위한 WAL 전달과정","item":"/postgresql/pg_replication_wal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PostgreSQL replication을 위한 WAL 전달과정","name":"PostgreSQL replication을 위한 WAL 전달과정","description":"PostgreSQL replication을 위한 WAL 전달과정 ORACLE의 RAC 처럼 공유디스크를 사용하지 않는 이상 DBMS는 Master - Slave 구성을 위해 어떤 방식으로든 Master에서 수행한 트랜잭션을 Slave로 전파해야 합니다.\nMySQL은 SQL 커맨드를 전파하는 방식으로 하는 반면, PostgreSQL은 트랜잭션 로그를 전달하는 방식으로 replication을 수행합니다.\n이 두개의 방식은 비슷한듯, 아래와 같이 다르게 조금은 동작합니다.\n MySQL   PostgreSQL  왜 이런 차이가 발생하는 건지 이번 글에서는 PostgreSQL의 Streaming Replication 기준으로 복제 방식을 살펴보겠습니다.\nMySQL의 replication 방식은 아래 글을 참고해주세요","keywords":["postgresql","replication","architecture"],"articleBody":"PostgreSQL replication을 위한 WAL 전달과정 ORACLE의 RAC 처럼 공유디스크를 사용하지 않는 이상 DBMS는 Master - Slave 구성을 위해 어떤 방식으로든 Master에서 수행한 트랜잭션을 Slave로 전파해야 합니다.\nMySQL은 SQL 커맨드를 전파하는 방식으로 하는 반면, PostgreSQL은 트랜잭션 로그를 전달하는 방식으로 replication을 수행합니다.\n이 두개의 방식은 비슷한듯, 아래와 같이 다르게 조금은 동작합니다.\n MySQL   PostgreSQL  왜 이런 차이가 발생하는 건지 이번 글에서는 PostgreSQL의 Streaming Replication 기준으로 복제 방식을 살펴보겠습니다.\nMySQL의 replication 방식은 아래 글을 참고해주세요\nhttps://kimdubi.github.io/mysql/semisync/\nPostgreSQL WAL 전파 과정 위 그림은 Primary(local) 에서 standby (remote) 로 WAL을 전달하는 과정을 나타내는데 총 5가지 단계가 있습니다.\n WAL inserts : WAL record는 wal_buffer 에 먼저 생성 되고 wal_buffer 로의 WAL record 생성은 여러 백그라운드 프로세스에 의해 지속적으로 기록됩니다. WAL writes \u0026 WAL flush : transaction commit / rollback , wal_buffer 사용량 이나 walwriter process 에 의해 WAL logfile로 flush 됩니다.(default 200ms 마다) Remote Write : 위 세가지 상황에서 wal_sender 는 WAL record를 remote 의 wal_receiver에게 전달합니다. Remote flush : 전달받은 wal record 가 standby 의 디스크에 flush 됩니다. Remote apply : 위 wal record를 standby 서버에 적용하여 데이터를 반영합니다.  Streaming replication 테스트  primary 서버  ### auto commit off postgres=# \\set AUTOCOMMIT off postgres=# \\echo :AUTOCOMMIT off ### DML 전 lsn postgres=# select pg_current_wal_lsn(); pg_current_wal_lsn -------------------- 7/2D0219E0 (1 row) ### DML 수행 postgres=# \\timing on Timing is on. postgres=# INSERT INTO repl_test SELECT generate_series(1,10000000) AS id, md5((random()*10000000)::text) AS pad; INSERT 0 10000000 Time: 32596.670 ms (00:32.597) ### DML 후 lsn postgres=# select pg_current_wal_lsn(); pg_current_wal_lsn -------------------- 7/3CCA51E0 (1 row) ### walsender 확인 $ ps -ef | grep walsender postgres: walsender repl 22.222.22.22(34856) streaming 7/3CCA51E0 = commit을 안찍었음에도 replication에 필요한 WAL 을 이미 standby 로 넘기고 Standby에서 WAL 을 재생하고 있는 상태입니다.\ncommit 을 찍어야 Standby에서 replication data를 반영하는 MySQL과는 차이가 있습니다.\n standby  ### Primary 에서 insert 중에 실시간으로 WAL 받고 있음 $ ps -ef | grep wal postgres: walreceiver streaming 7/A0000000 $ ps -ef | grep wal postgres: walreceiver streaming 7/A4000000 $ ps -ef | grep wal postgres: walreceiver streaming 7/A7C00000 $ ps -ef | grep wal postgres: walreceiver streaming 7/AAC00000 ### Primary postgres=# commit; COMMIT Time: 0.113 ms ### Standby postgres=# select count(*) from repl_test; count ---------- 10000000 (1 row) = Primary 에서 insert 를 완료하는데 30초 가량 걸렸지만 commit 하자마자 Standby에서도 데이터가 모두 반영된것을 확인 할 수 있습니다.\n이렇듯 PostgreSQL은 MySQL 처럼 binlog로 SQL 커맨드를 전달하는 게 아니라 트랜잭션 로그인 WAL 을 전달하기 때문에 거의 실시간으로 replication에 필요한 데이터를 전달하고 반영할 수 있습니다.\n","wordCount":"397","inLanguage":"en","datePublished":"2021-10-05T23:42:16+09:00","dateModified":"2021-10-05T23:42:16+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/postgresql/pg_replication_wal/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/postgresql/>Postgresqls</a></div><h1 class=post-title>PostgreSQL replication을 위한 WAL 전달과정</h1><div class=post-meta>October 5, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#postgresql-replication%ec%9d%84-%ec%9c%84%ed%95%9c-wal-%ec%a0%84%eb%8b%ac%ea%b3%bc%ec%a0%95 aria-label="PostgreSQL replication을 위한 WAL 전달과정">PostgreSQL replication을 위한 WAL 전달과정</a></li><li><a href=#postgresql-wal-%ec%a0%84%ed%8c%8c-%ea%b3%bc%ec%a0%95 aria-label="PostgreSQL WAL 전파 과정">PostgreSQL WAL 전파 과정</a></li><li><a href=#streaming-replication-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="Streaming replication 테스트">Streaming replication 테스트</a></li></ul></div></details></div><div class=post-content><h2 id=postgresql-replication을-위한-wal-전달과정>PostgreSQL replication을 위한 WAL 전달과정<a hidden class=anchor aria-hidden=true href=#postgresql-replication을-위한-wal-전달과정>#</a></h2><p>ORACLE의 RAC 처럼 공유디스크를 사용하지 않는 이상 DBMS는 Master - Slave 구성을 위해 어떤 방식으로든 Master에서 수행한 트랜잭션을 Slave로 전파해야 합니다.<br>MySQL은 SQL 커맨드를 전파하는 방식으로 하는 반면, PostgreSQL은 트랜잭션 로그를 전달하는 방식으로 replication을 수행합니다.<br>이 두개의 방식은 비슷한듯, 아래와 같이 다르게 조금은 동작합니다.</p><ul><li>MySQL</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/mysql_repl.png alt></p><ul><li>PostgreSQL</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/postgre_repl.png alt></p><p>왜 이런 차이가 발생하는 건지 이번 글에서는 PostgreSQL의 Streaming Replication 기준으로 복제 방식을 살펴보겠습니다.<br>MySQL의 replication 방식은 아래 글을 참고해주세요<br><a href=https://kimdubi.github.io/mysql/semisync/>https://kimdubi.github.io/mysql/semisync/</a></p><h2 id=postgresql-wal-전파-과정>PostgreSQL WAL 전파 과정<a hidden class=anchor aria-hidden=true href=#postgresql-wal-전파-과정>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/psql/postgre_repl2.png alt></p><p>위 그림은 Primary(local) 에서 standby (remote) 로 WAL을 전달하는 과정을 나타내는데 총 5가지 단계가 있습니다.</p><ul><li>WAL inserts : WAL record는 wal_buffer 에 먼저 생성 되고 wal_buffer 로의 WAL record 생성은 여러 백그라운드 프로세스에 의해 지속적으로 기록됩니다.</li><li>WAL writes & WAL flush : transaction commit / rollback , wal_buffer 사용량 이나 walwriter process 에 의해 WAL logfile로 flush 됩니다.(default 200ms 마다)</li><li>Remote Write : 위 세가지 상황에서 wal_sender 는 WAL record를 remote 의 wal_receiver에게 전달합니다.</li><li>Remote flush : 전달받은 wal record 가 standby 의 디스크에 flush 됩니다.</li><li>Remote apply : 위 wal record를 standby 서버에 적용하여 데이터를 반영합니다.</li></ul><h2 id=streaming-replication-테스트>Streaming replication 테스트<a hidden class=anchor aria-hidden=true href=#streaming-replication-테스트>#</a></h2><ul><li>primary 서버</li></ul><pre><code>### auto commit off
postgres=# \set AUTOCOMMIT off
postgres=# \echo :AUTOCOMMIT
off

### DML 전 lsn 
postgres=# select pg_current_wal_lsn();
 pg_current_wal_lsn
--------------------
 7/2D0219E0
(1 row)


### DML 수행
postgres=# \timing on
Timing is on.
postgres=# INSERT INTO repl_test SELECT generate_series(1,10000000) AS id, md5((random()*10000000)::text) AS pad;
INSERT 0 10000000
Time: 32596.670 ms (00:32.597)


### DML 후 lsn
postgres=# select pg_current_wal_lsn();
 pg_current_wal_lsn
--------------------
 7/3CCA51E0
(1 row)


### walsender 확인
$ ps -ef | grep walsender
postgres: walsender repl 22.222.22.22(34856) streaming 7/3CCA51E0
</code></pre><p>=> commit을 안찍었음에도 replication에 필요한 WAL 을 이미 standby 로 넘기고 Standby에서 WAL 을 재생하고 있는 상태입니다.<br>commit 을 찍어야 Standby에서 replication data를 반영하는 MySQL과는 차이가 있습니다.</p><ul><li>standby</li></ul><pre><code>### Primary 에서 insert 중에 실시간으로 WAL 받고 있음 
$ ps -ef | grep wal
postgres: walreceiver   streaming 7/A0000000

$ ps -ef | grep wal
postgres: walreceiver   streaming 7/A4000000

$ ps -ef | grep wal
postgres: walreceiver   streaming 7/A7C00000

$ ps -ef | grep wal
postgres: walreceiver   streaming 7/AAC00000

### Primary 

postgres=# commit;
COMMIT
Time: 0.113 ms

### Standby
postgres=# select count(*) from repl_test;
  count
----------
 10000000
(1 row)
</code></pre><p>=> Primary 에서 insert 를 완료하는데 30초 가량 걸렸지만 commit 하자마자 Standby에서도 데이터가 모두 반영된것을 확인 할 수 있습니다.<br>이렇듯 PostgreSQL은 MySQL 처럼 binlog로 SQL 커맨드를 전달하는 게 아니라 트랜잭션 로그인 WAL 을 전달하기 때문에 거의 실시간으로 replication에 필요한 데이터를 전달하고 반영할 수 있습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/postgresql/>postgresql</a></li><li><a href=/tags/replication/>replication</a></li><li><a href=/tags/architecture/>architecture</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>