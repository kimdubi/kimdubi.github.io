<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL row_format dynamic,compact에 대해서 | kimDuBiA</title><meta name=keywords content="MySQL,ddl,debugging"><meta name=description content="테스트 배경 특정 RDS에서 아래 쿼리가 생각보다 너무 느려서 살펴보던 중 row_format = COMPACT(MySQL 5.6 default) 인 것을 확인하였습니다 (MySQL 5.7 default DYNAMIC)
row_format은 데이터를 저장할 때 페이지를 어떻게 사용하느냐, 물리적으로 어떻게 저장할 것이냐 에 대한 설정이기 때문에 성능에 큰 영향을 줄 수 있는 파라미터로,
이 RDS는 row_format = COMPACT를 사용하고 있기 때문에 쿼리가 불필요하게 느린 것이라고 판단하여 (아래 그림 참고) 그렇다면 각각 row_format이 COMPACT / DYNAMIC일 때 실제로 어떻게 저장되고 어떻게 차이가 나는지 확인해보기로 했습니다."><meta name=author content="kimdubi"><link rel=canonical href=/mysql/row_format/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL row_format dynamic,compact에 대해서"><meta property="og:description" content="테스트 배경 특정 RDS에서 아래 쿼리가 생각보다 너무 느려서 살펴보던 중 row_format = COMPACT(MySQL 5.6 default) 인 것을 확인하였습니다 (MySQL 5.7 default DYNAMIC)
row_format은 데이터를 저장할 때 페이지를 어떻게 사용하느냐, 물리적으로 어떻게 저장할 것이냐 에 대한 설정이기 때문에 성능에 큰 영향을 줄 수 있는 파라미터로,
이 RDS는 row_format = COMPACT를 사용하고 있기 때문에 쿼리가 불필요하게 느린 것이라고 판단하여 (아래 그림 참고) 그렇다면 각각 row_format이 COMPACT / DYNAMIC일 때 실제로 어떻게 저장되고 어떻게 차이가 나는지 확인해보기로 했습니다."><meta property="og:type" content="article"><meta property="og:url" content="/mysql/row_format/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2024-07-29T16:53:15+09:00"><meta property="article:modified_time" content="2024-07-29T16:53:15+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL row_format dynamic,compact에 대해서"><meta name=twitter:description content="테스트 배경 특정 RDS에서 아래 쿼리가 생각보다 너무 느려서 살펴보던 중 row_format = COMPACT(MySQL 5.6 default) 인 것을 확인하였습니다 (MySQL 5.7 default DYNAMIC)
row_format은 데이터를 저장할 때 페이지를 어떻게 사용하느냐, 물리적으로 어떻게 저장할 것이냐 에 대한 설정이기 때문에 성능에 큰 영향을 줄 수 있는 파라미터로,
이 RDS는 row_format = COMPACT를 사용하고 있기 때문에 쿼리가 불필요하게 느린 것이라고 판단하여 (아래 그림 참고) 그렇다면 각각 row_format이 COMPACT / DYNAMIC일 때 실제로 어떻게 저장되고 어떻게 차이가 나는지 확인해보기로 했습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL row_format dynamic,compact에 대해서","item":"/mysql/row_format/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL row_format dynamic,compact에 대해서","name":"MySQL row_format dynamic,compact에 대해서","description":"테스트 배경 특정 RDS에서 아래 쿼리가 생각보다 너무 느려서 살펴보던 중 row_format = COMPACT(MySQL 5.6 default) 인 것을 확인하였습니다 (MySQL 5.7 default DYNAMIC)\nrow_format은 데이터를 저장할 때 페이지를 어떻게 사용하느냐, 물리적으로 어떻게 저장할 것이냐 에 대한 설정이기 때문에 성능에 큰 영향을 줄 수 있는 파라미터로,\n이 RDS는 row_format = COMPACT를 사용하고 있기 때문에 쿼리가 불필요하게 느린 것이라고 판단하여 (아래 그림 참고) 그렇다면 각각 row_format이 COMPACT / DYNAMIC일 때 실제로 어떻게 저장되고 어떻게 차이가 나는지 확인해보기로 했습니다.","keywords":["MySQL","ddl","debugging"],"articleBody":"테스트 배경 특정 RDS에서 아래 쿼리가 생각보다 너무 느려서 살펴보던 중 row_format = COMPACT(MySQL 5.6 default) 인 것을 확인하였습니다 (MySQL 5.7 default DYNAMIC)\nrow_format은 데이터를 저장할 때 페이지를 어떻게 사용하느냐, 물리적으로 어떻게 저장할 것이냐 에 대한 설정이기 때문에 성능에 큰 영향을 줄 수 있는 파라미터로,\n이 RDS는 row_format = COMPACT를 사용하고 있기 때문에 쿼리가 불필요하게 느린 것이라고 판단하여 (아래 그림 참고) 그렇다면 각각 row_format이 COMPACT / DYNAMIC일 때 실제로 어떻게 저장되고 어떻게 차이가 나는지 확인해보기로 했습니다.\ncompact 동작방식   text ,lob, varchar 큰 데이터가 들어오면 prefix 768 bytes만 같은 레코드에 저장하고 나머지는 off-page에 저장하게 됨 같은 page에 큰 데이터의 prefix를 768bytes나 할당하기 때문에 그만큼 1개 data page에 많은 레코드를 담을 수 없게 되어 필요한 data page를 많이 요구하게됨 이는 곧 I/O 증가로 이어짐 == 이런 점 때문에 compact를 사용하는 billing의 쿼리 성능이 느린 것으로 추측  dynamic 동작방식  compact와 달리 큰 값에 대해 20bytes의 포인터만 저장하고, 데이터는 off page에 저장하기 때문에 훨씬 효율적으로 큰 데이터를 저장할 수 있음  문제의 쿼리 select test1.pkey as pkey1_3_0_, . . . . test2.test2_seq as pay_deta2_5_0__ from test1 test1 left outer join test2 test2 on test1.pkey = test2.pkey and test1.pay_seq = test2.pay_seq where test1.pkey in (0, 20230902, 20230903) and test2.pkey in (0, 20230902, 20230903) and test1.register_datetime = '2023-09-03 21:00:00' and test1.register_datetime show table status like 'test2'; +------------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+--------------------------------+---------+ | Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment | +------------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+--------------------------------+---------+ | test2 | InnoDB | 10 | Compact | 406171337 | 812 | 330033004544 | 0 | 99371188224 | 342884352 | NULL | NULL | NULL | NULL | utf8_general_ci | NULL | |partitioned | | +------------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+--------------------------------+---------+ mysql show table status like 'test1'; +------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+ | Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment | +------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+ | test1 | InnoDB | 10 | Compact | 308351258 | 390 | 120404197376 | 0 | 110880571392 | 535822336 | NULL | NULL | NULL | NULL | utf8_general_ci | NULL | partitioned | | +------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+ = row_Format이 compact 인 것을 제외하면 플랜이나 그 외의 것들은 특이사항이 없음\n테스트 결과  단순히 text , varchar big size 데이터가 들어온다고 모두 위 compact / dynamic 그림처럼 off-page 방식으로 동작하는 것이 아니었다 특히 compact 타입일 땐 768bytes보다 크면 무조건 off-page 방식, dynamic일 땐 40bytes 이상이면 off-page 방식인 줄 알았으나 innodb page 16KB 기준, 8KB이상의 레코드가 저장될 때에나 위처럼 동작하게 된다 문제의 RDS의 경우 varchar(4000) 등 크게 할당된 varchar컬럼이 있었고 실제 데이터도 1KB이상이었으나, 하나의 레코드가 8KB 이상 되는 것은 없었기 때문에 off-page 저장되는 것이 없었고 이로 인해 COMPACT, DYNAMIC 차이가 없었음 문제의 RDS에선 원인이 아니었으나, 큰 데이터를 저장할 때 COMPACT, DYNAMIC 은 data page 개수 등에서 분명히 차이가 있으므로 무조건 DYNAMIC을 사용하자  테스트 문제의 RDS의 데이터 중 test2 테이블을 덤프받아 native mysql에 각각 row_format compact / dynamic으로 저장한 뒤\ninnodb_ruby 를 활용하여 각 row_format별로 데이터 페이지의 개수 차이를 확인해보았으나 차이가 없었음\n-rw-r----- 1 root root 17016291328 Sep 18 07:31 test2_compact#p#forever.ibd -rw-r----- 1 root root 5490343936 Sep 18 07:49 test2_compact#p#20230903.ibd -rw-r----- 1 root root 17016291328 Sep 18 09:34 test2_dynamic#p#forever.ibd -rw-r----- 1 root root 5490343936 Sep 18 09:52 test2_dynamic#p#20230903.ibd -rw-r--r-- 1 root root 17758233 Sep 18 11:21 compact_index.txt -rw-r--r-- 1 root root 17758233 Sep 18 11:28 dynamic_index.txt -rw-r--r-- 1 root root 455 Sep 18 11:50 compact_page.txt -rw-r--r-- 1 root root 455 Sep 18 11:51 dynamic_page.txt -rw-r--r-- 1 root root 27645 Sep 18 12:21 compact_region.txt -rw-r--r-- 1 root root 27645 Sep 18 12:21 dynamic_region.txt -rw-r--r-- 1 root root 1053 Sep 18 12:50 compact_space.txt -rw-r--r-- 1 root root 1053 Sep 18 12:50 dynamic_space.txt [root@831d3e1a52ea pg]# cat compact_page.txt type count percent description INDEX 316616 94.48 B+Tree index ALLOCATED 18444 5.50 Freshly allocated IBUF_BITMAP 21 0.01 Insert buffer bitmap XDES 20 0.01 Extent descriptor FSP_HDR 1 0.00 File space header INODE 1 0.00 File segment inode [root@831d3e1a52ea pg]# cat dynamic_page.txt type count percent description INDEX 316616 94.48 B+Tree index ALLOCATED 18444 5.50 Freshly allocated IBUF_BITMAP 21 0.01 Insert buffer bitmap XDES 20 0.01 Extent descriptor FSP_HDR 1 0.00 File space header INODE 1 0.00 File segment inode [root@831d3e1a52ea pg]# cat compact_space.txt id name root fseg fseg_id used allocated fill_factor 38544 4 internal 3 706 800 88.25% 38544 4 leaf 4 216696 216736 99.98% 38545 5 internal 5 263 352 74.72% 38545 5 leaf 6 39502 45152 87.49% 38546 6 internal 7 245 286 85.66% 38546 6 leaf 8 31592 36128 87.44% 38547 7 internal 9 129 156 82.69% 38547 7 leaf 10 27516 31456 87.47% [root@831d3e1a52ea pg]# cat dynamic_space.txt id name root fseg fseg_id used allocated fill_factor 36544 4 internal 3 706 800 88.25% 36544 4 leaf 4 216696 216736 99.98% 36545 5 internal 5 263 352 74.72% 36545 5 leaf 6 39502 45152 87.49% 36546 6 internal 7 245 286 85.66% 36546 6 leaf 8 31592 36128 87.44% 36547 7 internal 9 129 156 82.69% 36547 7 leaf 10 27516 31456 87.47% = compact, dynamic 의 데이터 사이즈도 동일했고 page 개수, fill_factor 등등 모든 저장된 형태가 동일함\n앞서 살펴본 그림과 매뉴얼의 내용대로라면\n COMPACT는 768만큼의 prefix 저장 후 off-page, DYNAMIC은 애초에 data page엔 20bytes만큼의 포인터만 저장 후 나머지는 모두 off-page에 저장하기 때문에\ndata page의 개수에 차이가 있어야하고, 저장되는 방식도 달라야하거늘 왜 동일한 것일까 ?  위 현상을 한참 찾아보다 MySQL 매뉴얼에서 아래의 충격적인 내용을 확인하였다… 이 내용이 왜 row_format 쪽 매뉴얼엔 없는 것인가,,,,\nFor for 4KB, 8KB, 16KB, and 32KB innodb_page_size settings, the maximum row length is slightly less than half a database page size. For example, the maximum row length is slightly less than 8KB for the default 16KB InnoDB page size. For a 64KB innodb_page_size setting, the maximum row length is slightly less than 16KB. If a row does not exceed the maximum row length, all of it is stored locally within the page. If a row exceeds the maximum row length, variable-length columns are chosen for external off-page storage until the row fits within the maximum row length limit. External off-page storage for variable-length columns differs by row format: 즉, row_format 에 따른 off-page 저장 방식의 차이는 Innodb page 16KB 기준 한 레코드가 8KB보다 클 때 발생한다는 것,,\n그리고 문제의 테이블은 비록 compact format을 사용하지만 레코드 하나의 크기가 끽해야 최대 2KB미만이어서 위에서 확인해봤을 때 차이가 없었던 것이다\nmysql select max(length(approve_option_body)) from test2 where pkey in (0, 20230902, 20230903); +----------------------------------+ | max(length(approve_option_body)) | +----------------------------------+ | 1232 | +----------------------------------+ 1 row in set (2 min 40.98 sec) mysql select max(length(cancel_option_body)) from test2 where pkey in (0, 20230902, 20230903); +---------------------------------+ | max(length(cancel_option_body)) | +---------------------------------+ | 306 | +---------------------------------+ 1 row in set (21.51 sec) 그래서 레코드 8KB가 넘냐 안넘냐를 기준으로 테스트를 다시 진행해보았다\n두번째 테스트 데이터 준비 ### 레코드가 8KB보다 작을 때 mysql use test; Database changed mysql create table tb_compact - ( - a int auto_increment primary key, - b varchar(10000) - ) charset=latin1 row_format=compact; Query OK, 0 rows affected (0.04 sec) mysql create table tb_dynamic - ( - a int auto_increment primary key, - b varchar(10000) - ) charset=latin1 row_format=dynamic; Query OK, 0 rows affected (0.01 sec) mysql insert into tb_compact(b) values(REPEAT('a', 1000)); Query OK, 1 row affected (0.04 sec) mysql mysql insert into tb_dynamic(b) values(REPEAT('a', 1000)); Query OK, 1 row affected (0.04 sec) ### 레코드가 8KB보다 클 때 mysql use test; Database changed mysql create table tb_compact - ( - a int auto_increment primary key, - b varchar(10000) - ) charset=latin1 row_format=compact; Query OK, 0 rows affected (0.04 sec) mysql create table tb_dynamic - ( - a int auto_increment primary key, - b varchar(10000) - ) charset=latin1 row_format=dynamic; Query OK, 0 rows affected (0.01 sec) mysql insert into tb_compact(b) values(REPEAT('a', 10000)); Query OK, 1 row affected (0.04 sec) mysql mysql insert into tb_dynamic(b) values(REPEAT('a', 10000)); Query OK, 1 row affected (0.04 sec) 레코드가 8KB보다 작을 때 compact  [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact space-index-pages-summary page index level data free records 3 41 0 1025 15227 1 5 0 0 0 16384 0 [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact -p 3 page-dump #: fil header: #fil trailer: #page header: #fseg header: #, fseg=2, internal= , fseg=1 sizes: header 120 trailer 8 directory 4 free 15227 used 1157 record 1025 per record 1025.00 page directory: [99, 112] system records: #, next=128, data=\"infimum\\x00\", length=8 #, next=112, data=\"supremum\", length=8 garbage records: records: #1000}, externs=[], next=112, key= [#], row= [#], sys= [#, #, extern=nil], child_page_number=nil, transaction_id=1301, roll_pointer= #, length=1017 = 레코드 크기가 1KB로, 8KB보다 작을 땐 off-page가 생기지 않음 (아래 extern=nil 확인 )\n대신 varchar(1000) 만큼을 모두 하나의 data page에 저장하는 모습임\nkey= [#], row= [#], dynamic [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic space-index-pages-summary page index level data free records 3 42 0 1025 15227 1 5 0 0 0 16384 0 [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic -p 3 page-dump #: fil header: #fil trailer: #page header: #fseg header: #, fseg=2, internal= , fseg=1 sizes: header 120 trailer 8 directory 4 free 15227 used 1157 record 1025 per record 1025.00 page directory: [99, 112] system records: #, next=128, data=\"infimum\\x00\", length=8 #, next=112, data=\"supremum\", length=8 garbage records: records: #1000}, externs=[], next=112, key= [#], row= [#], sys= [#, #, extern=nil], child_page_number=nil, transaction_id=1309, roll_pointer= #, length=1017 = 레코드가 1KB일 땐, COMPACT와 전혀 다르지 않다. 동일하게 하나의 data page에 모두 저장되는 모습\n레코드가 8KB보다 클 때 compact [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact space-index-pages-summary page index level data free records 3 41 0 813 15439 1 5 0 0 0 16384 0 = 3번 page에 813 bytes의 레코드가 하나 있는 것으로 보임. 앞서 레코드 사이즈가 1KB일 땐 하나의 data page에 모두 저장되었는데 이번엔 813 bytes만 저장되었다 나머지 9200 bytes는 어디로 간것일까.. [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact -p 3 page-dump #: fil header: #fil trailer: #page header: #fseg header: #, fseg=2, internal= , fseg=1 sizes: header 120 trailer 8 directory 4 free 15439 used 945 record 813 per record 813.00 page directory: [99, 112] system records: #, next=128, data=\"infimum\\x00\", length=8 #, next=112, data=\"supremum\", length=8 garbage records: records: #788}, externs=[\"b\"], next=112, key= [#], row= [#], sys= [#, #, extern=nil], child_page_number=nil, transaction_id=1290, roll_pointer= #, length=805 = 3번 페이지를 page-dump로 확인해보니 드디어 b컬럼에 대해 externs=[“b”] off-page가 발생한 것을 확인할 수 있음\n header= #788}, externs=[\"b\"], = length={“b”=788} 을 확인한다. 맨위에서 compact 동작방식의 768 bytes와는 수치가 살짝 다르지만 비슷한 로직을 드디어 확인했다\n extern= #], = 이 레코드의 off-page는 4번 페이지에 저장되었으며, 그 크기는 9232bytes라 한다\n[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact -p 4 page-dump #: fil header: #fil trailer: #blob header: {:length=9232, :next=nil} blob data: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 00000016 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 00000032 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 00000048 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| . . . 00009216 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| = 4번 page를 확인해보면, type=:BLOB 으로 저장되어있음을 확인할 수 있고 9200 bytes만큼의 blob data를 쭉 확인할 수 있다!!\ndynamic [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic space-index-pages-summary page index level data free records 3 42 0 45 16207 1 5 0 0 0 16384 0 = 3번 page에 45bytes의 레코드 하나가 저장된 것으로 보임. 10,000 bytes의 문자열을 넣었는데 45bytes밖에 안됨. 벌써 COMPACT와 다르다\n[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic -p 3 page-dump #: fil header: #fil trailer: #page header: #fseg header: #, fseg=2, internal= , fseg=1 sizes: header 120 trailer 8 directory 4 free 16207 used 177 record 45 per record 45.00 page directory: [99, 112] system records: #, next=128, data=\"infimum\\x00\", length=8 #, next=112, data=\"supremum\", length=8 garbage records: records: #20}, externs=[\"b\"], next=112, key= [#], row= [#], sys= [#, #, extern=nil], child_page_number=nil, transaction_id=1292, roll_pointer= #, length=37  header= #20}, externs=[\"b\"], = lengths={“b”=20} , 맨위에서 본 dynamic의 동작방식과 동일하게 20bytes를 체크한다 !\n마찬가지로 3번 page를 자세히 확인해보자\n row= [#], = 역시 b컬럼에 대해 extern, off-page가 발생하였고 4번 페이지에 저장되었다.\nCOMPACT와 달리 768bytes 만큼의 prefix 조차도 저장하지 않아서 10,000 bytes 그대로 off-page에 저장되는 모습이다\n[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic -p 4 page-dump #: fil header: #fil trailer: #blob header: {:length=10000, :next=nil} blob data: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 00000016 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 00000032 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 00000048 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| . . . 00009984 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| = 4번 page를 자세히 확인해보자\n마찬가지로 type=:BLOB 으로 저장되었고 10,000 bytes만큼의 blob-data 를 확인할 수 있다!!\n데이터 건 수에 따른 COMPACT DYNAMIC data-page 차이 mysql select count(*),avg(length(b)) from tb_compact; +----------+----------------+ | count(*) | avg(length(b)) | +----------+----------------+ | 100 | 10000.0000 | +----------+----------------+ 1 row in set (0.02 sec) mysql select count(*),avg(length(b)) from tb_dynamic; +----------+----------------+ | count(*) | avg(length(b)) | +----------+----------------+ | 100 | 10000.0000 | +----------+----------------+ 1 row in set (0.01 sec) * compact [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact space-index-pages-summary page index level data free records 3 41 1 98 16154 7 [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact space-index-pages-summary | wc -l 538 * dynamic [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic space-index-pages-summary page index level data free records 3 42 0 4500 11704 100 [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic space-index-pages-summary | wc -l 218 mysql select count(*),avg(length(b)) from tb_compact; +----------+----------------+ | count(*) | avg(length(b)) | +----------+----------------+ | 12800 | 10000.0000 | +----------+----------------+ 1 row in set (0.42 sec) mysql select count(*),avg(length(b)) from tb_dynamic; +----------+----------------+ | count(*) | avg(length(b)) | +----------+----------------+ | 12800 | 10000.0000 | +----------+----------------+ 1 row in set (0.45 sec) ### compact [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact space-index-pages-summary | wc -l 3326 ### dynamic [root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic space-index-pages-summary | wc -l 510 = COMPACT : 데이터 100건일 때 벌써 index depth가 늘어나고, 12800건 일 땐 data page 개수가 3326개\ndynamic : 12800 건일 때에도 data page 개수는 510개 밖에 안됨.\ntext 등 큰 데이터를 저장할 때 compact / dynamic 의 차이는 데이터 건 수가 많아질 수록 점점 커질 것이기 때문에 반드시 dynamic을 사용하자\n","wordCount":"3091","inLanguage":"en","datePublished":"2024-07-29T16:53:15+09:00","dateModified":"2024-07-29T16:53:15+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/row_format/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL row_format dynamic,compact에 대해서</h1><div class=post-meta>July 29, 2024&nbsp;·&nbsp;15 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%b0%b0%ea%b2%bd aria-label="테스트 배경">테스트 배경</a><ul><li><a href=#compact-%eb%8f%99%ec%9e%91%eb%b0%a9%ec%8b%9d aria-label="compact 동작방식 ">compact 동작방식 </a></li><li><a href=#dynamic-%eb%8f%99%ec%9e%91%eb%b0%a9%ec%8b%9d aria-label="dynamic 동작방식">dynamic 동작방식</a></li><li><a href=#%eb%ac%b8%ec%a0%9c%ec%9d%98-%ec%bf%bc%eb%a6%ac aria-label="문제의 쿼리">문제의 쿼리</a></li></ul></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ea%b2%b0%ea%b3%bc aria-label="테스트 결과">테스트 결과</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label=테스트>테스트</a><ul><li><a href=#%eb%91%90%eb%b2%88%ec%a7%b8-%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a4%80%eb%b9%84 aria-label="두번째 테스트 데이터 준비">두번째 테스트 데이터 준비</a></li><li><a href=#%eb%a0%88%ec%bd%94%eb%93%9c%ea%b0%80-8kb%eb%b3%b4%eb%8b%a4-%ec%9e%91%ec%9d%84-%eb%95%8c aria-label="레코드가 8KB보다 작을 때">레코드가 8KB보다 작을 때</a><ul><li><a href=#compact aria-label=compact>compact</a></li><li><a href=#dynamic aria-label=dynamic>dynamic</a></li></ul></li><li><a href=#%eb%a0%88%ec%bd%94%eb%93%9c%ea%b0%80-8kb%eb%b3%b4%eb%8b%a4-%ed%81%b4-%eb%95%8c aria-label="레코드가 8KB보다 클 때">레코드가 8KB보다 클 때</a><ul><li><a href=#compact-1 aria-label=compact>compact</a></li><li><a href=#dynamic-1 aria-label=dynamic>dynamic</a></li></ul></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b1%b4-%ec%88%98%ec%97%90-%eb%94%b0%eb%a5%b8-compact-dynamic-data-page-%ec%b0%a8%ec%9d%b4 aria-label="데이터 건 수에 따른 COMPACT DYNAMIC data-page 차이">데이터 건 수에 따른 COMPACT DYNAMIC data-page 차이</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=테스트-배경>테스트 배경<a hidden class=anchor aria-hidden=true href=#테스트-배경>#</a></h1><p>특정 RDS에서 아래 쿼리가 생각보다 너무 느려서 살펴보던 중 row_format = COMPACT(MySQL 5.6 default) 인 것을 확인하였습니다 (MySQL 5.7 default DYNAMIC)<br>row_format은 데이터를 저장할 때 페이지를 어떻게 사용하느냐, 물리적으로 어떻게 저장할 것이냐 에 대한 설정이기 때문에 성능에 큰 영향을 줄 수 있는 파라미터로,<br>이 RDS는 row_format = COMPACT를 사용하고 있기 때문에 쿼리가 불필요하게 느린 것이라고 판단하여 (아래 그림 참고)<br>그렇다면 각각 row_format이 COMPACT / DYNAMIC일 때 실제로 어떻게 저장되고 어떻게 차이가 나는지 확인해보기로 했습니다.</p><h2 id=compact-동작방식>compact 동작방식 <a hidden class=anchor aria-hidden=true href=#compact-동작방식>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/rowformat_1.png alt></p><ul><li>text ,lob, varchar 큰 데이터가 들어오면 prefix 768 bytes만 같은 레코드에 저장하고 나머지는 off-page에 저장하게 됨</li><li>같은 page에 큰 데이터의 prefix를 768bytes나 할당하기 때문에 그만큼 1개 data page에 많은 레코드를 담을 수 없게 되어 필요한 data page를 많이 요구하게됨</li><li>이는 곧 I/O 증가로 이어짐  ==> 이런 점 때문에 compact를 사용하는 billing의 쿼리 성능이 느린 것으로 추측</li></ul><h2 id=dynamic-동작방식>dynamic 동작방식<a hidden class=anchor aria-hidden=true href=#dynamic-동작방식>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/rowformat_2.png alt></p><ul><li>compact와 달리 큰 값에 대해 20bytes의 포인터만 저장하고, 데이터는 off page에 저장하기 때문에 훨씬 효율적으로 큰 데이터를 저장할 수 있음</li></ul><h2 id=문제의-쿼리>문제의 쿼리<a hidden class=anchor aria-hidden=true href=#문제의-쿼리>#</a></h2><pre><code>select
test1.pkey as pkey1_3_0_,
.
.
.
.
test2.test2_seq as pay_deta2_5_0__
from test1 test1
left outer join test2 test2 on test1.pkey = test2.pkey and test1.pay_seq = test2.pay_seq
where
test1.pkey in (0, 20230902, 20230903)
and test2.pkey in (0, 20230902, 20230903)
and test1.register_datetime &gt;= '2023-09-03 21:00:00'
and test1.register_datetime &lt; '2023-09-03 22:00:00'
order by test1.register_datetime asc;

+----+-------------+--------------+---------------------------+-------+-------------------------------+-----------------------------+---------+--------------------------------+--------+----------+-----------------------+
| id | select_type | table        | partitions                | type  | possible_keys                 | key                         | key_len | ref                            | rows   | filtered | Extra                 |
+----+-------------+--------------+---------------------------+-------+-------------------------------+-----------------------------+---------+--------------------------------+--------+----------+-----------------------+
|  1 | SIMPLE      | test1        | forever,20230902,20230903 | range | PRIMARY,IDX_REGISTER_DATETIME | IDX_REGISTER_DATETIME       | 6       | NULL                           | 457581 |    30.00 | Using index condition |
|  1 | SIMPLE      | test2        | forever,20230902,20230903 | ref   | IDX_test2_PAY_SEQ_PKEY   | IDX_test2_PAY_SEQ_PKEY | 114     | tt.test1.pay_seq,tt.test1.pkey |      1 |   100.00 | NULL                  |
+----+-------------+--------------+---------------------------+-------+-------------------------------+-----------------------------+---------+--------------------------------+--------+----------+-----------------------+
2 rows in set, 1 warning (0.06 sec)



mysql&gt; show table status like 'test2';
+------------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+--------------------------------+---------+
| Name       | Engine | Version | Row_format | Rows      | Avg_row_length | Data_length  | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation       | Checksum | Create_options                 | Comment |
+------------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+--------------------------------+---------+
| test2      | InnoDB |      10 | Compact    | 406171337 |            812 | 330033004544 |               0 |  99371188224 | 342884352 |           NULL | NULL        | NULL        | NULL       | utf8_general_ci |     NULL |  |partitioned    |         |
+------------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+--------------------------------+---------+


mysql&gt; show table status like 'test1';
+------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+
| Name | Engine | Version | Row_format | Rows      | Avg_row_length | Data_length  | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation       | Checksum | Create_options | Comment |
+------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+
| test1  | InnoDB |      10 | Compact    | 308351258 |            390 | 120404197376 |               0 | 110880571392 | 535822336 |           NULL | NULL        | NULL        | NULL       | utf8_general_ci |     NULL | partitioned    |         |
+------+--------+---------+------------+-----------+----------------+--------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+


</code></pre><p>=> row_Format이 compact 인 것을 제외하면 플랜이나 그 외의 것들은 특이사항이 없음</p><h1 id=테스트-결과>테스트 결과<a hidden class=anchor aria-hidden=true href=#테스트-결과>#</a></h1><ul><li>단순히 text , varchar big size 데이터가 들어온다고 모두 위 compact / dynamic 그림처럼 off-page 방식으로 동작하는 것이 아니었다</li><li>특히 compact 타입일 땐 768bytes보다 크면 무조건 off-page 방식, dynamic일 땐 40bytes 이상이면 off-page 방식인 줄 알았으나 
innodb page 16KB 기준, 8KB이상의 레코드가 저장될 때에나 위처럼 동작하게 된다</li><li>문제의 RDS의 경우 varchar(4000) 등 크게 할당된 varchar컬럼이 있었고 실제 데이터도 1KB이상이었으나, 하나의 레코드가 8KB 이상 되는 것은 없었기 때문에 off-page 저장되는 것이 없었고 이로 인해 COMPACT, DYNAMIC 차이가 없었음</li><li>문제의 RDS에선 원인이 아니었으나, 큰 데이터를 저장할 때 COMPACT, DYNAMIC 은 data page 개수 등에서 분명히 차이가 있으므로 무조건 DYNAMIC을 사용하자</li></ul><h1 id=테스트>테스트<a hidden class=anchor aria-hidden=true href=#테스트>#</a></h1><p>문제의 RDS의 데이터 중 test2 테이블을 덤프받아 native mysql에 각각 row_format compact / dynamic으로 저장한 뒤<br>innodb_ruby 를 활용하여 각 row_format별로 데이터 페이지의 개수 차이를 확인해보았으나 차이가 없었음</p><pre><code>-rw-r----- 1 root root 17016291328 Sep 18 07:31 test2_compact#p#forever.ibd
-rw-r----- 1 root root  5490343936 Sep 18 07:49 test2_compact#p#20230903.ibd

-rw-r----- 1 root root 17016291328 Sep 18 09:34 test2_dynamic#p#forever.ibd
-rw-r----- 1 root root  5490343936 Sep 18 09:52 test2_dynamic#p#20230903.ibd

-rw-r--r-- 1 root root    17758233 Sep 18 11:21 compact_index.txt
-rw-r--r-- 1 root root    17758233 Sep 18 11:28 dynamic_index.txt
-rw-r--r-- 1 root root         455 Sep 18 11:50 compact_page.txt
-rw-r--r-- 1 root root         455 Sep 18 11:51 dynamic_page.txt
-rw-r--r-- 1 root root       27645 Sep 18 12:21 compact_region.txt
-rw-r--r-- 1 root root       27645 Sep 18 12:21 dynamic_region.txt
-rw-r--r-- 1 root root        1053 Sep 18 12:50 compact_space.txt
-rw-r--r-- 1 root root        1053 Sep 18 12:50 dynamic_space.txt


[root@831d3e1a52ea pg]# cat compact_page.txt
type                count       percent     description
INDEX               316616      94.48       B+Tree index
ALLOCATED           18444       5.50        Freshly allocated
IBUF_BITMAP         21          0.01        Insert buffer bitmap
XDES                20          0.01        Extent descriptor
FSP_HDR             1           0.00        File space header
INODE               1           0.00        File segment inode

[root@831d3e1a52ea pg]# cat dynamic_page.txt
type                count       percent     description
INDEX               316616      94.48       B+Tree index
ALLOCATED           18444       5.50        Freshly allocated
IBUF_BITMAP         21          0.01        Insert buffer bitmap
XDES                20          0.01        Extent descriptor
FSP_HDR             1           0.00        File space header
INODE               1           0.00        File segment inode

[root@831d3e1a52ea pg]# cat compact_space.txt
id          name                            root        fseg        fseg_id     used        allocated   fill_factor
38544                                       4           internal    3           706         800         88.25%
38544                                       4           leaf        4           216696      216736      99.98%
38545                                       5           internal    5           263         352         74.72%
38545                                       5           leaf        6           39502       45152       87.49%
38546                                       6           internal    7           245         286         85.66%
38546                                       6           leaf        8           31592       36128       87.44%
38547                                       7           internal    9           129         156         82.69%
38547                                       7           leaf        10          27516       31456       87.47%
[root@831d3e1a52ea pg]# cat dynamic_space.txt
id          name                            root        fseg        fseg_id     used        allocated   fill_factor
36544                                       4           internal    3           706         800         88.25%
36544                                       4           leaf        4           216696      216736      99.98%
36545                                       5           internal    5           263         352         74.72%
36545                                       5           leaf        6           39502       45152       87.49%
36546                                       6           internal    7           245         286         85.66%
36546                                       6           leaf        8           31592       36128       87.44%
36547                                       7           internal    9           129         156         82.69%
36547                                       7           leaf        10          27516       31456       87.47%
</code></pre><p>=> compact, dynamic 의 데이터 사이즈도 동일했고 page 개수,  fill_factor 등등 모든 저장된 형태가 동일함</p><p>앞서 살펴본 그림과 매뉴얼의 내용대로라면</p><ul><li>COMPACT는 768만큼의 prefix 저장 후 off-page,</li><li>DYNAMIC은 애초에 data page엔 20bytes만큼의 포인터만 저장 후 나머지는 모두 off-page에 저장하기 때문에<br>data page의 개수에 차이가 있어야하고, 저장되는 방식도 달라야하거늘 왜 동일한 것일까 ?</li></ul><p>위 현상을 한참 찾아보다 MySQL 매뉴얼에서 아래의 충격적인 내용을 확인하였다&mldr;  이 내용이 왜 row_format 쪽 매뉴얼엔 없는 것인가,,,,</p><pre><code>For for 4KB, 8KB, 16KB, and 32KB innodb_page_size settings, the maximum row length is slightly less than half a database page size. 
For example, the maximum row length is slightly less than 8KB for the default 16KB InnoDB page size. 
For a 64KB innodb_page_size setting, the maximum row length is slightly less than 16KB.

If a row does not exceed the maximum row length, all of it is stored locally within the page. 
If a row exceeds the maximum row length, variable-length columns are chosen for external off-page storage until the row fits within the maximum row length limit. 
External off-page storage for variable-length columns differs by row format:
</code></pre><p>즉, row_format 에 따른 off-page 저장 방식의 차이는 Innodb page 16KB 기준 한 레코드가 8KB보다 클 때 발생한다는 것,,<br>그리고 문제의 테이블은 비록 compact format을 사용하지만 레코드 하나의 크기가 끽해야 최대 2KB미만이어서 위에서 확인해봤을 때 차이가 없었던 것이다</p><pre><code>mysql&gt; select max(length(approve_option_body)) from test2 where pkey in (0, 20230902, 20230903);
+----------------------------------+
| max(length(approve_option_body)) |
+----------------------------------+
|                             1232 |
+----------------------------------+
1 row in set (2 min 40.98 sec)

mysql&gt; select max(length(cancel_option_body)) from test2 where pkey in (0, 20230902, 20230903);
+---------------------------------+
| max(length(cancel_option_body)) |
+---------------------------------+
|                             306 |
+---------------------------------+
1 row in set (21.51 sec)
</code></pre><p>그래서 레코드 8KB가 넘냐 안넘냐를 기준으로 테스트를 다시 진행해보았다</p><h2 id=두번째-테스트-데이터-준비>두번째 테스트 데이터 준비<a hidden class=anchor aria-hidden=true href=#두번째-테스트-데이터-준비>#</a></h2><pre><code>### 레코드가 8KB보다 작을 때 
mysql&gt; use test;
Database changed
mysql&gt; create table tb_compact
    -&gt; (
    -&gt;     a int auto_increment primary key,
    -&gt;     b varchar(10000)
    -&gt; ) charset=latin1 row_format=compact;
Query OK, 0 rows affected (0.04 sec)

mysql&gt; create table tb_dynamic
    -&gt; (
    -&gt;     a int auto_increment primary key,
    -&gt;     b varchar(10000)
    -&gt; ) charset=latin1 row_format=dynamic;
Query OK, 0 rows affected (0.01 sec)


mysql&gt; insert into tb_compact(b) values(REPEAT('a', 1000));
Query OK, 1 row affected (0.04 sec)

mysql&gt;
mysql&gt; insert into tb_dynamic(b) values(REPEAT('a', 1000));
Query OK, 1 row affected (0.04 sec)


### 레코드가 8KB보다 클 때 

mysql&gt; use test;
Database changed
mysql&gt; create table tb_compact
    -&gt; (
    -&gt;     a int auto_increment primary key,
    -&gt;     b varchar(10000)
    -&gt; ) charset=latin1 row_format=compact;
Query OK, 0 rows affected (0.04 sec)

mysql&gt; create table tb_dynamic
    -&gt; (
    -&gt;     a int auto_increment primary key,
    -&gt;     b varchar(10000)
    -&gt; ) charset=latin1 row_format=dynamic;
Query OK, 0 rows affected (0.01 sec)


mysql&gt; insert into tb_compact(b) values(REPEAT('a', 10000));
Query OK, 1 row affected (0.04 sec)

mysql&gt;
mysql&gt; insert into tb_dynamic(b) values(REPEAT('a', 10000));
Query OK, 1 row affected (0.04 sec)
</code></pre><h2 id=레코드가-8kb보다-작을-때>레코드가 8KB보다 작을 때<a hidden class=anchor aria-hidden=true href=#레코드가-8kb보다-작을-때>#</a></h2><h3 id=compact>compact<a hidden class=anchor aria-hidden=true href=#compact>#</a></h3><pre><code>
[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact   space-index-pages-summary
page        index   level   data    free    records
3           41      0       1025    15227   1
5           0       0       0       16384   0

[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact -p 3   page-dump
#&lt;Innodb::Page::Index:0x0000000000fafaf0&gt;:

fil header:
#&lt;struct Innodb::Page::FilHeader
 checksum=217622452,
 offset=3,
 prev=nil,
 next=nil,
 lsn=2562511,
 type=:INDEX,
 flush_lsn=0,
 space_id=23&gt;

fil trailer:
#&lt;struct Innodb::Page::FilTrailer checksum=217622452, lsn_low32=2562511&gt;

page header:
#&lt;struct Innodb::Page::Index::PageHeader
 n_dir_slots=2,
 heap_top=1145,
 n_heap_format=32771,
 n_heap=3,
 format=:compact,
 garbage_offset=0,
 garbage_size=0,
 last_insert_offset=128,
 direction=:no_direction,
 n_direction=0,
 n_recs=1,
 max_trx_id=0,
 level=0,
 index_id=41&gt;

fseg header:
#&lt;struct Innodb::Page::Index::FsegHeader
 leaf=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_compact.ibd&quot;, page_size=16384, pages=6&gt;, fseg=2&gt;,
 internal=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_compact.ibd&quot;, page_size=16384, pages=6&gt;, fseg=1&gt;&gt;

sizes:
  header           120
  trailer            8
  directory          4
  free           15227
  used            1157
  record          1025
  per record     1025.00

page directory:
[99, 112]

system records:
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=99,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=128,
   type=:infimum,
   heap_number=0,
   n_owned=1,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=128,
 data=&quot;infimum\x00&quot;,
 length=8&gt;
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=112,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=112,
   type=:supremum,
   heap_number=1,
   n_owned=2,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=112,
 data=&quot;supremum&quot;,
 length=8&gt;

garbage records:

records:
#&lt;struct Innodb::Page::Index::UserRecord
 type=:clustered,
 format=:compact,
 offset=128,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=8,
   next=112,
   type=:conventional,
   heap_number=2,
   n_owned=0,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=[],
   lengths={&quot;b&quot;=&gt;1000},
   externs=[]&gt;,
 next=112,
 key=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;a&quot;,
    type=&quot;INT&quot;,
    value=1,
    extern=nil&gt;],
 row=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;b&quot;,
    type=&quot;VARCHAR(10000)&quot;,
    value=
     &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,
    extern=nil&gt;],
 sys=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_TRX_ID&quot;,
    type=&quot;TRX_ID&quot;,
    value=1301,
    extern=nil&gt;,
   #&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_ROLL_PTR&quot;,
    type=&quot;ROLL_PTR&quot;,
    value=
     #&lt;struct Innodb::DataType::RollPointerType::Pointer
      is_insert=true,
      rseg_id=50,
      undo_log=#&lt;struct Innodb::Page::Address page=294, offset=272&gt;&gt;,
    extern=nil&gt;],
 child_page_number=nil,
 transaction_id=1301,
 roll_pointer=
  #&lt;struct Innodb::DataType::RollPointerType::Pointer
   is_insert=true,
   rseg_id=50,
   undo_log=#&lt;struct Innodb::Page::Address page=294, offset=272&gt;&gt;,
 length=1017&gt;

</code></pre><p>=> 레코드 크기가 1KB로, 8KB보다 작을 땐 off-page가 생기지 않음 (아래 extern=nil 확인 )<br>대신 varchar(1000) 만큼을 모두 하나의 data page에 저장하는 모습임</p><pre><code>key=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;a&quot;,
    type=&quot;INT&quot;,
    value=1,
    extern=nil&gt;],
 row=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;b&quot;,
    type=&quot;VARCHAR(10000)&quot;,
    value=
     &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,
    extern=nil&gt;],
</code></pre><h3 id=dynamic>dynamic<a hidden class=anchor aria-hidden=true href=#dynamic>#</a></h3><pre><code>[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   space-index-pages-summary
page        index   level   data    free    records
3           42      0       1025    15227   1
5           0       0       0       16384   0

[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   -p 3 page-dump
#&lt;Innodb::Page::Index:0x0000000000fafc80&gt;:

fil header:
#&lt;struct Innodb::Page::FilHeader
 checksum=2324395643,
 offset=3,
 prev=nil,
 next=nil,
 lsn=2571765,
 type=:INDEX,
 flush_lsn=0,
 space_id=24&gt;

fil trailer:
#&lt;struct Innodb::Page::FilTrailer checksum=2324395643, lsn_low32=2571765&gt;

page header:
#&lt;struct Innodb::Page::Index::PageHeader
 n_dir_slots=2,
 heap_top=1145,
 n_heap_format=32771,
 n_heap=3,
 format=:compact,
 garbage_offset=0,
 garbage_size=0,
 last_insert_offset=128,
 direction=:no_direction,
 n_direction=0,
 n_recs=1,
 max_trx_id=0,
 level=0,
 index_id=42&gt;

fseg header:
#&lt;struct Innodb::Page::Index::FsegHeader
 leaf=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_dynamic.ibd&quot;, page_size=16384, pages=6&gt;, fseg=2&gt;,
 internal=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_dynamic.ibd&quot;, page_size=16384, pages=6&gt;, fseg=1&gt;&gt;

sizes:
  header           120
  trailer            8
  directory          4
  free           15227
  used            1157
  record          1025
  per record     1025.00

page directory:
[99, 112]

system records:
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=99,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=128,
   type=:infimum,
   heap_number=0,
   n_owned=1,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=128,
 data=&quot;infimum\x00&quot;,
 length=8&gt;
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=112,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=112,
   type=:supremum,
   heap_number=1,
   n_owned=2,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=112,
 data=&quot;supremum&quot;,
 length=8&gt;

garbage records:

records:
#&lt;struct Innodb::Page::Index::UserRecord
 type=:clustered,
 format=:compact,
 offset=128,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=8,
   next=112,
   type=:conventional,
   heap_number=2,
   n_owned=0,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=[],
   lengths={&quot;b&quot;=&gt;1000},
   externs=[]&gt;,
 next=112,
 key=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;a&quot;,
    type=&quot;INT&quot;,
    value=1,
    extern=nil&gt;],
 row=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;b&quot;,
    type=&quot;VARCHAR(10000)&quot;,
    value=
     &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,
    extern=nil&gt;],
 sys=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_TRX_ID&quot;,
    type=&quot;TRX_ID&quot;,
    value=1309,
    extern=nil&gt;,
   #&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_ROLL_PTR&quot;,
    type=&quot;ROLL_PTR&quot;,
    value=
     #&lt;struct Innodb::DataType::RollPointerType::Pointer
      is_insert=true,
      rseg_id=55,
      undo_log=#&lt;struct Innodb::Page::Address page=299, offset=272&gt;&gt;,
    extern=nil&gt;],
 child_page_number=nil,
 transaction_id=1309,
 roll_pointer=
  #&lt;struct Innodb::DataType::RollPointerType::Pointer
   is_insert=true,
   rseg_id=55,
   undo_log=#&lt;struct Innodb::Page::Address page=299, offset=272&gt;&gt;,
 length=1017&gt;

</code></pre><p>=> 레코드가 1KB일 땐, COMPACT와 전혀 다르지 않다. 동일하게 하나의 data page에 모두 저장되는 모습</p><h2 id=레코드가-8kb보다-클-때>레코드가 8KB보다 클 때<a hidden class=anchor aria-hidden=true href=#레코드가-8kb보다-클-때>#</a></h2><h3 id=compact-1>compact<a hidden class=anchor aria-hidden=true href=#compact-1>#</a></h3><pre><code>[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact   space-index-pages-summary

page        index   level   data    free    records
3           41      0       813     15439   1
5           0       0       0       16384   0

=&gt; 3번 page에 813 bytes의 레코드가 하나 있는 것으로 보임.

앞서 레코드 사이즈가 1KB일 땐 하나의 data page에 모두 저장되었는데  이번엔 813 bytes만 저장되었다 나머지 9200 bytes는 어디로 간것일까..




[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact -p 3   page-dump
#&lt;Innodb::Page::Index:0x0000000000fafaf0&gt;:

fil header:
#&lt;struct Innodb::Page::FilHeader
 checksum=3289322324,
 offset=3,
 prev=nil,
 next=nil,
 lsn=2543164,
 type=:INDEX,
 flush_lsn=0,
 space_id=23&gt;

fil trailer:
#&lt;struct Innodb::Page::FilTrailer checksum=3289322324, lsn_low32=2543164&gt;

page header:
#&lt;struct Innodb::Page::Index::PageHeader
 n_dir_slots=2,
 heap_top=933,
 n_heap_format=32771,
 n_heap=3,
 format=:compact,
 garbage_offset=0,
 garbage_size=0,
 last_insert_offset=128,
 direction=:no_direction,
 n_direction=0,
 n_recs=1,
 max_trx_id=0,
 level=0,
 index_id=41&gt;

fseg header:
#&lt;struct Innodb::Page::Index::FsegHeader
 leaf=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_compact.ibd&quot;, page_size=16384, pages=6&gt;, fseg=2&gt;,
 internal=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_compact.ibd&quot;, page_size=16384, pages=6&gt;, fseg=1&gt;&gt;

sizes:
  header           120
  trailer            8
  directory          4
  free           15439
  used             945
  record           813
  per record     813.00

page directory:
[99, 112]

system records:
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=99,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=128,
   type=:infimum,
   heap_number=0,
   n_owned=1,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=128,
 data=&quot;infimum\x00&quot;,
 length=8&gt;
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=112,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=112,
   type=:supremum,
   heap_number=1,
   n_owned=2,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=112,
 data=&quot;supremum&quot;,
 length=8&gt;

garbage records:

records:
#&lt;struct Innodb::Page::Index::UserRecord
 type=:clustered,
 format=:compact,
 offset=128,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=8,
   next=112,
   type=:conventional,
   heap_number=2,
   n_owned=0,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=[],
   lengths={&quot;b&quot;=&gt;788},
   externs=[&quot;b&quot;]&gt;,
 next=112,
 key=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;a&quot;,
    type=&quot;INT&quot;,
    value=1,
    extern=nil&gt;],
 row=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;b&quot;,
    type=&quot;VARCHAR(10000)&quot;,
    value=
     &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,
    extern=
     #&lt;struct Innodb::Field::ExternReference
      space_id=23,
      page_number=4,
      offset=38,
      length=9232&gt;&gt;],
 sys=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_TRX_ID&quot;,
    type=&quot;TRX_ID&quot;,
    value=1290,
    extern=nil&gt;,
   #&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_ROLL_PTR&quot;,
    type=&quot;ROLL_PTR&quot;,
    value=
     #&lt;struct Innodb::DataType::RollPointerType::Pointer
      is_insert=true,
      rseg_id=42,
      undo_log=#&lt;struct Innodb::Page::Address page=286, offset=272&gt;&gt;,
    extern=nil&gt;],
 child_page_number=nil,
 transaction_id=1290,
 roll_pointer=
  #&lt;struct Innodb::DataType::RollPointerType::Pointer
   is_insert=true,
   rseg_id=42,
   undo_log=#&lt;struct Innodb::Page::Address page=286, offset=272&gt;&gt;,
 length=805&gt;
</code></pre><p>=> 3번 페이지를 page-dump로 확인해보니 드디어 b컬럼에 대해 externs=[&ldquo;b&rdquo;]> off-page가 발생한 것을 확인할 수 있음</p><pre><code> header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=8,
   next=112,
   type=:conventional,
   heap_number=2,
   n_owned=0,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=[],
   lengths={&quot;b&quot;=&gt;788},
   externs=[&quot;b&quot;]&gt;,
</code></pre><p>=> length={&ldquo;b&rdquo;=>788} 을 확인한다. 맨위에서 compact 동작방식의 768 bytes와는 수치가 살짝 다르지만 비슷한 로직을 드디어 확인했다</p><pre><code>     extern=
     #&lt;struct Innodb::Field::ExternReference
      space_id=23,
      page_number=4,
      offset=38,
      length=9232&gt;&gt;], 

</code></pre><p>=> 이 레코드의 off-page는 4번 페이지에 저장되었으며, 그 크기는 9232bytes라 한다</p><pre><code>[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact  -p 4 page-dump
#&lt;Innodb::Page::Blob:0x0000000000fb01d0&gt;:

fil header:
#&lt;struct Innodb::Page::FilHeader
 checksum=4279130595,
 offset=4,
 prev=0,
 next=0,
 lsn=2543164,
 type=:BLOB,
 flush_lsn=0,
 space_id=23&gt;

fil trailer:
#&lt;struct Innodb::Page::FilTrailer checksum=4279130595, lsn_low32=2543164&gt;

blob header:
{:length=&gt;9232, :next=&gt;nil}

blob data:
00000000  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000016  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000032  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000048  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
.
.
.
00009216  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
</code></pre><p>=> 4번 page를 확인해보면, type=:BLOB 으로 저장되어있음을 확인할 수 있고 9200 bytes만큼의 blob data를 쭉 확인할 수 있다!!</p><h3 id=dynamic-1>dynamic<a hidden class=anchor aria-hidden=true href=#dynamic-1>#</a></h3><pre><code>[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   space-index-pages-summary
page        index   level   data    free    records
3           42      0       45      16207   1
5           0       0       0       16384   0
</code></pre><p>=> 3번 page에 45bytes의 레코드 하나가 저장된 것으로 보임.  10,000 bytes의 문자열을 넣었는데 45bytes밖에 안됨. 벌써 COMPACT와 다르다</p><pre><code>[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   -p 3 page-dump
#&lt;Innodb::Page::Index:0x0000000000fafaf0&gt;:

fil header:
#&lt;struct Innodb::Page::FilHeader
 checksum=1440227673,
 offset=3,
 prev=nil,
 next=nil,
 lsn=2553982,
 type=:INDEX,
 flush_lsn=0,
 space_id=24&gt;

fil trailer:
#&lt;struct Innodb::Page::FilTrailer checksum=1440227673, lsn_low32=2553982&gt;

page header:
#&lt;struct Innodb::Page::Index::PageHeader
 n_dir_slots=2,
 heap_top=165,
 n_heap_format=32771,
 n_heap=3,
 format=:compact,
 garbage_offset=0,
 garbage_size=0,
 last_insert_offset=128,
 direction=:no_direction,
 n_direction=0,
 n_recs=1,
 max_trx_id=0,
 level=0,
 index_id=42&gt;

fseg header:
#&lt;struct Innodb::Page::Index::FsegHeader
 leaf=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_dynamic.ibd&quot;, page_size=16384, pages=6&gt;, fseg=2&gt;,
 internal=
  &lt;Innodb::Inode space=&lt;Innodb::Space file=&quot;test/tb_dynamic.ibd&quot;, page_size=16384, pages=6&gt;, fseg=1&gt;&gt;

sizes:
  header           120
  trailer            8
  directory          4
  free           16207
  used             177
  record            45
  per record     45.00

page directory:
[99, 112]

system records:
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=99,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=128,
   type=:infimum,
   heap_number=0,
   n_owned=1,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=128,
 data=&quot;infimum\x00&quot;,
 length=8&gt;
#&lt;struct Innodb::Page::Index::SystemRecord
 offset=112,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=5,
   next=112,
   type=:supremum,
   heap_number=1,
   n_owned=2,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=nil,
   lengths=nil,
   externs=nil&gt;,
 next=112,
 data=&quot;supremum&quot;,
 length=8&gt;

garbage records:

records:
#&lt;struct Innodb::Page::Index::UserRecord
 type=:clustered,
 format=:compact,
 offset=128,
 header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=8,
   next=112,
   type=:conventional,
   heap_number=2,
   n_owned=0,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=[],
   lengths={&quot;b&quot;=&gt;20},
   externs=[&quot;b&quot;]&gt;,
 next=112,
 key=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;a&quot;,
    type=&quot;INT&quot;,
    value=1,
    extern=nil&gt;],
 row=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;b&quot;,
    type=&quot;VARCHAR(10000)&quot;,
    value=&quot;&quot;,
    extern=
     #&lt;struct Innodb::Field::ExternReference
      space_id=24,
      page_number=4,
      offset=38,
      length=10000&gt;&gt;],
 sys=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_TRX_ID&quot;,
    type=&quot;TRX_ID&quot;,
    value=1292,
    extern=nil&gt;,
   #&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;DB_ROLL_PTR&quot;,
    type=&quot;ROLL_PTR&quot;,
    value=
     #&lt;struct Innodb::DataType::RollPointerType::Pointer
      is_insert=true,
      rseg_id=44,
      undo_log=#&lt;struct Innodb::Page::Address page=288, offset=272&gt;&gt;,
    extern=nil&gt;],
 child_page_number=nil,
 transaction_id=1292,
 roll_pointer=
  #&lt;struct Innodb::DataType::RollPointerType::Pointer
   is_insert=true,
   rseg_id=44,
   undo_log=#&lt;struct Innodb::Page::Address page=288, offset=272&gt;&gt;,
 length=37&gt;
</code></pre><pre><code> header=
  #&lt;struct Innodb::Page::Index::RecordHeader
   length=8,
   next=112,
   type=:conventional,
   heap_number=2,
   n_owned=0,
   info_flags=0,
   offset_size=nil,
   n_fields=nil,
   nulls=[],
   lengths={&quot;b&quot;=&gt;20},
   externs=[&quot;b&quot;]&gt;,
</code></pre><p>=> lengths={&ldquo;b&rdquo;=>20} , 맨위에서 본 dynamic의 동작방식과 동일하게 20bytes를 체크한다 !<br>마찬가지로 3번 page를 자세히 확인해보자</p><pre><code>  row=
  [#&lt;struct Innodb::Page::Index::FieldDescriptor
    name=&quot;b&quot;,
    type=&quot;VARCHAR(10000)&quot;,
    value=&quot;&quot;,
    extern=
     #&lt;struct Innodb::Field::ExternReference
      space_id=24,
      page_number=4,
      offset=38,
      length=10000&gt;&gt;], 
</code></pre><p>=>  역시 b컬럼에 대해 extern, off-page가 발생하였고 4번 페이지에 저장되었다.<br>COMPACT와 달리 768bytes 만큼의 prefix 조차도 저장하지 않아서 10,000 bytes 그대로 off-page에 저장되는 모습이다</p><pre><code>[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   -p 4 page-dump
#&lt;Innodb::Page::Blob:0x0000000000fafaf0&gt;:

fil header:
#&lt;struct Innodb::Page::FilHeader
 checksum=3045201149,
 offset=4,
 prev=0,
 next=0,
 lsn=2553982,
 type=:BLOB,
 flush_lsn=0,
 space_id=24&gt;

fil trailer:
#&lt;struct Innodb::Page::FilTrailer checksum=3045201149, lsn_low32=2553982&gt;

blob header:
{:length=&gt;10000, :next=&gt;nil}

blob data:
00000000  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000016  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000032  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
00000048  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
.
.
.
00009984  61 61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
</code></pre><p>=> 4번 page를 자세히 확인해보자<br>마찬가지로 type=:BLOB 으로 저장되었고 10,000 bytes만큼의 blob-data 를 확인할 수 있다!!</p><h2 id=데이터-건-수에-따른-compact-dynamic-data-page-차이>데이터 건 수에 따른 COMPACT DYNAMIC data-page 차이<a hidden class=anchor aria-hidden=true href=#데이터-건-수에-따른-compact-dynamic-data-page-차이>#</a></h2><pre><code>mysql&gt; select count(*),avg(length(b)) from tb_compact;
+----------+----------------+
| count(*) | avg(length(b)) |
+----------+----------------+
|      100 |     10000.0000 |
+----------+----------------+
1 row in set (0.02 sec)

mysql&gt; select count(*),avg(length(b)) from tb_dynamic;
+----------+----------------+
| count(*) | avg(length(b)) |
+----------+----------------+
|      100 |     10000.0000 |
+----------+----------------+
1 row in set (0.01 sec)

* compact

[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact   space-index-pages-summary
page        index   level   data    free    records
3           41      1       98      16154   7

[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact   space-index-pages-summary | wc -l
538


* dynamic

[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   space-index-pages-summary
page        index   level   data    free    records
3           42      0       4500    11704   100

[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   space-index-pages-summary | wc -l
218




mysql&gt; select count(*),avg(length(b)) from tb_compact;
+----------+----------------+
| count(*) | avg(length(b)) |
+----------+----------------+
|    12800 |     10000.0000 |
+----------+----------------+
1 row in set (0.42 sec)

mysql&gt; select count(*),avg(length(b)) from tb_dynamic;
+----------+----------------+
| count(*) | avg(length(b)) |
+----------+----------------+
|    12800 |     10000.0000 |
+----------+----------------+
1 row in set (0.45 sec)


### compact
[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_compact   space-index-pages-summary | wc -l
3326


### dynamic
[root@caeaedb95ff7 data]# innodb_space -s ibdata1 -T test/tb_dynamic   space-index-pages-summary | wc -l
510
</code></pre><p>=> COMPACT : 데이터 100건일 때 벌써 index depth가 늘어나고,  12800건 일 땐 data page 개수가 3326개<br>dynamic : 12800 건일 때에도 data page 개수는 510개 밖에 안됨.<br>text 등 큰 데이터를 저장할 때 compact / dynamic 의 차이는 데이터 건 수가 많아질 수록 점점 커질 것이기 때문에 반드시 dynamic을 사용하자</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/ddl/>ddl</a></li><li><a href=/tags/debugging/>debugging</a></li></ul><nav class=paginav><a class=next href=/mysql/ddl_failcase/><span class=title>Next Page »</span><br><span>MySQL 대용량 테이블 DDL할 때 주의할 사항들</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>