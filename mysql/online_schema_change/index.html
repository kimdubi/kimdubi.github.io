<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL online DDL을 위한 TOOL 비교 ( pt-osc & gh-ost ) | kimDuBiA</title><meta name=keywords content="mysql,pt-osc,percona,DDL,운영"><meta name=description content="MySQL online DDL을 위한 TOOL pt-osc & gh-ost ONLINE DDL MySQL은 DDL에 대해서 한정적으로 online 작업을 지원합니다.
online ddl 방식으로는 INPLACE, INSTANT (mysql 8.0부터) 가 있고
주로 쓰이는 algorithm=INPLACE 방식은 아래와 같은 절차로 ONLINE DDL을 지원합니다.
1. INPLACE 스키마 변경이 지원되는 커맨드인지, 스토리지 엔진(InnoDB) 인지 확인 2. online 스키마 변경 작업동안 변경되는 데이터를 저장할 준비 (innodb_online_alter_log_max_size) 3. 테이블 스키마 변경 및 DML 로깅 4. 변경 완료된 테이블에 DML 로깅 적용 5."><meta name=author content="kimdubi"><link rel=canonical href=/mysql/online_schema_change/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL online DDL을 위한 TOOL 비교 ( pt-osc & gh-ost )"><meta property="og:description" content="MySQL online DDL을 위한 TOOL pt-osc & gh-ost ONLINE DDL MySQL은 DDL에 대해서 한정적으로 online 작업을 지원합니다.
online ddl 방식으로는 INPLACE, INSTANT (mysql 8.0부터) 가 있고
주로 쓰이는 algorithm=INPLACE 방식은 아래와 같은 절차로 ONLINE DDL을 지원합니다.
1. INPLACE 스키마 변경이 지원되는 커맨드인지, 스토리지 엔진(InnoDB) 인지 확인 2. online 스키마 변경 작업동안 변경되는 데이터를 저장할 준비 (innodb_online_alter_log_max_size) 3. 테이블 스키마 변경 및 DML 로깅 4. 변경 완료된 테이블에 DML 로깅 적용 5."><meta property="og:type" content="article"><meta property="og:url" content="/mysql/online_schema_change/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2021-10-04T03:54:13+09:00"><meta property="article:modified_time" content="2021-10-04T03:54:13+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL online DDL을 위한 TOOL 비교 ( pt-osc & gh-ost )"><meta name=twitter:description content="MySQL online DDL을 위한 TOOL pt-osc & gh-ost ONLINE DDL MySQL은 DDL에 대해서 한정적으로 online 작업을 지원합니다.
online ddl 방식으로는 INPLACE, INSTANT (mysql 8.0부터) 가 있고
주로 쓰이는 algorithm=INPLACE 방식은 아래와 같은 절차로 ONLINE DDL을 지원합니다.
1. INPLACE 스키마 변경이 지원되는 커맨드인지, 스토리지 엔진(InnoDB) 인지 확인 2. online 스키마 변경 작업동안 변경되는 데이터를 저장할 준비 (innodb_online_alter_log_max_size) 3. 테이블 스키마 변경 및 DML 로깅 4. 변경 완료된 테이블에 DML 로깅 적용 5."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL online DDL을 위한 TOOL 비교 ( pt-osc \u0026 gh-ost )","item":"/mysql/online_schema_change/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL online DDL을 위한 TOOL 비교 ( pt-osc \u0026 gh-ost )","name":"MySQL online DDL을 위한 TOOL 비교 ( pt-osc \u0026 gh-ost )","description":"MySQL online DDL을 위한 TOOL pt-osc \u0026amp; gh-ost ONLINE DDL MySQL은 DDL에 대해서 한정적으로 online 작업을 지원합니다.\nonline ddl 방식으로는 INPLACE, INSTANT (mysql 8.0부터) 가 있고\n주로 쓰이는 algorithm=INPLACE 방식은 아래와 같은 절차로 ONLINE DDL을 지원합니다.\n1. INPLACE 스키마 변경이 지원되는 커맨드인지, 스토리지 엔진(InnoDB) 인지 확인 2. online 스키마 변경 작업동안 변경되는 데이터를 저장할 준비 (innodb_online_alter_log_max_size) 3. 테이블 스키마 변경 및 DML 로깅 4. 변경 완료된 테이블에 DML 로깅 적용 5.","keywords":["mysql","pt-osc","percona","DDL","운영"],"articleBody":"MySQL online DDL을 위한 TOOL pt-osc \u0026 gh-ost ONLINE DDL MySQL은 DDL에 대해서 한정적으로 online 작업을 지원합니다.\nonline ddl 방식으로는 INPLACE, INSTANT (mysql 8.0부터) 가 있고\n주로 쓰이는 algorithm=INPLACE 방식은 아래와 같은 절차로 ONLINE DDL을 지원합니다.\n1. INPLACE 스키마 변경이 지원되는 커맨드인지, 스토리지 엔진(InnoDB) 인지 확인 2. online 스키마 변경 작업동안 변경되는 데이터를 저장할 준비 (innodb_online_alter_log_max_size) 3. 테이블 스키마 변경 및 DML 로깅 4. 변경 완료된 테이블에 DML 로깅 적용 5. INPLACE 작업 완료  online 작업이니만큼 아래와 같은 주의사항이 있습니다.\n  2번과 4번 단계에서는 아주 짧게나마 metadata lock이 필요함, metadata lock을 못잡으면 작업 실패 (lock_wait_timeout 설정 확인 필요)\n mysql 8.0의 algorithm=INSTANT는 metadata lock을 잡지않음    3번 단계 DML 로깅을 하는 online alter log memory가 부족하면 작업이 실패함 (innodb_online_alter_log_max_size)\nERROR 1799 (HY000): Creating index ‘idx2’ required more than ‘innodb_online_alter_log_max_size’ bytes of modification log. Please try again.\n  ONLINE DDL Tool online DDL이 한정적이다 보니 지원하지 않는 작업을 online 으로 처리하기 위한 도구가 나왔는데 이번 글에서는 간단한 사용법과 차이점을 살펴보도록 하겠습니다.\npt-online-schema-change  INSTALL - rpm  yum install -y perl-IO* perl-DBD-MySQL perl-TermReadKey perl-devel https://www.percona.com/downloads/percona-toolkit/3.1.0/binary/redhat/6/x86_64/percona-toolkit-3.1.0-2.el6.x86_64.rpm rpm -ivh percona-toolkit-3.1.0-2.el6.x86_64.rpm  INSTALL tar.gz   wget percona.com/get/percona-toolkit.tar.gz tar zxvpf percona-toolkit.tar.gz perl ./Makefile.PL make sudo make install 동작방식 (https://gywn.net/2017/08/small-talk-pt-osc/)\n 수행하려는 DDL 이 반영된 new table을 생성 old-table로 발생한 DML을 new table로 가져오기 위한 update/insert/delete trigger 생성 chunk-size 만큼 old table로 부터 new table로 데이터 복사 (old table에 pk 필수) 복사가 끝나면 table rename 후 작업 완료  COMMAND pt-online-schema-change --alter \"add column ptosc int not null default 0\" D=test,t=tb_test \\ --no-drop-old-table \\ --no-drop-new-table \\ --chunk-size=1000 \\ --recursion-method=dsn=t=mysql.dsns \\ --max-lag=5 \\ --defaults-file=/home/kimdubi/db/mysql/my.cnf \\ --host=127.0.0.1 \\ --port=13306 \\ --user=root \\ --password=password \\ --progress=time,30 \\ --max-load=\"Threads_running=100\" \\ --critical-load=\"Threads_running=200\" \\ --chunk-index=PRIMARY \\ --charset=utf8mb4 \\ --set-vars=\"tx_isolation='repeatable-read',innodb_lock_wait_timeout=1,lock_wait_timeout=1\" \\ --no-check-alter \\ --execute   alter : 수행할 DDL 커맨드 D : 사용할 데이터베이스명 t : 테이블명 no-drop-old-table : 원본 테이블 rename 후 drop 하지 않음 no-drop-new-table : 작업 실패했을 때 생성한 new 테이블 drop 하지 않음 chunk-size : 복사할 데이터 크기 단위 max-lag : pt-osc는 master에서만 작업할 수 있는데 slave에서 복제지연이 발생하면 pt-osc 작업을 중단하고 기다림 progress : max-load : 작업 도중 서버에 과한 load 를 막기위해 수행하는 세션이 일정 수치 이상 되면 pt-osc 작업 일시 중지함 critical-load : max-load가 일시정지라면 이 옵션은 pt-osc 작업 중단시킴 set-vars: pt-osc 작업 시작할 때 설정할 session variables = 위 예시에서는 pt-osc 작업이 서비스에 영향 없도록 lock 1초안에 획득 못하면 작업중지하도록 설정함 no-check-alter : alter DDL 구문 체크 recursion-method : db port가 기본 port (3306)이 아닐 때 pt-osc는 slave를 찾지 못합니다.\ndsn방식으로 접속할 slave 정보를 저장해놓고 이 테이블을 조회하라고 명시해야합니다.   CREATE TABLE `dsn` ( `id` int(11) NOT NULL AUTO_INCREMENT, `parent_id` int(11) NOT NULL, `dsn` varchar(255) NOT NULL, PRIMARY KEY (`id`) ### slave IP:port insert INSERT INTO dsn(parent_id,dsn) VALUES(1,'h=11.111.11.11,P=13306'); TEST LOG 1. 정상 시나리오\n[kimdubi@test-dbatst-t1801 01:34:57 ~ ]$ pt-online-schema-change --alter \"add column ptosc int not null default 0\" D=test,t=tb_test \\  --no-drop-old-table \\  --no-drop-new-table \\  --chunk-size=1000 \\  --recursion-method=dsn=t=mysql.dsn \\  --max-lag=5 \\  --defaults-file=/home/kimdubi/db/mysql/my.cnf \\  --port=13306 \\  --user=ptosc \\  --password=qhdks123 \\  --progress=time,30 \\  --max-load=\"Threads_running=100\" \\  --critical-load=\"Threads_running=200\" \\  --chunk-index=PRIMARY \\  --charset=utf8mb4 \\  --set-vars=\"innodb_lock_wait_timeout=1,lock_wait_timeout=1\" \\  --no-check-alter \\  --execute Found 1 slaves: test-dbatst-t1802 - 11.111.11.11:13306 Will check slave lag on: test-dbatst-t1802 - 11.111.11.11:13306 Operation, tries, wait: analyze_table, 10, 1 copy_rows, 10, 0.25 create_triggers, 10, 1 drop_triggers, 10, 1 swap_tables, 10, 1 update_foreign_keys, 10, 1 Altering `test`.`tb_test`... Creating new table... Created new table test.___tb_test_new OK. Altering new table... Altered `test`.`___tb_test_new` OK. 2020-03-19T01:34:58 Creating triggers... 2020-03-19T01:34:58 Created triggers OK. 2020-03-19T01:34:58 Copying approximately 10079347 rows... Copying `test`.`tb_test`: 25% 01:27 remain Copying `test`.`tb_test`: 50% 00:57 remain Copying `test`.`tb_test`: 76% 00:27 remain 2020-03-19T01:37:06 Copied rows OK. 2020-03-19T01:37:06 Analyzing new table... 2020-03-19T01:37:06 Swapping tables... 2020-03-19T01:37:06 Swapped original and new tables OK. Not dropping old table because --no-drop-old-table was specified. 2020-03-19T01:37:06 Dropping triggers... 2020-03-19T01:37:06 Dropped triggers OK. Successfully altered `test`.`tb_test`.   DB 내에선 아래와 같은 작업들이 수행 됨   원본 table에서 new table 로 data copy 하는 세션 ( pk 기준 chunk 크기만큼씩)   mysql select * from information_schema.processlist where user='ptosc'\\G; *************************** 1. row *************************** ID: 751321 USER: ptosc HOST: localhost DB: test COMMAND: Query TIME: 0 STATE: Sending data INFO: INSERT LOW_PRIORITY IGNORE INTO `test`.`____tb_test_new` (`id`, `a`, `b`, `c`, `d`, `ptosc`) SELECT `id`, `a`, `b`, `c`, `d`, `ptosc` FROM `test`.`tb_test` FORCE INDEX(`PRIMARY`) WHERE ((`id` = '11089001')) AND ((`id` = LOW_PRIORITY : 다른 세션들이 해당 테이블을 사용하는 경우 그 작업이 모두 완료되면 insert 하겠다는 의미 IGNORE : error 발생하는 경우 무시하고 pass, 어차피 trigger로 최신 DML이 반영될 것이기 때문 LOCK IN SHARE MODE : 가져올 데이터 select 후 트랜잭션이 완료될 때 까지 해당 row 변경되지 않도록 보장\n원본 table의 DML을 new table로 반영하기 위한 trigger 세션 (insert /update /delete)   *************************** 3. row *************************** ID: 748143 USER: ptosc HOST: % DB: test COMMAND: Query TIME: 0 STATE: update INFO: REPLACE INTO `test`.`____tb_test_new` (`id`, `a`, `b`, `c`, `d`, `ptosc`) VALUES (NEW.`id`, NEW.`a`, NEW.`b`, NEW.`c`, NEW.`d`, NEW.`ptosc`)  작업 완료 후   mysql show tables; +----------------+ | Tables_in_test | +----------------+ | _tb_test_old | | tb_test | +----------------+ 2 rows in set (0.00 sec) mysql show triggers; Empty set (0.00 sec) mysql desc tb_test; +-------+---------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+---------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | a | varchar(100) | YES | | NULL | | | b | varchar(1001) | YES | | NULL | | | c | varchar(100) | YES | | NULL | | | d | varchar(100) | YES | | NULL | | | ptosc | int(11) | NO | | 0 | | +-------+---------------+------+-----+---------+----------------+ 6 rows in set (0.00 sec) 2. lock 획득 실패로 인한 작업 실패 LOG\n2020-03-19T14:51:59 Dropping triggers... 2020-03-19T14:52:18 Error dropping trigger: 2020-03-19T14:52:18 DBD::mysql::db do failed: Lock wait timeout exceeded; try restarting transaction [for Statement \"DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_del`\"] at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 11297. 2020-03-19T14:52:37 Error dropping trigger: 2020-03-19T14:52:37 DBD::mysql::db do failed: Lock wait timeout exceeded; try restarting transaction [for Statement \"DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_upd`\"] at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 11297. 2020-03-19T14:52:56 Error dropping trigger: 2020-03-19T14:52:56 DBD::mysql::db do failed: Lock wait timeout exceeded; try restarting transaction [for Statement \"DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_ins`\"] at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 11297. 2020-03-19T14:52:56 To try dropping the triggers again, execute: DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_del` DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_upd` DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_ins` Not dropping the new table `test`.`___tb_test_new` because --no-drop-new-table was specified. To drop the new table, execute: DROP TABLE IF EXISTS `test`.`___tb_test_new`;  = 재수행하려면 생성된 trigger 모두 삭제 필요\n3. max_load=? thread running 대기 LOG\n. . . Altering new table... Altered `test`.`___tb_test_new` OK. 2020-03-19T23:54:41 Creating triggers... 2020-03-19T23:54:41 Created triggers OK. 2020-03-19T23:54:41 Copying approximately 10686036 rows... Copying `test`.`tb_test`: 23% 01:35 remain Copying `test`.`tb_test`: 47% 01:05 remain Copying `test`.`tb_test`: 71% 00:35 remain Pausing because Threads_running=100. Pausing because Threads_running=100. Copying `test`.`tb_test`: 74% 03:56 remain Copying `test`.`tb_test`: 96% 00:27 remain 2020-03-20T00:07:00 Copied rows OK. 2020-03-20T00:07:00 Adding original triggers to new table.  = DB 내 session이 max_load 수 만큼 존재하면 pt-osc작업을 일시정지함 session 빠지면 자동 재수행\n4. critical-load=? 설정한 최대 thread 초과로 작업 실패 LOG\nAltering new table... Altered `test`.`___tb_test_new` OK. 2020-03-20T00:26:13 Creating triggers... 2020-03-20T00:26:13 Created triggers OK. 2020-03-20T00:26:13 Copying approximately 10771088 rows... Copying `test`.`tb_test`: 23% 01:39 remain 2020-03-20T00:26:47 Dropping triggers... 2020-03-20T00:26:47 Dropped triggers OK. Not dropping the new table `test`.`___tb_test_new` because --no-drop-new-table was specified. To drop the new table, execute: DROP TABLE IF EXISTS `test`.`___tb_test_new`; `test`.`tb_test` was not altered. 2020-03-20T00:26:47 Error copying rows from `test`.`tb_test` to `test`.`___tb_test_new`: Threads_running=4 exceeds its critical threshold 200  6. replication lag 대기 LOG\nAltering new table... Altered `test`.`_______tb_test_new` OK. 2020-03-20T01:08:52 Creating triggers... 2020-03-20T01:08:52 Created triggers OK. 2020-03-20T01:08:52 Copying approximately 11423307 rows... Replica lag is 1083 seconds on test-dbatst-t1802. Waiting. Replica lag is 1113 seconds on test-dbatst-t1802. Waiting. Replica lag is 1262 seconds on test-dbatst-t1802. Waiting. Copying `test`.`tb_test`: 0% 14+19:19:46 remain  6. 작업 시 charater set error LOG\n ERROR LOG   Character set 'utf8mb4' is not a compiled character set and is not specified in the '/usr/share/mysql/charsets/Index.xml' file Character set 'utf8mb4' is not a compiled character set and is not specified in the '/usr/share/mysql/charsets/Index.xml' file Cannot connect to MySQL: DBI connect('test;mysql_read_default_file=/home/kimdubi/db/mysql/my.cnf;host=127.0.0.1;port=13306;charset=utf8mb4;mysql_read_default_group=client','admin',...) failed: Can't initialize character set utf8mb4 (path: /usr/share/mysql/charsets/) at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 2345  utf8 = utf8mb4 로 수정   vi /usr/share/mysql/charsets/Index.xml Unicode UTF-8 Unicode utf-8 primary compiled  binary compiled   chunk copy 중간 sleep 넣기  vi /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change   8250 package pt_online_schema_change; 8251 8252 use strict; 8253 use warnings FATAL = 'all'; 8254 use English qw(-no_match_vars); 8255 8256 use Percona::Toolkit; 8257 use constant PTDEBUG = $ENV{PTDEBUG} || 0; 8258 8259 use List::Util qw(max); 8260 use Time::HiRes qw(time sleep usleep); . . 11405 sub exec_nibble { 11406 11407 usleep(10000); 11408 my (%args) = @_; 11409 my @required_args = qw(Cxn tbl stats tries Retry NibbleIterator Quoter); 11410 foreach my $arg ( @required_args ) { 11411 die \"I need a $arg argument\" unless $args{$arg}; = pt-osc 작업이 서비스 성능에 영향을 준다면 위 처럼 코드를 수정하여 chunk copy 건건 완료 마다 sleep() 하도록 수정\ngh-ost INSTALL wget https://github.com/github/gh-ost/releases/download/v1.0.49/gh-ost-1.0.49-1.x86_64.rpm rpm -ivh gh-ost-1.0.49-1.x86_64.rpm  동작방식  alter 문이 반영 된 ghost table 생성 PK로 chunk-size 만큼 data copy master 서버에서 수행된 DML에 대한 binary log를 ghost table에 반영함  binary log를 가져올 서버는 log-bin, binlog-format=ROW 설정 필요 SLAVE에서 가져오는 경우엔 log_slave_updates 옵션도 추가로 필요함   triggerless 방식  trigger로 인한 부하가 없음 작업 일시정지가 자유로움   org 테이블과 ghost 테이블 swapping  COMMAND gh-ost \\ --max-load=Threads_running=100 \\ --critical-load=Threads_running=200 \\ --chunk-size=1000 \\ --throttle-control-replicas=\"11.111.11.11:13306\" \\ --max-lag-millis=500 \\ --user=\"ghost\" \\ --password='qhdks123' \\ --host=\"11.111.11.11\" \\ --port=13306 \\ --database=\"test\" \\ --table=\"tb_test\" \\ --verbose \\ --alter=\"add column ghost5 int not null default 0\" \\ --switch-to-rbr \\ --allow-master-master \\ --allow-on-master \\ --assume-master-host=\"22.222.22.22:13306\" \\ --cut-over=default \\ --default-retries=120 \\ --panic-flag-file=/tmp/ghost.panic.flag \\ --postpone-cut-over-flag-file=/tmp/ghost.postpone.flag \\ --throttle-flag-file=/tmp/throttle.flag \\ --execute   host : binary log 를 가져올 서버 설정 throttle-control-replicas : –max-lag-millis 를 체크할 리플리카 서버 지정하는 옵션 switch-to-rbr : gh-ost 는 binlog_format=ROW 일 때만 동작하기 때문에 작업 대상 서버의 binlog_format을 ROW로 변경하는 옵션. 주로 Slave의 binlog_format 변경과 log_slave_updates 옵션 설정 후 재기동 수행 (원복 X) allow-master-master : MMM 사용할 때 처럼 master-master (active-passive) 구성일 때 설정 allow-on-master : master에서 작업할 때 설정하는 옵션 migrate-on-replica : slave 에서 작업할 때 설정하는 옵션 ( 양방향 복제가 아닌 이상 slave에만 작업 적용되므로 참고! ) assume-master-host : allow-master-master 설정 시 작업할 master 서버 지정하는 옵션 cut-over : org-table과 gh-ost table 간 swapping하는 migration의 마지막 단계로 atomic 하기 때문에 swapping 도중 실패하는 쿼리는 없음 panic-flag-file : flag-file 생성 시 작업 취소 postpone-cut-over-flag-file : flag-file 존재하면 cut-over 단계를 수행하지 않고 대기함 이 옵션 설정 시 작업 시작 할때 이 파일을 생성하기 때문에 마지막 rename 단계 전에 수동으로 삭제해줘야함, 대기하더라도 DML은 계속 copy 진행됨 throttle-flag-file : throttle-flag-file 존재하면 작업 일시정지  TEST LOG 1. 정상 시나리오\n2020-03-24 11:49:13 INFO starting gh-ost 1.0.49 2020-03-24 11:49:13 INFO Migrating `test`.`tb_test` 2020-03-24 11:49:13 INFO connection validated on 11.111.11.11:13306 2020-03-24 11:49:13 INFO User has SUPER, REPLICATION SLAVE privileges, and has ALL privileges on `test`.* 2020-03-24 11:49:13 INFO binary logs validated on 11.111.11.11:13306 2020-03-24 11:49:13 INFO Restarting replication on 11.111.11.11:13306 to make sure binlog settings apply to replication thread 2020-03-24 11:49:14 INFO Inspector initiated on test-dbatst-t1802:13306, version 8.0.16 2020-03-24 11:49:14 INFO Table found. Engine=InnoDB 2020-03-24 11:49:14 INFO Estimated number of rows via EXPLAIN: 11474891 2020-03-24 11:49:14 INFO Master forced to be 22.222.22.22:13306 2020-03-24 11:49:14 INFO log_slave_updates validated on 11.111.11.11:13306 2020-03-24 11:49:14 INFO connection validated on 11.111.11.11:13306 2020-03-24 11:49:14 INFO Connecting binlog streamer at mysql-bin.000012:638658499 [2020/03/24 11:49:14] [info] binlogsyncer.go:133 create BinlogSyncer with config {99999 mysql 11.111.11.11 13306 ghost false false  false UTC true 0 0s 0s 0 false} [2020/03/24 11:49:14] [info] binlogsyncer.go:354 begin to sync binlog from position (mysql-bin.000012, 638658499) [2020/03/24 11:49:14] [info] binlogsyncer.go:203 register slave for master server 11.111.11.11:13306 2020-03-24 11:49:14 INFO rotate to next log from mysql-bin.000012:0 to mysql-bin.000012 [2020/03/24 11:49:14] [info] binlogsyncer.go:723 rotate to (mysql-bin.000012, 638658499) 2020-03-24 11:49:14 INFO connection validated on 22.222.22.22:13306 2020-03-24 11:49:14 INFO connection validated on 22.222.22.22:13306 2020-03-24 11:49:14 INFO will use time_zone='SYSTEM' on applier 2020-03-24 11:49:14 INFO Examining table structure on applier 2020-03-24 11:49:14 INFO Applier initiated on test-dbatst-t1801:13306, version 8.0.16  = master / slave 파악 및 binary log 가져올 서버(여기선 slave) 와 binlog position 확인\n2020-03-24 11:49:14 INFO Dropping table `test`.`_tb_test_ghc` 2020-03-24 11:49:14 INFO Table dropped 2020-03-24 11:49:14 INFO Creating changelog table `test`.`_tb_test_ghc` 2020-03-24 11:49:14 INFO Changelog table created 2020-03-24 11:49:14 INFO Creating ghost table `test`.`_tb_test_gho` 2020-03-24 11:49:14 INFO Ghost table created 2020-03-24 11:49:14 INFO Altering ghost table `test`.`_tb_test_gho` 2020-03-24 11:49:14 INFO Ghost table altered  = migration 과정을 기록할 _tb_test_ghc 테이블 , 데이터 copy 및 rename 할 _tb_test_gho 임시테이블 생성\n2020-03-24 11:49:14 INFO Created postpone-cut-over-flag-file: /tmp/ghost.postpone.flag 2020-03-24 11:49:14 INFO Waiting for ghost table to be migrated. Current lag is 0s 2020-03-24 11:49:14 INFO Intercepted changelog state GhostTableMigrated 2020-03-24 11:49:14 INFO Handled changelog state GhostTableMigrated 2020-03-24 11:49:14 INFO Chosen shared unique key is PRIMARY 2020-03-24 11:49:14 INFO Shared columns are id,a,b,c,d,ptosc,ghost,ghost2 2020-03-24 11:49:14 INFO Listening on unix socket file: /tmp/gh-ost.test.tb_test.sock 2020-03-24 11:49:14 INFO Migration min values: [1] 2020-03-24 11:49:14 INFO Migration max values: [12404000] 2020-03-24 11:49:14 INFO Waiting for first throttle metrics to be collected 2020-03-24 11:49:14 INFO First throttle metrics collected # Migrating `test`.`tb_test`; Ghost table is `test`.`_tb_test_gho` # Migrating test-dbatst-t1801:13306; inspecting test-dbatst-t1802:13306; executing on test-dbatst-t1801 # Migration started at Tue Mar 24 11:49:13 +0900 2020 # chunk-size: 1000; max-lag-millis: 500ms; dml-batch-size: 10; max-load: Threads_running=100; critical-load: Threads_running=200; nice-ratio: 0.000000 # throttle-additional-flag-file: /tmp/gh-ost.throttle # throttle-control-replicas count: 1 # postpone-cut-over-flag-file: /tmp/ghost.postpone.flag [set] # panic-flag-file: /tmp/ghost.panic.flag # Serving on unix socket: /tmp/gh-ost.test.tb_test.sock  = 설정 재확인 및 postpone 파일 생성 (마지막 rename 단계에서 수동으로 지워줘야함)\nCopy: 0/11474891 0.0%; Applied: 0; Backlog: 0/1000; Time: 1s(total), 0s(copy); streamer: mysql-bin.000012:638660757; Lag: 0.01s, State: migrating; ETA: N/A Copy: 0/11474891 0.0%; Applied: 0; Backlog: 0/1000; Time: 2s(total), 1s(copy); streamer: mysql-bin.000012:638665367; Lag: 0.01s, State: migrating; ETA: N/A Copy: 87000/11474891 0.8%; Applied: 0; Backlog: 0/1000; Time: 3s(total), 2s(copy); streamer: mysql-bin.000012:645087979; Lag: 0.01s, State: migrating; ETA: 4m21s Copy: 177000/11474891 1.5%; Applied: 0; Backlog: 0/1000; Time: 4s(total), 3s(copy); streamer: mysql-bin.000012:651809118; Lag: 0.01s, State: migrating; ETA: 3m11s Copy: 267000/11474891 2.3%; Applied: 0; Backlog: 0/1000; Time: 5s(total), 4s(copy); streamer: mysql-bin.000012:658530259; Lag: 0.01s, State: migrating; ETA: 2m47s Copy: 357000/11474891 3.1%; Applied: 0; Backlog: 0/1000; Time: 6s(total), 5s(copy); streamer: mysql-bin.000012:665251399; Lag: 0.01s, State: migrating; ETA: 2m35s . . . Copy: 12404000/12404000 100.0%; Applied: 0; Backlog: 0/1000; Time: 3m30s(total), 2m21s(copy); streamer: mysql-bin.000013:494768124; Lag: 0.01s, State: postponing cut-over; ETA: due Copy: 12404000/12404000 100.0%; Applied: 0; Backlog: 0/1000; Time: 4m0s(total), 2m21s(copy); streamer: mysql-bin.000013:494892172; Lag: 0.01s, State: postponing cut-over; ETA: due  = org_table에서 tmp table로 data copy\n2020-03-24 11:53:22 INFO Grabbing voluntary lock: gh-ost.160965.lock 2020-03-24 11:53:22 INFO Setting LOCK timeout as 6 seconds 2020-03-24 11:53:22 INFO Looking for magic cut-over table 2020-03-24 11:53:22 INFO Creating magic cut-over table `test`.`_tb_test_del` 2020-03-24 11:53:22 INFO Magic cut-over table created 2020-03-24 11:53:22 INFO Locking `test`.`tb_test`, `test`.`_tb_test_del` 2020-03-24 11:53:22 INFO Tables locked 2020-03-24 11:53:22 INFO Session locking original \u0026 magic tables is 160965 2020-03-24 11:53:22 INFO Writing changelog state: AllEventsUpToLockProcessed:1585018402096959497 2020-03-24 11:53:22 INFO Waiting for events up to lock 2020-03-24 11:53:22 INFO Intercepted changelog state AllEventsUpToLockProcessed 2020-03-24 11:53:22 INFO Handled changelog state AllEventsUpToLockProcessed 2020-03-24 11:53:23 INFO Waiting for events up to lock: got AllEventsUpToLockProcessed:1585018402096959497 2020-03-24 11:53:23 INFO Done waiting for events up to lock; duration=983.332503ms # Migrating `test`.`tb_test`; Ghost table is `test`.`_tb_test_gho` # Migrating test-dbatst-t1801:13306; inspecting test-dbatst-t1802:13306; executing on test-dbatst-t1801 # Migration started at Tue Mar 24 11:49:13 +0900 2020 # chunk-size: 1000; max-lag-millis: 500ms; dml-batch-size: 10; max-load: Threads_running=100; critical-load: Threads_running=200; nice-ratio: 0.000000 # throttle-additional-flag-file: /tmp/gh-ost.throttle # throttle-control-replicas count: 1 # postpone-cut-over-flag-file: /tmp/ghost.postpone.flag # panic-flag-file: /tmp/ghost.panic.flag # Serving on unix socket: /tmp/gh-ost.test.tb_test.sock Copy: 12404000/12404000 100.0%; Applied: 0; Backlog: 0/1000; Time: 4m9s(total), 2m21s(copy); streamer: mysql-bin.000013:494931666; Lag: 0.01s, State: migrating; ETA: due 2020-03-24 11:53:23 INFO Setting RENAME timeout as 3 seconds 2020-03-24 11:53:23 INFO Session renaming tables is 160954 2020-03-24 11:53:23 INFO Issuing and expecting this to block: rename /* gh-ost */ table `test`.`tb_test` to `test`.`_tb_test_del`, `test`.`_tb_test_gho` to `test`.`tb_test` 2020-03-24 11:53:23 INFO Found atomic RENAME to be blocking, as expected. Double checking the lock is still in place (though I don't strictly have to) 2020-03-24 11:53:23 INFO Checking session lock: gh-ost.160965.lock 2020-03-24 11:53:23 INFO Connection holding lock on original table still exists 2020-03-24 11:53:23 INFO Will now proceed to drop magic table and unlock tables 2020-03-24 11:53:23 INFO Dropping magic cut-over table 2020-03-24 11:53:23 INFO Releasing lock from `test`.`tb_test`, `test`.`_tb_test_del` 2020-03-24 11:53:23 INFO Tables unlocked 2020-03-24 11:53:23 INFO Tables renamed 2020-03-24 11:53:23 INFO Lock \u0026 rename duration: 1.005631871s. During this time, queries on `tb_test` were blocked 2020-03-24 11:53:23 INFO Looking for magic cut-over table [2020/03/24 11:53:23] [info] binlogsyncer.go:164 syncer is closing... 2020-03-24 11:53:23 INFO Closed streamer connection. err= 2020-03-24 11:53:23 INFO Dropping table `test`.`_tb_test_ghc` [2020/03/24 11:53:23] [error] binlogsyncer.go:631 connection was bad [2020/03/24 11:53:23] [error] binlogstreamer.go:77 close sync with err: Sync was closed [2020/03/24 11:53:23] [info] binlogsyncer.go:179 syncer is closed 2020-03-24 11:53:23 INFO Table dropped 2020-03-24 11:53:23 INFO Am not dropping old table because I want this operation to be as live as possible. If you insist I should do it, please add `--ok-to-drop-table` next time. But I prefer you do not. To drop the old table, issue: 2020-03-24 11:53:23 INFO -- drop table `test`.`_tb_test_del` 2020-03-24 11:53:23 INFO Done migrating `test`.`tb_test` 2020-03-24 11:53:23 INFO Removing socket file: /tmp/gh-ost.test.tb_test.sock 2020-03-24 11:53:23 INFO Tearing down inspector 2020-03-24 11:53:23 INFO Tearing down applier 2020-03-24 11:53:23 INFO Tearing down streamer 2020-03-24 11:53:23 INFO Tearing down throttler # Done  = copy 완료 후 rename 및 정리\n2. binlog_format ROW 가 아닐 때\ngh-ost \\ --max-load=Threads_running=100 \\ --critical-load=Threads_running=200 \\ --chunk-size=1000 \\ . . . 2020-03-24 14:04:13 FATAL 11.111.11.11:13306 has MIXED binlog_format, but I'm too scared to change it to ROW because it has replicas. Bailing out  = binary log 를 가져오려는 Slave 서버가 MIXED format 을 사용하는 경우 –switch-to-rbr 옵션을 통해 Slave의 replication 재기동 및 binlog_format=MIXED 로 변경함 그러나 양방향 복제를 하는 환경에서는 위의 에러로 작업이 실패하기 때문에 수동으로 Slave binlog_format 변경해야함 (dynamic parameter, replication 재기동 필요)\n3. log_slave_updates 안 켰을 때\n2020-03-24 16:30:27 FATAL 11.111.11.11:13306 must have log_slave_updates enabled for executing migration  = slave에서 binary log 를 가져오는 경우 log_slave_updates=ON 이어야함 OFF 설정시 작업실패하며 DB 재기동이 필요한 옵션임\n4. throttle 로 일시정지\n### throttle file 생성 [kimdubi@test-dbatst-t1801 14:23:32 /tmp ]$ touch /tmp/throttle.flag ### 작업 일시정지 Copy: 1558000/11087382 14.1%; Applied: 0; Backlog: 0/1000; Time: 20s(total), 19s(copy); streamer: mysql-bin.000014:469195727; Lag: 0.01s, State: migrating; ETA: 1m56s Copy: 1647000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 21s(total), 20s(copy); streamer: mysql-bin.000014:476020512; Lag: 0.01s, State: migrating; ETA: 1m54s Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 22s(total), 21s(copy); streamer: mysql-bin.000014:476868746; Lag: 0.01s, State: throttled, flag-file; ETA: 1m59s Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 23s(total), 22s(copy); streamer: mysql-bin.000014:476873383; Lag: 0.01s, State: throttled, flag-file; ETA: 2m5s Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 24s(total), 23s(copy); streamer: mysql-bin.000014:476878018; Lag: 0.01s, State: throttled, flag-file; ETA: 2m10s . . ### throttle 파일 삭제 [kimdubi@test-dbatst-t1801 14:23:43 /tmp ]$ rm /tmp/throttle.flag rm: remove regular empty file `/tmp/throttle.flag'? y . . ### 작업 재개 Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 1m5s(total), 1m4s(copy); streamer: mysql-bin.000014:477065980; Lag: 0.01s, State: throttled, flag-file; ETA: 6m4s Copy: 2090000/11087382 18.9%; Applied: 0; Backlog: 0/1000; Time: 1m10s(total), 1m9s(copy); streamer: mysql-bin.000014:510249819; Lag: 0.01s, State: migrating; ETA: 4m57s Copy: 2535000/11087382 22.9%; Applied: 0; Backlog: 0/1000; Time: 1m15s(total), 1m14s(copy); streamer: mysql-bin.000014:544314297; Lag: 0.01s, State: migrating; ETA: 4m9s  5. panic 으로 작업 중단\n### panic 파일 생성 [kimdubi@test-dbatst-t1801 14:25:36 /tmp ]$ touch /tmp/ghost.panic.flag ### 작업 정지 Copy: 7839000/11087382 70.7%; Applied: 0; Backlog: 0/1000; Time: 2m16s(total), 2m15s(copy); streamer: mysql-bin.000014:951100060; Lag: 0.01s, State: migrating; ETA: 55s 2020-03-24 14:25:38 FATAL Found panic-file /tmp/ghost.panic.flag. Aborting without cleanup ### 작업 테이블은 남아있으므로 수동 삭제 필요 mysql show tables like '%tb_test%'; +----------------------------+ | Tables_in_test (%tb_test%) | +----------------------------+ | _tb_test_ghc | | _tb_test_gho |  공통점  Table Copy 방식을 사용 기존 테이블의 row를 chunk 단위로 임시 테이블에 복사 복사 완료 후 rename table로 임시 테이블을 기존 테이블처럼 사용 툴을 원격 서버에서 사용 가능 PK 혹은 Unique key 반드시 필요 (중복없이 chunk 를 나누는 단위)  차이점     pt-osc gh-ost     작업 중 DML 반영 방식 trigger binlog   binlog_format 상관없음 ROW(Mixed안됨)   log_slave_updates 상관없음 master에서 binlog 가져오면 상관없음, slave에서 가져오면 필수   FK 지원 미지원   trigger 지원 미지원   임의 중단 기능 미지원 throttle, panic 옵션으로 지원   작업 도중 설정 변경 미지원 지원 (https://github.com/github/gh-ost/blob/d2726c77f86cb65e25bce5c0ac5fe3fa0c997488/doc/interactive-commands.md)   작업 수행 서버 Master Master / Slave (–migrate-on-replica)    ","wordCount":"3289","inLanguage":"en","datePublished":"2021-10-04T03:54:13+09:00","dateModified":"2021-10-04T03:54:13+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/online_schema_change/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL online DDL을 위한 TOOL 비교 ( pt-osc & gh-ost )</h1><div class=post-meta>October 4, 2021&nbsp;·&nbsp;16 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mysql-online-ddl%ec%9d%84-%ec%9c%84%ed%95%9c-tool-pt-osc--gh-ost aria-label="MySQL online DDL을 위한 TOOL pt-osc &amp;amp; gh-ost">MySQL online DDL을 위한 TOOL pt-osc & gh-ost</a></li><li><a href=#online-ddl aria-label="ONLINE DDL">ONLINE DDL</a></li><li><a href=#online-ddl-tool aria-label="ONLINE DDL Tool">ONLINE DDL Tool</a><ul><li><a href=#pt-online-schema-change aria-label=pt-online-schema-change>pt-online-schema-change</a><ul><li><a href=#%eb%8f%99%ec%9e%91%eb%b0%a9%ec%8b%9d aria-label=동작방식>동작방식</a></li><li><a href=#command aria-label=COMMAND>COMMAND</a></li><li><a href=#test-log aria-label="TEST LOG">TEST LOG</a></li><li><a href=#chunk-copy-%ec%a4%91%ea%b0%84-sleep-%eb%84%a3%ea%b8%b0 aria-label="chunk copy 중간 sleep 넣기">chunk copy 중간 sleep 넣기</a></li></ul></li><li><a href=#gh-ost aria-label=gh-ost>gh-ost</a><ul><li><a href=#install aria-label=INSTALL>INSTALL</a></li><li><a href=#%eb%8f%99%ec%9e%91%eb%b0%a9%ec%8b%9d-1 aria-label=동작방식>동작방식</a></li><li><a href=#command-1 aria-label=COMMAND>COMMAND</a></li><li><a href=#test-log-1 aria-label="TEST LOG">TEST LOG</a></li></ul></li><li><a href=#%ea%b3%b5%ed%86%b5%ec%a0%90 aria-label=공통점>공통점</a></li><li><a href=#%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label=차이점>차이점</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=mysql-online-ddl을-위한-tool-pt-osc--gh-ost>MySQL online DDL을 위한 TOOL pt-osc & gh-ost<a hidden class=anchor aria-hidden=true href=#mysql-online-ddl을-위한-tool-pt-osc--gh-ost>#</a></h2><h2 id=online-ddl>ONLINE DDL<a hidden class=anchor aria-hidden=true href=#online-ddl>#</a></h2><p>MySQL은 DDL에 대해서 한정적으로 online 작업을 지원합니다.<br>online ddl 방식으로는 INPLACE, INSTANT (mysql 8.0부터) 가 있고<br>주로 쓰이는 algorithm=INPLACE 방식은 아래와 같은 절차로 ONLINE DDL을 지원합니다.</p><pre><code>1. INPLACE 스키마 변경이 지원되는 커맨드인지, 스토리지 엔진(InnoDB) 인지 확인 
2. online 스키마 변경 작업동안 변경되는 데이터를 저장할 준비  (innodb_online_alter_log_max_size)
3. 테이블 스키마 변경 및 DML 로깅
4. 변경 완료된 테이블에 DML 로깅 적용
5. INPLACE 작업 완료  
</code></pre><p>online 작업이니만큼 아래와 같은 주의사항이 있습니다.</p><ul><li><p>2번과 4번 단계에서는 아주 짧게나마 metadata lock이 필요함, metadata lock을 못잡으면 작업 실패 (lock_wait_timeout 설정 확인 필요)</p><ul><li>mysql 8.0의 algorithm=INSTANT는 metadata lock을 잡지않음</li></ul></li><li><p>3번 단계 DML 로깅을 하는 online alter log memory가 부족하면 작업이 실패함 (innodb_online_alter_log_max_size)</p><p>ERROR 1799 (HY000): Creating index &lsquo;idx2&rsquo; required more than &lsquo;innodb_online_alter_log_max_size&rsquo; bytes of modification log. Please try again.</p></li></ul><h2 id=online-ddl-tool>ONLINE DDL Tool<a hidden class=anchor aria-hidden=true href=#online-ddl-tool>#</a></h2><p>online DDL이 한정적이다 보니 지원하지 않는 작업을 online 으로 처리하기 위한 도구가 나왔는데 이번 글에서는 간단한 사용법과 차이점을 살펴보도록 하겠습니다.</p><h3 id=pt-online-schema-change>pt-online-schema-change<a hidden class=anchor aria-hidden=true href=#pt-online-schema-change>#</a></h3><ul><li>INSTALL - rpm</li></ul><pre><code>yum install -y perl-IO* perl-DBD-MySQL perl-TermReadKey perl-devel
https://www.percona.com/downloads/percona-toolkit/3.1.0/binary/redhat/6/x86_64/percona-toolkit-3.1.0-2.el6.x86_64.rpm

rpm -ivh percona-toolkit-3.1.0-2.el6.x86_64.rpm
</code></pre><ul><li>INSTALL tar.gz</li></ul><pre><code>    wget percona.com/get/percona-toolkit.tar.gz
    tar zxvpf percona-toolkit.tar.gz
    perl ./Makefile.PL
    make
    sudo make install
</code></pre><h4 id=동작방식>동작방식<a hidden class=anchor aria-hidden=true href=#동작방식>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ptosc.png alt></p><p>(<a href=https://gywn.net/2017/08/small-talk-pt-osc/>https://gywn.net/2017/08/small-talk-pt-osc/</a>)</p><ul><li>수행하려는 DDL 이 반영된 new table을 생성</li><li>old-table로 발생한 DML을 new table로 가져오기 위한 update/insert/delete trigger 생성</li><li>chunk-size 만큼 old table로 부터 new table로 데이터 복사 (old table에 pk 필수)</li><li>복사가 끝나면 table rename 후 작업 완료</li></ul><h4 id=command>COMMAND<a hidden class=anchor aria-hidden=true href=#command>#</a></h4><pre><code>pt-online-schema-change --alter &quot;add column ptosc int not null default 0&quot; D=test,t=tb_test \
--no-drop-old-table \
--no-drop-new-table \
--chunk-size=1000 \
--recursion-method=dsn=t=mysql.dsns \
--max-lag=5 \
--defaults-file=/home/kimdubi/db/mysql/my.cnf \
--host=127.0.0.1 \
--port=13306 \
--user=root \
--password=password \
--progress=time,30 \
--max-load=&quot;Threads_running=100&quot; \
--critical-load=&quot;Threads_running=200&quot; \
--chunk-index=PRIMARY \
--charset=utf8mb4 \
--set-vars=&quot;tx_isolation='repeatable-read',innodb_lock_wait_timeout=1,lock_wait_timeout=1&quot; \
--no-check-alter \
--execute
</code></pre><ul><li>alter : 수행할 DDL 커맨드</li><li>D : 사용할 데이터베이스명</li><li>t : 테이블명</li><li>no-drop-old-table : 원본 테이블 rename 후 drop 하지 않음</li><li>no-drop-new-table : 작업 실패했을 때 생성한 new 테이블 drop 하지 않음</li><li>chunk-size : 복사할 데이터 크기 단위</li><li>max-lag : pt-osc는 master에서만 작업할 수 있는데 slave에서 복제지연이 발생하면 pt-osc 작업을 중단하고 기다림</li><li>progress :</li><li>max-load : 작업 도중 서버에 과한 load 를 막기위해 수행하는 세션이 일정 수치 이상 되면 pt-osc 작업 일시 중지함</li><li>critical-load : max-load가 일시정지라면 이 옵션은 pt-osc 작업 중단시킴</li><li>set-vars: pt-osc 작업 시작할 때 설정할 session variables <strong>=> 위 예시에서는 pt-osc 작업이 서비스에 영향 없도록 lock 1초안에 획득 못하면 작업중지하도록 설정함</strong></li><li>no-check-alter : alter DDL 구문 체크</li><li>recursion-method : db port가 기본 port (3306)이 아닐 때 pt-osc는 slave를 찾지 못합니다.<br>dsn방식으로 접속할 slave 정보를 저장해놓고 이 테이블을 조회하라고 명시해야합니다.</li></ul><pre><code>     CREATE TABLE `dsn` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `parent_id` int(11) NOT NULL,
      `dsn` varchar(255) NOT NULL,
      PRIMARY KEY (`id`)
    
    ###  slave IP:port insert
    INSERT INTO dsn(parent_id,dsn) VALUES(1,'h=11.111.11.11,P=13306');  
</code></pre><h4 id=test-log>TEST LOG<a hidden class=anchor aria-hidden=true href=#test-log>#</a></h4><p><strong>1. 정상 시나리오</strong></p><pre><code>[kimdubi@test-dbatst-t1801 01:34:57 ~ ]$ pt-online-schema-change --alter &quot;add column ptosc int not null default 0&quot; D=test,t=tb_test \
&gt; --no-drop-old-table \
&gt; --no-drop-new-table \
&gt; --chunk-size=1000 \
&gt; --recursion-method=dsn=t=mysql.dsn \
&gt; --max-lag=5 \
&gt; --defaults-file=/home/kimdubi/db/mysql/my.cnf \
&gt; --port=13306 \
&gt; --user=ptosc \
&gt; --password=qhdks123 \
&gt; --progress=time,30 \
&gt; --max-load=&quot;Threads_running=100&quot; \
&gt; --critical-load=&quot;Threads_running=200&quot; \
&gt; --chunk-index=PRIMARY \
&gt; --charset=utf8mb4 \
&gt; --set-vars=&quot;innodb_lock_wait_timeout=1,lock_wait_timeout=1&quot; \
&gt; --no-check-alter \
&gt; --execute
Found 1 slaves:
test-dbatst-t1802 -&gt; 11.111.11.11:13306
Will check slave lag on:
test-dbatst-t1802 -&gt; 11.111.11.11:13306
Operation, tries, wait:
  analyze_table, 10, 1
  copy_rows, 10, 0.25
  create_triggers, 10, 1
  drop_triggers, 10, 1
  swap_tables, 10, 1
  update_foreign_keys, 10, 1
Altering `test`.`tb_test`...
Creating new table...
Created new table test.___tb_test_new OK.
Altering new table...
Altered `test`.`___tb_test_new` OK.
2020-03-19T01:34:58 Creating triggers...
2020-03-19T01:34:58 Created triggers OK.
2020-03-19T01:34:58 Copying approximately 10079347 rows...
Copying `test`.`tb_test`:  25% 01:27 remain
Copying `test`.`tb_test`:  50% 00:57 remain
Copying `test`.`tb_test`:  76% 00:27 remain
2020-03-19T01:37:06 Copied rows OK.
2020-03-19T01:37:06 Analyzing new table...
2020-03-19T01:37:06 Swapping tables...
2020-03-19T01:37:06 Swapped original and new tables OK.
Not dropping old table because --no-drop-old-table was specified.
2020-03-19T01:37:06 Dropping triggers...
2020-03-19T01:37:06 Dropped triggers OK.
Successfully altered `test`.`tb_test`.
</code></pre><ul><li>DB 내에선 아래와 같은 작업들이 수행 됨</li></ul><ol><li>원본 table에서 new table 로 data copy 하는 세션 ( pk 기준 chunk 크기만큼씩)</li></ol><pre><code>    mysql&gt; select * from information_schema.processlist where user='ptosc'\G;
    *************************** 1. row ***************************
         ID: 751321
       USER: ptosc
       HOST: localhost
         DB: test
    COMMAND: Query
       TIME: 0
      STATE: Sending data
       INFO: INSERT LOW_PRIORITY IGNORE INTO `test`.`____tb_test_new` (`id`, `a`, `b`, `c`, `d`, `ptosc`) SELECT `id`, `a`, `b`, `c`, `d`, `ptosc` FROM `test`.`tb_test` FORCE INDEX(`PRIMARY`) WHERE ((`id` &gt;= '11089001')) AND ((`id` &lt;= '11090000')) LOCK IN SHARE MODE /*pt-online-schema-change 47357 copy nibble*/
</code></pre><p>=> LOW_PRIORITY : 다른 세션들이 해당 테이블을 사용하는 경우 그 작업이 모두 완료되면 insert 하겠다는 의미 IGNORE : error 발생하는 경우 무시하고 pass, 어차피 trigger로 최신 DML이 반영될 것이기 때문 LOCK IN SHARE MODE : 가져올 데이터 select 후 트랜잭션이 완료될 때 까지 해당 row 변경되지 않도록 보장</p><ol start=2><li>원본 table의 DML을 new table로 반영하기 위한 trigger 세션 (insert /update /delete)</li></ol><pre><code>    *************************** 3. row ***************************
         ID: 748143
       USER: ptosc
       HOST: %
         DB: test
    COMMAND: Query
       TIME: 0
      STATE: update
       INFO: REPLACE INTO `test`.`____tb_test_new` (`id`, `a`, `b`, `c`, `d`, `ptosc`) VALUES (NEW.`id`, NEW.`a`, NEW.`b`, NEW.`c`, NEW.`d`, NEW.`ptosc`)
</code></pre><ul><li>작업 완료 후</li></ul><pre><code>    mysql&gt; show tables;
    +----------------+
    | Tables_in_test |
    +----------------+
    | _tb_test_old   |
    | tb_test        |
    +----------------+
    2 rows in set (0.00 sec)
    
    mysql&gt; show triggers;
    Empty set (0.00 sec)
    
    mysql&gt; desc tb_test;
    +-------+---------------+------+-----+---------+----------------+
    | Field | Type          | Null | Key | Default | Extra          |
    +-------+---------------+------+-----+---------+----------------+
    | id    | int(11)       | NO   | PRI | NULL    | auto_increment |
    | a     | varchar(100)  | YES  |     | NULL    |                |
    | b     | varchar(1001) | YES  |     | NULL    |                |
    | c     | varchar(100)  | YES  |     | NULL    |                |
    | d     | varchar(100)  | YES  |     | NULL    |                |
    | ptosc | int(11)       | NO   |     | 0       |                |
    +-------+---------------+------+-----+---------+----------------+
    6 rows in set (0.00 sec)
</code></pre><p><strong>2. lock 획득 실패로 인한 작업 실패 LOG</strong></p><pre><code>2020-03-19T14:51:59 Dropping triggers...

2020-03-19T14:52:18 Error dropping trigger: 2020-03-19T14:52:18 DBD::mysql::db do failed: Lock wait timeout exceeded; try restarting transaction [for Statement &quot;DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_del`&quot;] at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 11297.

2020-03-19T14:52:37 Error dropping trigger: 2020-03-19T14:52:37 DBD::mysql::db do failed: Lock wait timeout exceeded; try restarting transaction [for Statement &quot;DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_upd`&quot;] at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 11297.

2020-03-19T14:52:56 Error dropping trigger: 2020-03-19T14:52:56 DBD::mysql::db do failed: Lock wait timeout exceeded; try restarting transaction [for Statement &quot;DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_ins`&quot;] at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 11297.

2020-03-19T14:52:56 To try dropping the triggers again, execute:
DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_del`
DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_upd`
DROP TRIGGER IF EXISTS `test`.`pt_osc_test_tb_test_ins`
Not dropping the new table `test`.`___tb_test_new` because --no-drop-new-table was specified.  To drop the new table, execute:
DROP TABLE IF EXISTS `test`.`___tb_test_new`;
</code></pre><p>=> 재수행하려면 생성된 trigger 모두 삭제 필요</p><p><strong>3. max_load=? thread running 대기 LOG</strong></p><pre><code>.
.
.
Altering new table...
Altered `test`.`___tb_test_new` OK.
2020-03-19T23:54:41 Creating triggers...
2020-03-19T23:54:41 Created triggers OK.
2020-03-19T23:54:41 Copying approximately 10686036 rows...
Copying `test`.`tb_test`:  23% 01:35 remain
Copying `test`.`tb_test`:  47% 01:05 remain
Copying `test`.`tb_test`:  71% 00:35 remain

Pausing because Threads_running=100.
Pausing because Threads_running=100.


Copying `test`.`tb_test`:  74% 03:56 remain
Copying `test`.`tb_test`:  96% 00:27 remain
2020-03-20T00:07:00 Copied rows OK.
2020-03-20T00:07:00 Adding original triggers to new table.
</code></pre><p>=> DB 내 session이 max_load 수 만큼 존재하면 pt-osc작업을 일시정지함 session 빠지면 자동 재수행</p><p><strong>4. critical-load=? 설정한 최대 thread 초과로 작업 실패 LOG</strong></p><pre><code>Altering new table...
Altered `test`.`___tb_test_new` OK.
2020-03-20T00:26:13 Creating triggers...
2020-03-20T00:26:13 Created triggers OK.
2020-03-20T00:26:13 Copying approximately 10771088 rows...


Copying `test`.`tb_test`:  23% 01:39 remain
2020-03-20T00:26:47 Dropping triggers...
2020-03-20T00:26:47 Dropped triggers OK.
Not dropping the new table `test`.`___tb_test_new` because --no-drop-new-table was specified.  To drop the new table, execute:
DROP TABLE IF EXISTS `test`.`___tb_test_new`;
`test`.`tb_test` was not altered.

2020-03-20T00:26:47 Error copying rows from `test`.`tb_test` to `test`.`___tb_test_new`: Threads_running=4 exceeds its critical threshold 200
</code></pre><p><strong>6. replication lag 대기 LOG</strong></p><pre><code>Altering new table...
Altered `test`.`_______tb_test_new` OK.
2020-03-20T01:08:52 Creating triggers...
2020-03-20T01:08:52 Created triggers OK.
2020-03-20T01:08:52 Copying approximately 11423307 rows...


Replica lag is 1083 seconds on test-dbatst-t1802.  Waiting.

Replica lag is 1113 seconds on test-dbatst-t1802.  Waiting.
Replica lag is 1262 seconds on test-dbatst-t1802.  Waiting.
Copying `test`.`tb_test`:   0% 14+19:19:46 remain
</code></pre><p><strong>6. 작업 시 charater set error LOG</strong></p><ul><li>ERROR LOG</li></ul><pre><code>    Character set 'utf8mb4' is not a compiled character set and is not specified in the '/usr/share/mysql/charsets/Index.xml' file
    Character set 'utf8mb4' is not a compiled character set and is not specified in the '/usr/share/mysql/charsets/Index.xml' file
    Cannot connect to MySQL: DBI connect('test;mysql_read_default_file=/home/kimdubi/db/mysql/my.cnf;host=127.0.0.1;port=13306;charset=utf8mb4;mysql_read_default_group=client','admin',...) failed: Can't initialize character set utf8mb4 (path: /usr/share/mysql/charsets/) at /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change line 2345
</code></pre><ul><li>utf8 => utf8mb4 로 수정</li></ul><pre><code>    vi /usr/share/mysql/charsets/Index.xml
    
    
    &lt;charset name=&quot;utf8mb4&quot;&gt;
      &lt;family&gt;Unicode&lt;/family&gt;
      &lt;description&gt;UTF-8 Unicode&lt;/description&gt;
      &lt;alias&gt;utf-8&lt;/alias&gt;
      &lt;collation name=&quot;utf8_general_ci&quot;     id=&quot;33&quot;&gt;
       &lt;flag&gt;primary&lt;/flag&gt;
       &lt;flag&gt;compiled&lt;/flag&gt;
      &lt;/collation&gt;
      &lt;collation name=&quot;utf8_bin&quot;            id=&quot;83&quot;&gt;
        &lt;flag&gt;binary&lt;/flag&gt;
        &lt;flag&gt;compiled&lt;/flag&gt;
      &lt;/collation&gt;
    &lt;/charset&gt;
</code></pre><h4 id=chunk-copy-중간-sleep-넣기>chunk copy 중간 sleep 넣기<a hidden class=anchor aria-hidden=true href=#chunk-copy-중간-sleep-넣기>#</a></h4><ul><li>vi /home/kimdubi/db/mysql/util/ptkit/bin/pt-online-schema-change</li></ul><pre><code>     8250 package pt_online_schema_change;
     8251
     8252 use strict;
     8253 use warnings FATAL =&gt; 'all';
     8254 use English qw(-no_match_vars);
     8255
     8256 use Percona::Toolkit;
     8257 use constant PTDEBUG =&gt; $ENV{PTDEBUG} || 0;
     8258
     8259 use List::Util qw(max);
     8260 use Time::HiRes qw(time sleep usleep);
    .
    .
    
    11405 sub exec_nibble {
    11406
    11407    usleep(10000);
    11408    my (%args) = @_;
    11409    my @required_args = qw(Cxn tbl stats tries Retry NibbleIterator Quoter);
    11410    foreach my $arg ( @required_args ) {
    11411       die &quot;I need a $arg argument&quot; unless $args{$arg};
</code></pre><p>=> pt-osc 작업이 서비스 성능에 영향을 준다면 위 처럼 코드를 수정하여 chunk copy 건건 완료 마다 sleep() 하도록 수정</p><h3 id=gh-ost>gh-ost<a hidden class=anchor aria-hidden=true href=#gh-ost>#</a></h3><h4 id=install>INSTALL<a hidden class=anchor aria-hidden=true href=#install>#</a></h4><pre><code>wget https://github.com/github/gh-ost/releases/download/v1.0.49/gh-ost-1.0.49-1.x86_64.rpm
rpm -ivh gh-ost-1.0.49-1.x86_64.rpm
</code></pre><h4 id=동작방식-1>동작방식<a hidden class=anchor aria-hidden=true href=#동작방식-1>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ghost.png alt></p><ul><li>alter 문이 반영 된 ghost table 생성</li><li>PK로 chunk-size 만큼 data copy</li><li>master 서버에서 수행된 DML에 대한 binary log를 ghost table에 반영함<ul><li>binary log를 가져올 서버는 log-bin, binlog-format=ROW 설정 필요</li><li>SLAVE에서 가져오는 경우엔 log_slave_updates 옵션도 추가로 필요함</li></ul></li><li>triggerless 방식<ul><li>trigger로 인한 부하가 없음</li><li>작업 일시정지가 자유로움</li></ul></li><li>org 테이블과 ghost 테이블 swapping</li></ul><h4 id=command-1>COMMAND<a hidden class=anchor aria-hidden=true href=#command-1>#</a></h4><pre><code>gh-ost \
--max-load=Threads_running=100 \
--critical-load=Threads_running=200 \
--chunk-size=1000 \
--throttle-control-replicas=&quot;11.111.11.11:13306&quot; \
--max-lag-millis=500 \
--user=&quot;ghost&quot; \
--password='qhdks123' \
--host=&quot;11.111.11.11&quot; \
--port=13306 \
--database=&quot;test&quot; \
--table=&quot;tb_test&quot; \
--verbose \
--alter=&quot;add column ghost5 int not null default 0&quot; \
--switch-to-rbr \
--allow-master-master \
--allow-on-master \
--assume-master-host=&quot;22.222.22.22:13306&quot; \
--cut-over=default \
--default-retries=120 \
--panic-flag-file=/tmp/ghost.panic.flag \
--postpone-cut-over-flag-file=/tmp/ghost.postpone.flag \
--throttle-flag-file=/tmp/throttle.flag \
--execute
</code></pre><ul><li>host : binary log 를 가져올 서버 설정</li><li>throttle-control-replicas : –max-lag-millis 를 체크할 리플리카 서버 지정하는 옵션</li><li>switch-to-rbr : gh-ost 는 binlog_format=ROW 일 때만 동작하기 때문에 작업 대상 서버의 binlog_format을 ROW로 변경하는 옵션. 주로 Slave의 binlog_format 변경과 log_slave_updates 옵션 설정 후 재기동 수행 (원복 X)</li><li>allow-master-master : MMM 사용할 때 처럼 master-master (active-passive) 구성일 때 설정</li><li>allow-on-master : master에서 작업할 때 설정하는 옵션</li><li>migrate-on-replica : slave 에서 작업할 때 설정하는 옵션 ( 양방향 복제가 아닌 이상 slave에만 작업 적용되므로 참고! )</li><li>assume-master-host : allow-master-master 설정 시 작업할 master 서버 지정하는 옵션</li><li>cut-over : org-table과 gh-ost table 간 swapping하는 migration의 마지막 단계로 atomic 하기 때문에 swapping 도중 실패하는 쿼리는 없음</li><li>panic-flag-file : flag-file 생성 시 작업 취소</li><li>postpone-cut-over-flag-file : flag-file 존재하면 cut-over 단계를 수행하지 않고 대기함 이 옵션 설정 시 작업 시작 할때 이 파일을 생성하기 때문에 마지막 rename 단계 전에 수동으로 삭제해줘야함, 대기하더라도 DML은 계속 copy 진행됨</li><li>throttle-flag-file : throttle-flag-file 존재하면 작업 일시정지</li></ul><h4 id=test-log-1>TEST LOG<a hidden class=anchor aria-hidden=true href=#test-log-1>#</a></h4><p><strong>1. 정상 시나리오</strong></p><pre><code>2020-03-24 11:49:13 INFO starting gh-ost 1.0.49
2020-03-24 11:49:13 INFO Migrating `test`.`tb_test`
2020-03-24 11:49:13 INFO connection validated on 11.111.11.11:13306
2020-03-24 11:49:13 INFO User has SUPER, REPLICATION SLAVE privileges, and has ALL privileges on `test`.*
2020-03-24 11:49:13 INFO binary logs validated on 11.111.11.11:13306
2020-03-24 11:49:13 INFO Restarting replication on 11.111.11.11:13306 to make sure binlog settings apply to replication thread
2020-03-24 11:49:14 INFO Inspector initiated on test-dbatst-t1802:13306, version 8.0.16
2020-03-24 11:49:14 INFO Table found. Engine=InnoDB
2020-03-24 11:49:14 INFO Estimated number of rows via EXPLAIN: 11474891
2020-03-24 11:49:14 INFO Master forced to be 22.222.22.22:13306
2020-03-24 11:49:14 INFO log_slave_updates validated on 11.111.11.11:13306
2020-03-24 11:49:14 INFO connection validated on 11.111.11.11:13306
2020-03-24 11:49:14 INFO Connecting binlog streamer at mysql-bin.000012:638658499
[2020/03/24 11:49:14] [info] binlogsyncer.go:133 create BinlogSyncer with config {99999 mysql 11.111.11.11 13306 ghost    false false &lt;nil&gt; false UTC true 0 0s 0s 0 false}
[2020/03/24 11:49:14] [info] binlogsyncer.go:354 begin to sync binlog from position (mysql-bin.000012, 638658499)
[2020/03/24 11:49:14] [info] binlogsyncer.go:203 register slave for master server 11.111.11.11:13306
2020-03-24 11:49:14 INFO rotate to next log from mysql-bin.000012:0 to mysql-bin.000012
[2020/03/24 11:49:14] [info] binlogsyncer.go:723 rotate to (mysql-bin.000012, 638658499)
2020-03-24 11:49:14 INFO connection validated on 22.222.22.22:13306
2020-03-24 11:49:14 INFO connection validated on 22.222.22.22:13306
2020-03-24 11:49:14 INFO will use time_zone='SYSTEM' on applier
2020-03-24 11:49:14 INFO Examining table structure on applier
2020-03-24 11:49:14 INFO Applier initiated on test-dbatst-t1801:13306, version 8.0.16
</code></pre><p>=> master / slave 파악 및 binary log 가져올 서버(여기선 slave) 와 binlog position 확인</p><pre><code>2020-03-24 11:49:14 INFO Dropping table `test`.`_tb_test_ghc`
2020-03-24 11:49:14 INFO Table dropped
2020-03-24 11:49:14 INFO Creating changelog table `test`.`_tb_test_ghc`
2020-03-24 11:49:14 INFO Changelog table created
2020-03-24 11:49:14 INFO Creating ghost table `test`.`_tb_test_gho`
2020-03-24 11:49:14 INFO Ghost table created
2020-03-24 11:49:14 INFO Altering ghost table `test`.`_tb_test_gho`
2020-03-24 11:49:14 INFO Ghost table altered
</code></pre><p>=> migration 과정을 기록할 _tb_test_ghc 테이블 , 데이터 copy 및 rename 할 _tb_test_gho 임시테이블 생성</p><pre><code>2020-03-24 11:49:14 INFO Created postpone-cut-over-flag-file: /tmp/ghost.postpone.flag
2020-03-24 11:49:14 INFO Waiting for ghost table to be migrated. Current lag is 0s
2020-03-24 11:49:14 INFO Intercepted changelog state GhostTableMigrated
2020-03-24 11:49:14 INFO Handled changelog state GhostTableMigrated
2020-03-24 11:49:14 INFO Chosen shared unique key is PRIMARY
2020-03-24 11:49:14 INFO Shared columns are id,a,b,c,d,ptosc,ghost,ghost2
2020-03-24 11:49:14 INFO Listening on unix socket file: /tmp/gh-ost.test.tb_test.sock
2020-03-24 11:49:14 INFO Migration min values: [1]
2020-03-24 11:49:14 INFO Migration max values: [12404000]
2020-03-24 11:49:14 INFO Waiting for first throttle metrics to be collected
2020-03-24 11:49:14 INFO First throttle metrics collected
# Migrating `test`.`tb_test`; Ghost table is `test`.`_tb_test_gho`
# Migrating test-dbatst-t1801:13306; inspecting test-dbatst-t1802:13306; executing on test-dbatst-t1801
# Migration started at Tue Mar 24 11:49:13 +0900 2020
# chunk-size: 1000; max-lag-millis: 500ms; dml-batch-size: 10; max-load: Threads_running=100; critical-load: Threads_running=200; nice-ratio: 0.000000
# throttle-additional-flag-file: /tmp/gh-ost.throttle
# throttle-control-replicas count: 1
# postpone-cut-over-flag-file: /tmp/ghost.postpone.flag [set]
# panic-flag-file: /tmp/ghost.panic.flag
# Serving on unix socket: /tmp/gh-ost.test.tb_test.sock
</code></pre><p>=> 설정 재확인 및 postpone 파일 생성 (마지막 rename 단계에서 수동으로 지워줘야함)</p><pre><code>Copy: 0/11474891 0.0%; Applied: 0; Backlog: 0/1000; Time: 1s(total), 0s(copy); streamer: mysql-bin.000012:638660757; Lag: 0.01s, State: migrating; ETA: N/A
Copy: 0/11474891 0.0%; Applied: 0; Backlog: 0/1000; Time: 2s(total), 1s(copy); streamer: mysql-bin.000012:638665367; Lag: 0.01s, State: migrating; ETA: N/A
Copy: 87000/11474891 0.8%; Applied: 0; Backlog: 0/1000; Time: 3s(total), 2s(copy); streamer: mysql-bin.000012:645087979; Lag: 0.01s, State: migrating; ETA: 4m21s
Copy: 177000/11474891 1.5%; Applied: 0; Backlog: 0/1000; Time: 4s(total), 3s(copy); streamer: mysql-bin.000012:651809118; Lag: 0.01s, State: migrating; ETA: 3m11s
Copy: 267000/11474891 2.3%; Applied: 0; Backlog: 0/1000; Time: 5s(total), 4s(copy); streamer: mysql-bin.000012:658530259; Lag: 0.01s, State: migrating; ETA: 2m47s
Copy: 357000/11474891 3.1%; Applied: 0; Backlog: 0/1000; Time: 6s(total), 5s(copy); streamer: mysql-bin.000012:665251399; Lag: 0.01s, State: migrating; ETA: 2m35s

.
.
.

Copy: 12404000/12404000 100.0%; Applied: 0; Backlog: 0/1000; Time: 3m30s(total), 2m21s(copy); streamer: mysql-bin.000013:494768124; Lag: 0.01s, State: postponing cut-over; ETA: due
Copy: 12404000/12404000 100.0%; Applied: 0; Backlog: 0/1000; Time: 4m0s(total), 2m21s(copy); streamer: mysql-bin.000013:494892172; Lag: 0.01s, State: postponing cut-over; ETA: due
</code></pre><p>=> org_table에서 tmp table로 data copy</p><pre><code>2020-03-24 11:53:22 INFO Grabbing voluntary lock: gh-ost.160965.lock
2020-03-24 11:53:22 INFO Setting LOCK timeout as 6 seconds
2020-03-24 11:53:22 INFO Looking for magic cut-over table
2020-03-24 11:53:22 INFO Creating magic cut-over table `test`.`_tb_test_del`
2020-03-24 11:53:22 INFO Magic cut-over table created
2020-03-24 11:53:22 INFO Locking `test`.`tb_test`, `test`.`_tb_test_del`
2020-03-24 11:53:22 INFO Tables locked
2020-03-24 11:53:22 INFO Session locking original &amp; magic tables is 160965
2020-03-24 11:53:22 INFO Writing changelog state: AllEventsUpToLockProcessed:1585018402096959497
2020-03-24 11:53:22 INFO Waiting for events up to lock
2020-03-24 11:53:22 INFO Intercepted changelog state AllEventsUpToLockProcessed
2020-03-24 11:53:22 INFO Handled changelog state AllEventsUpToLockProcessed
2020-03-24 11:53:23 INFO Waiting for events up to lock: got AllEventsUpToLockProcessed:1585018402096959497
2020-03-24 11:53:23 INFO Done waiting for events up to lock; duration=983.332503ms
# Migrating `test`.`tb_test`; Ghost table is `test`.`_tb_test_gho`
# Migrating test-dbatst-t1801:13306; inspecting test-dbatst-t1802:13306; executing on test-dbatst-t1801
# Migration started at Tue Mar 24 11:49:13 +0900 2020
# chunk-size: 1000; max-lag-millis: 500ms; dml-batch-size: 10; max-load: Threads_running=100; critical-load: Threads_running=200; nice-ratio: 0.000000
# throttle-additional-flag-file: /tmp/gh-ost.throttle
# throttle-control-replicas count: 1
# postpone-cut-over-flag-file: /tmp/ghost.postpone.flag
# panic-flag-file: /tmp/ghost.panic.flag
# Serving on unix socket: /tmp/gh-ost.test.tb_test.sock
Copy: 12404000/12404000 100.0%; Applied: 0; Backlog: 0/1000; Time: 4m9s(total), 2m21s(copy); streamer: mysql-bin.000013:494931666; Lag: 0.01s, State: migrating; ETA: due
2020-03-24 11:53:23 INFO Setting RENAME timeout as 3 seconds
2020-03-24 11:53:23 INFO Session renaming tables is 160954
2020-03-24 11:53:23 INFO Issuing and expecting this to block: rename /* gh-ost */ table `test`.`tb_test` to `test`.`_tb_test_del`, `test`.`_tb_test_gho` to `test`.`tb_test`
2020-03-24 11:53:23 INFO Found atomic RENAME to be blocking, as expected. Double checking the lock is still in place (though I don't strictly have to)
2020-03-24 11:53:23 INFO Checking session lock: gh-ost.160965.lock
2020-03-24 11:53:23 INFO Connection holding lock on original table still exists
2020-03-24 11:53:23 INFO Will now proceed to drop magic table and unlock tables
2020-03-24 11:53:23 INFO Dropping magic cut-over table
2020-03-24 11:53:23 INFO Releasing lock from `test`.`tb_test`, `test`.`_tb_test_del`
2020-03-24 11:53:23 INFO Tables unlocked
2020-03-24 11:53:23 INFO Tables renamed
2020-03-24 11:53:23 INFO Lock &amp; rename duration: 1.005631871s. During this time, queries on `tb_test` were blocked
2020-03-24 11:53:23 INFO Looking for magic cut-over table
[2020/03/24 11:53:23] [info] binlogsyncer.go:164 syncer is closing...
2020-03-24 11:53:23 INFO Closed streamer connection. err=&lt;nil&gt;
2020-03-24 11:53:23 INFO Dropping table `test`.`_tb_test_ghc`
[2020/03/24 11:53:23] [error] binlogsyncer.go:631 connection was bad
[2020/03/24 11:53:23] [error] binlogstreamer.go:77 close sync with err: Sync was closed
[2020/03/24 11:53:23] [info] binlogsyncer.go:179 syncer is closed
2020-03-24 11:53:23 INFO Table dropped
2020-03-24 11:53:23 INFO Am not dropping old table because I want this operation to be as live as possible. If you insist I should do it, please add `--ok-to-drop-table` next time. But I prefer you do not. To drop the old table, issue:
2020-03-24 11:53:23 INFO -- drop table `test`.`_tb_test_del`
2020-03-24 11:53:23 INFO Done migrating `test`.`tb_test`
2020-03-24 11:53:23 INFO Removing socket file: /tmp/gh-ost.test.tb_test.sock
2020-03-24 11:53:23 INFO Tearing down inspector
2020-03-24 11:53:23 INFO Tearing down applier
2020-03-24 11:53:23 INFO Tearing down streamer
2020-03-24 11:53:23 INFO Tearing down throttler
# Done
</code></pre><p>=> copy 완료 후 rename 및 정리</p><p><strong>2. binlog_format ROW 가 아닐 때</strong></p><pre><code>gh-ost \
--max-load=Threads_running=100 \
--critical-load=Threads_running=200 \
--chunk-size=1000 \
.
.
.

2020-03-24 14:04:13 FATAL 11.111.11.11:13306 has MIXED binlog_format, but I'm too scared to change it to ROW because it has replicas. Bailing out
</code></pre><p>=> binary log 를 가져오려는 Slave 서버가 MIXED format 을 사용하는 경우 –switch-to-rbr 옵션을 통해 Slave의 replication 재기동 및 binlog_format=MIXED 로 변경함 그러나 양방향 복제를 하는 환경에서는 위의 에러로 작업이 실패하기 때문에 수동으로 Slave binlog_format 변경해야함 (dynamic parameter, replication 재기동 필요)</p><p><strong>3. log_slave_updates 안 켰을 때</strong></p><pre><code>2020-03-24 16:30:27 FATAL 11.111.11.11:13306 must have log_slave_updates enabled for executing migration
</code></pre><p>=> slave에서 binary log 를 가져오는 경우 log_slave_updates=ON 이어야함 OFF 설정시 작업실패하며 DB 재기동이 필요한 옵션임</p><p><strong>4. throttle 로 일시정지</strong></p><pre><code>### throttle file 생성 
[kimdubi@test-dbatst-t1801 14:23:32 /tmp ]$ touch /tmp/throttle.flag


### 작업 일시정지
Copy: 1558000/11087382 14.1%; Applied: 0; Backlog: 0/1000; Time: 20s(total), 19s(copy); streamer: mysql-bin.000014:469195727; Lag: 0.01s, State: migrating; ETA: 1m56s
Copy: 1647000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 21s(total), 20s(copy); streamer: mysql-bin.000014:476020512; Lag: 0.01s, State: migrating; ETA: 1m54s
Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 22s(total), 21s(copy); streamer: mysql-bin.000014:476868746; Lag: 0.01s, State: throttled, flag-file; ETA: 1m59s


Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 23s(total), 22s(copy); streamer: mysql-bin.000014:476873383; Lag: 0.01s, State: throttled, flag-file; ETA: 2m5s
Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 24s(total), 23s(copy); streamer: mysql-bin.000014:476878018; Lag: 0.01s, State: throttled, flag-file; ETA: 2m10s
.
.

### throttle 파일 삭제
[kimdubi@test-dbatst-t1801 14:23:43 /tmp ]$ rm /tmp/throttle.flag
rm: remove regular empty file `/tmp/throttle.flag'? y
.
.

### 작업 재개
Copy: 1657000/11087382 14.9%; Applied: 0; Backlog: 0/1000; Time: 1m5s(total), 1m4s(copy); streamer: mysql-bin.000014:477065980; Lag: 0.01s, State: throttled, flag-file; ETA: 6m4s
Copy: 2090000/11087382 18.9%; Applied: 0; Backlog: 0/1000; Time: 1m10s(total), 1m9s(copy); streamer: mysql-bin.000014:510249819; Lag: 0.01s, State: migrating; ETA: 4m57s


Copy: 2535000/11087382 22.9%; Applied: 0; Backlog: 0/1000; Time: 1m15s(total), 1m14s(copy); streamer: mysql-bin.000014:544314297; Lag: 0.01s, State: migrating; ETA: 4m9s
</code></pre><p><strong>5. panic 으로 작업 중단</strong></p><pre><code>### panic 파일 생성
[kimdubi@test-dbatst-t1801 14:25:36 /tmp ]$ touch /tmp/ghost.panic.flag

### 작업 정지
Copy: 7839000/11087382 70.7%; Applied: 0; Backlog: 0/1000; Time: 2m16s(total), 2m15s(copy); streamer: mysql-bin.000014:951100060; Lag: 0.01s, State: migrating; ETA: 55s
2020-03-24 14:25:38 FATAL Found panic-file /tmp/ghost.panic.flag. Aborting without cleanup

### 작업 테이블은 남아있으므로 수동 삭제 필요
mysql&gt; show tables like '%tb_test%';
+----------------------------+
| Tables_in_test (%tb_test%) |
+----------------------------+
| _tb_test_ghc               |
| _tb_test_gho               |
</code></pre><h3 id=공통점>공통점<a hidden class=anchor aria-hidden=true href=#공통점>#</a></h3><ul><li>Table Copy 방식을 사용</li><li>기존 테이블의 row를 chunk 단위로 임시 테이블에 복사</li><li>복사 완료 후 rename table로 임시 테이블을 기존 테이블처럼 사용</li><li>툴을 원격 서버에서 사용 가능</li><li>PK 혹은 Unique key 반드시 필요 (중복없이 chunk 를 나누는 단위)</li></ul><h3 id=차이점>차이점<a hidden class=anchor aria-hidden=true href=#차이점>#</a></h3><table><thead><tr><th></th><th>pt-osc</th><th>gh-ost</th></tr></thead><tbody><tr><td>작업 중 DML 반영 방식</td><td>trigger</td><td>binlog</td></tr><tr><td>binlog_format</td><td>상관없음</td><td>ROW(Mixed안됨)</td></tr><tr><td>log_slave_updates</td><td>상관없음</td><td>master에서 binlog 가져오면 상관없음, slave에서 가져오면 필수</td></tr><tr><td>FK</td><td>지원</td><td>미지원</td></tr><tr><td>trigger</td><td>지원</td><td>미지원</td></tr><tr><td>임의 중단 기능</td><td>미지원</td><td>throttle, panic 옵션으로 지원</td></tr><tr><td>작업 도중 설정 변경</td><td>미지원</td><td>지원 (<a href=https://github.com/github/gh-ost/blob/d2726c77f86cb65e25bce5c0ac5fe3fa0c997488/doc/interactive-commands.md>https://github.com/github/gh-ost/blob/d2726c77f86cb65e25bce5c0ac5fe3fa0c997488/doc/interactive-commands.md</a>)</td></tr><tr><td>작업 수행 서버</td><td>Master</td><td>Master / Slave (&ndash;migrate-on-replica)</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/pt-osc/>pt-osc</a></li><li><a href=/tags/percona/>percona</a></li><li><a href=/tags/ddl/>DDL</a></li><li><a href=/tags/%EC%9A%B4%EC%98%81/>운영</a></li></ul><nav class=paginav><a class=prev href=/mysql/mysql_dump_split/><span class=title>« Prev Page</span><br><span>MySQL mysqldump 테이블별로 쪼개는 법</span></a>
<a class=next href=/mysql/semisync/><span class=title>Next Page »</span><br><span>MySQL lossless semi-sync replication</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>