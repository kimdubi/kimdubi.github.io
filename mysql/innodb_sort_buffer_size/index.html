<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL innodb_sort_buffer_size | kimDuBiA</title><meta name=keywords content="mysql,architecture"><meta name=description content="테스트 목적 innodb_sort_buffer_size 를 크게 잡으면 index 생성 속도에 얼마나 도움이 될까?
online DDL 중 DML 성능 향상에도 도움이 될까?
테스트 환경  5.7.mysql_aurora.2.04.9 r5.2xlarge writer 1대 테스트 대상 테이블 정보   CREATE TABLE `stock1` ( `s_i_id` int(11) NOT NULL, `s_w_id` smallint(6) NOT NULL, `s_quantity` smallint(6) DEFAULT NULL, `s_dist_01` char(24) DEFAULT NULL, `s_dist_02` char(24) DEFAULT NULL, `s_dist_03` char(24) DEFAULT NULL, `s_dist_04` char(24) DEFAULT NULL, `s_dist_05` char(24) DEFAULT NULL, `s_dist_06` char(24) DEFAULT NULL, `s_dist_07` char(24) DEFAULT NULL, `s_dist_08` char(24) DEFAULT NULL, `s_dist_09` char(24) DEFAULT NULL, `s_dist_10` char(24) DEFAULT NULL, `s_ytd` decimal(8,0) DEFAULT NULL, `s_order_cnt` smallint(6) DEFAULT NULL, `s_remote_cnt` smallint(6) DEFAULT NULL, `s_data` varchar(50) DEFAULT NULL, PRIMARY KEY (`s_w_id`,`s_i_id`), KEY `fkey_stock_21` (`s_i_id`), CONSTRAINT `fkey_stock_1_1` FOREIGN KEY (`s_w_id`) REFERENCES `warehouse1` (`w_id`), CONSTRAINT `fkey_stock_2_1` FOREIGN KEY (`s_i_id`) REFERENCES `item1` (`i_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 +-------------+------------+---------------+----------------+ | table_name | table_rows | DATA_SIZE(MB) | INDEX_SIZE(MB) | +-------------+------------+---------------+----------------+ | stock1 | 192659975 | 70237."><meta name=author content="kimdubi"><link rel=canonical href=/mysql/innodb_sort_buffer_size/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL innodb_sort_buffer_size"><meta property="og:description" content="테스트 목적 innodb_sort_buffer_size 를 크게 잡으면 index 생성 속도에 얼마나 도움이 될까?
online DDL 중 DML 성능 향상에도 도움이 될까?
테스트 환경  5.7.mysql_aurora.2.04.9 r5.2xlarge writer 1대 테스트 대상 테이블 정보   CREATE TABLE `stock1` ( `s_i_id` int(11) NOT NULL, `s_w_id` smallint(6) NOT NULL, `s_quantity` smallint(6) DEFAULT NULL, `s_dist_01` char(24) DEFAULT NULL, `s_dist_02` char(24) DEFAULT NULL, `s_dist_03` char(24) DEFAULT NULL, `s_dist_04` char(24) DEFAULT NULL, `s_dist_05` char(24) DEFAULT NULL, `s_dist_06` char(24) DEFAULT NULL, `s_dist_07` char(24) DEFAULT NULL, `s_dist_08` char(24) DEFAULT NULL, `s_dist_09` char(24) DEFAULT NULL, `s_dist_10` char(24) DEFAULT NULL, `s_ytd` decimal(8,0) DEFAULT NULL, `s_order_cnt` smallint(6) DEFAULT NULL, `s_remote_cnt` smallint(6) DEFAULT NULL, `s_data` varchar(50) DEFAULT NULL, PRIMARY KEY (`s_w_id`,`s_i_id`), KEY `fkey_stock_21` (`s_i_id`), CONSTRAINT `fkey_stock_1_1` FOREIGN KEY (`s_w_id`) REFERENCES `warehouse1` (`w_id`), CONSTRAINT `fkey_stock_2_1` FOREIGN KEY (`s_i_id`) REFERENCES `item1` (`i_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 +-------------+------------+---------------+----------------+ | table_name | table_rows | DATA_SIZE(MB) | INDEX_SIZE(MB) | +-------------+------------+---------------+----------------+ | stock1 | 192659975 | 70237."><meta property="og:type" content="article"><meta property="og:url" content="/mysql/innodb_sort_buffer_size/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2021-10-14T07:58:48+09:00"><meta property="article:modified_time" content="2021-10-14T07:58:48+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL innodb_sort_buffer_size"><meta name=twitter:description content="테스트 목적 innodb_sort_buffer_size 를 크게 잡으면 index 생성 속도에 얼마나 도움이 될까?
online DDL 중 DML 성능 향상에도 도움이 될까?
테스트 환경  5.7.mysql_aurora.2.04.9 r5.2xlarge writer 1대 테스트 대상 테이블 정보   CREATE TABLE `stock1` ( `s_i_id` int(11) NOT NULL, `s_w_id` smallint(6) NOT NULL, `s_quantity` smallint(6) DEFAULT NULL, `s_dist_01` char(24) DEFAULT NULL, `s_dist_02` char(24) DEFAULT NULL, `s_dist_03` char(24) DEFAULT NULL, `s_dist_04` char(24) DEFAULT NULL, `s_dist_05` char(24) DEFAULT NULL, `s_dist_06` char(24) DEFAULT NULL, `s_dist_07` char(24) DEFAULT NULL, `s_dist_08` char(24) DEFAULT NULL, `s_dist_09` char(24) DEFAULT NULL, `s_dist_10` char(24) DEFAULT NULL, `s_ytd` decimal(8,0) DEFAULT NULL, `s_order_cnt` smallint(6) DEFAULT NULL, `s_remote_cnt` smallint(6) DEFAULT NULL, `s_data` varchar(50) DEFAULT NULL, PRIMARY KEY (`s_w_id`,`s_i_id`), KEY `fkey_stock_21` (`s_i_id`), CONSTRAINT `fkey_stock_1_1` FOREIGN KEY (`s_w_id`) REFERENCES `warehouse1` (`w_id`), CONSTRAINT `fkey_stock_2_1` FOREIGN KEY (`s_i_id`) REFERENCES `item1` (`i_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 +-------------+------------+---------------+----------------+ | table_name | table_rows | DATA_SIZE(MB) | INDEX_SIZE(MB) | +-------------+------------+---------------+----------------+ | stock1 | 192659975 | 70237."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL innodb_sort_buffer_size","item":"/mysql/innodb_sort_buffer_size/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL innodb_sort_buffer_size","name":"MySQL innodb_sort_buffer_size","description":"테스트 목적 innodb_sort_buffer_size 를 크게 잡으면 index 생성 속도에 얼마나 도움이 될까?\nonline DDL 중 DML 성능 향상에도 도움이 될까?\n테스트 환경  5.7.mysql_aurora.2.04.9 r5.2xlarge writer 1대 테스트 대상 테이블 정보   CREATE TABLE `stock1` ( `s_i_id` int(11) NOT NULL, `s_w_id` smallint(6) NOT NULL, `s_quantity` smallint(6) DEFAULT NULL, `s_dist_01` char(24) DEFAULT NULL, `s_dist_02` char(24) DEFAULT NULL, `s_dist_03` char(24) DEFAULT NULL, `s_dist_04` char(24) DEFAULT NULL, `s_dist_05` char(24) DEFAULT NULL, `s_dist_06` char(24) DEFAULT NULL, `s_dist_07` char(24) DEFAULT NULL, `s_dist_08` char(24) DEFAULT NULL, `s_dist_09` char(24) DEFAULT NULL, `s_dist_10` char(24) DEFAULT NULL, `s_ytd` decimal(8,0) DEFAULT NULL, `s_order_cnt` smallint(6) DEFAULT NULL, `s_remote_cnt` smallint(6) DEFAULT NULL, `s_data` varchar(50) DEFAULT NULL, PRIMARY KEY (`s_w_id`,`s_i_id`), KEY `fkey_stock_21` (`s_i_id`), CONSTRAINT `fkey_stock_1_1` FOREIGN KEY (`s_w_id`) REFERENCES `warehouse1` (`w_id`), CONSTRAINT `fkey_stock_2_1` FOREIGN KEY (`s_i_id`) REFERENCES `item1` (`i_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 +-------------+------------+---------------+----------------+ | table_name | table_rows | DATA_SIZE(MB) | INDEX_SIZE(MB) | +-------------+------------+---------------+----------------+ | stock1 | 192659975 | 70237.","keywords":["mysql","architecture"],"articleBody":"테스트 목적 innodb_sort_buffer_size 를 크게 잡으면 index 생성 속도에 얼마나 도움이 될까?\nonline DDL 중 DML 성능 향상에도 도움이 될까?\n테스트 환경  5.7.mysql_aurora.2.04.9 r5.2xlarge writer 1대 테스트 대상 테이블 정보   CREATE TABLE `stock1` ( `s_i_id` int(11) NOT NULL, `s_w_id` smallint(6) NOT NULL, `s_quantity` smallint(6) DEFAULT NULL, `s_dist_01` char(24) DEFAULT NULL, `s_dist_02` char(24) DEFAULT NULL, `s_dist_03` char(24) DEFAULT NULL, `s_dist_04` char(24) DEFAULT NULL, `s_dist_05` char(24) DEFAULT NULL, `s_dist_06` char(24) DEFAULT NULL, `s_dist_07` char(24) DEFAULT NULL, `s_dist_08` char(24) DEFAULT NULL, `s_dist_09` char(24) DEFAULT NULL, `s_dist_10` char(24) DEFAULT NULL, `s_ytd` decimal(8,0) DEFAULT NULL, `s_order_cnt` smallint(6) DEFAULT NULL, `s_remote_cnt` smallint(6) DEFAULT NULL, `s_data` varchar(50) DEFAULT NULL, PRIMARY KEY (`s_w_id`,`s_i_id`), KEY `fkey_stock_21` (`s_i_id`), CONSTRAINT `fkey_stock_1_1` FOREIGN KEY (`s_w_id`) REFERENCES `warehouse1` (`w_id`), CONSTRAINT `fkey_stock_2_1` FOREIGN KEY (`s_i_id`) REFERENCES `item1` (`i_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 +-------------+------------+---------------+----------------+ | table_name | table_rows | DATA_SIZE(MB) | INDEX_SIZE(MB) | +-------------+------------+---------------+----------------+ | stock1 | 192659975 | 70237.00 | 3991.00 | +-------------+------------+---------------+----------------+ 테스트 대상 파라미터          Command-Line Format –innodb-sort-buffer-size=#   System Variable innodb_sort_buffer_size   Scope Global   Dynamic No   Type Integer   Default Value 1048576   Minimum Value 65536   Maximum Value 67108864     index 생성 시 data sorting 하는 buffer의 크기를 정의하는 파라미터 innodb_sort_buffer에서 sorting 하고 disk로 내려쓰게 되며 buffer의 크기가 커질 수록 merge 횟수가 줄어들어 Disk I/O 등에서 성능 이점이 있음 online DDL 수행 중 발생하는 DML record를 담는 row log buffer 의 extend 단위로도 사용됨\n(row log buffer 는 최대 innodb_online_alter_log_max_size 값만큼 증가할수있음 )  결론  default 1MB로 놓고 쓰자  innodb_sort_buffer_size를 늘리면 인덱스 생성 속도는 아주 조금 향상되나 side effect가 크다\ndefault 1MB에 → 최대값 64MB로 설정하는 건 큰 메리트가 없음. disk와 CPU의 성능이 좋을 수록 그 차이는 더 미비할 것 innodb_sort_buffer_size 를 늘릴 수록 인덱스 여러개를 한꺼번에 생성 했을 때 memory leak으로 보이는 현상이 심함 미세하지만 innodb_sort_buffer_size를 늘릴 수록 오히려 Online DDL 중 DML 성능이 떨어짐    index 생성 소요시간 테스트 default 1MB와 64MB의 차이가 크지 않음, 5%~10% 정도의 성능 차이\n#### innodb_sort_buffer_size = 64KB mysql create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 ); Query OK, 0 rows affected (2 hours 48 min 47.72 sec) Records: 0 Duplicates: 0 Warnings: 0 #### innodb_sort_buffer_size = 1MB mysql create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 ); Query OK, 0 rows affected (2 hours 11 min 13.15 sec) Records: 0 Duplicates: 0 Warnings: 0 #### innodb_sort_buffer_size = 8MB mysql create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 ); Query OK, 0 rows affected (2 hours 8 min 51.46 sec) Records: 0 Duplicates: 0 Warnings: 0 #### innodb_sort_buffer_size = 16MB mysql create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 ); Query OK, 0 rows affected (2 hours 5 min 48.70 sec) Records: 0 Duplicates: 0 Warnings: 0 #### innodb_sort_buffer_size = 32MB mysql create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 ); Query OK, 0 rows affected (2 hours 4 min 59.64 sec) Records: 0 Duplicates: 0 Warnings: 0 #### innodb_sort_buffer_size = 64MB mysql create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 ); Query OK, 0 rows affected (2 hours 4 min 48.03 sec) Records: 0 Duplicates: 0 Warnings: 0 online DDL 중 DML QPS 테스트  alter table stock1 add column test1 varchar(200),algorithm=inplace, lock=none;  위 DDL 수행 중 128 threads, Read 45 % Write 45% Others 10% 비율로 30초간 부하 테스트 7회 수행 후, 뒤의 4회로 평균 산출 유의미한 차이는 아니지만 innodb_buffer_size 가 클수록 오히려 QPS가 떨어지는 결과가 나옴  왜일까,,,,,,, = online DDL 수행 중 발생한 DML 데이터는 row_log_buffer ( innodb_online_alter_log_max_size ) 에 저장됨 이 때 row_log_buffer 는 여러 chunk 단위로 나뉘는데, 그 chunk 단위는 innodb_sort_buffer_size의 크기임 결국 innodb_sort_buffer_size의 크기가 클 수록 row log buffer 내 chunk extend 횟수가 줄어들기 때문에 DML 성능에 이점이 있을 수 있을 것이라고 기대했으나 반대의 결과가 나옴    sort_buffer_size , rnd_buffer_size 같은 버퍼도 일정 값 넘어서 설정하면 효과 없다는데 같은 맥락일듯\n#### NO DDL, DML ONLY queries: 1070494 (35579.24 per sec.) queries: 1079044 (35787.83 per sec.) queries: 1062181 (35277.79 per sec.) queries: 1085398 (35998.80 per sec.) #### innodb_sort_buffer_size = 64K queries: 929224 (30728.81 per sec.) queries: 941740 (31165.30 per sec.) queries: 939693 (31183.89 per sec.) queries: 925846 (30745.61 per sec.) #### innodb_sort_buffer_size = 1M queries: 914122 (30372.16 per sec.) queries: 931132 (30895.06 per sec.) queries: 920218 (30560.92 per sec.) queries: 929405 (30846.84 per sec.) #### innodb_sort_buffer_size = 8M queries: 853290 (28358.40 per sec.) queries: 848449 (28159.97 per sec.) queries: 860407 (28521.78 per sec.) queries: 863537 (28674.37 per sec.) #### innodb_sort_buffer_size = 16M queries: 855897 (28392.20 per sec.) queries: 835787 (27653.29 per sec.) queries: 851361 (28228.19 per sec.) queries: 849894 (28067.34 per sec.) #### innodb_sort_buffer_size = 32M queries: 826788 (27398.12 per sec.) queries: 807663 (26799.70 per sec.) queries: 855277 (28415.28 per sec.) queries: 872884 (28964.68 per sec.) #### innodb_sort_buffer_size = 64M queries: 873414 (27942.96 per sec.) queries: 846271 (28102.47 per sec.) queries: 838817 (27707.62 per sec.) queries: 850687 (28238.55 per sec.) innodb_sort_buffer_size 에 따른 resource 사용량  생성 인덱스 mysql alter table stock1 add index idx01 (s_dist_01), - add index idx02 (s_dist_02), - add index idx03 (s_dist_03), - add index idx04 (s_dist_04), - add index idx05 (s_dist_05), - add index idx06 (s_dist_06), - add index idx07 (s_dist_07), - add index idx08 (s_dist_08), - add index idx09 (s_dist_09), - add index idx10 (s_dist_10); innodb_sort_buffer_size = 1MB innodb_sort_buffer_size = 64MB  innodb_sort_buffer_size = 1MB일 때와 64MB일 때 메모리 사용량 차이가 꽤 많이 나는 것을 볼 수 있음  innodb_sort_buffer_size 가 DDL operation 단위로 할당되기 때문임   tmp files 수치도 한번에 증가함, 11 = 1 + 10 (작업용 임시파일 1개 + index 10개 생성 각각 1개씩)  Created_tmp_tables , Create_tmp_disk_files 지표는 select ,dml 같은 query 처리 시 사용되는 개념으로 본 테스트와는 상관없음 https://dev.mysql.com/doc/refman/8.0/en/internal-temporary-tables.html   USABLE MEMORY 12,600 MB = 10,000 MB = 11,500MB , index 생성 중 2,600MB 사용됐다가 완료 후 1,500MB 반환됨. 일부 반환 안되는 메모리가 있는듯 innodb_sort_buffer_size 사용 공식  (6 /*FTS_NUM_AUX_INDEX*/ * (3*@@GLOBAL.innodb_sort_buffer_size) + 2 * number_of_partitions * number_of_secondary_indexes_created * (@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)*/) * 8 /*64-bit sizeof *buf-tuples*/\") innodb_sort_buffer_size 동작 방식 innodb_sort_buffer_size 크기가 sort \u0026 merge 동작에 어떻게 영향을 주는지 확인해보자\n======== data sort\u0026merge ======== #0 row_merge_tuple_sort (index=0x7f6d200c8590, n_uniq=5, n_field=5, dup=0x0, tuples=0x7f6d202488c0, aux=0x7f6d204488c0, low=0, high=1899) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:986 #1 0x0000000004bab1aa in row_merge_tuple_sort (index=0x7f6d200c8590, n_uniq=5, n_field=5, dup=0x0, tuples=0x7f6d202488c0, aux=0x7f6d204488c0, low=0, high=3799) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:989 #2 0x0000000004bab1aa in row_merge_tuple_sort (index=0x7f6d200c8590, n_uniq=5, n_field=5, dup=0x0, tuples=0x7f6d202488c0, aux=0x7f6d204488c0, low=0, high=7598) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:989 #3 0x0000000004bab43a in row_merge_buf_sort (buf=0x7f6d200c5b50, dup=0x0) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:999 #4 0x0000000004baf16a in row_merge_read_clustered_index (trx=0x7f6e21433078, table=0x7f6d200b8e30, old_table=0x7f6d180f5a80, new_table=0x7f6d180f5a80, online=true, index=0x7f6d200c80a0, fts_sort_idx=0x0, psort_info=0x0, files=0x7f6d200c5a40, key_numbers=0x7f6d200c80c8, n_index=1, add_cols=0x0, add_v=0x0, col_map=0x0, add_autoinc=18446744073709551615, sequence=..., block=0x7f6d0bd00000 \"\", skip_pk_sort=false, tmpfd=0x7f6e1811116c, stage=0x7f6d200c8330, eval_table=0x7f6d200b8e30) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:2271 ======== index 생성을 위한 buffer 할당 등 index 생성 준비 단계 ======== #5 0x0000000004bb34c3 in row_merge_build_indexes (trx=0x7f6e21433078, old_table=0x7f6d180f5a80, new_table=0x7f6d180f5a80, online=true, indexes=0x7f6d200c80a0, key_numbers=0x7f6d200c80c8, n_indexes=1, table=0x7f6d200b8e30, add_cols=0x0, col_map=0x0, add_autoinc=18446744073709551615, sequence=..., skip_pk_sort=false, stage=0x7f6d200c8330, add_v=0x0, eval_table=0x7f6d200b8e30) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:3753 ======== inplace 로 DDL 처리 함수 호출 ======== #6 0x0000000004a34194 in ha_innobase::inplace_alter_table_impl (this=0x7f6d2009c9c8, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, old_dd_tab=0x7f6d18021900, new_dd_tab=0x7f6d20024580) at /MySQL_sources/mysql-8.0.25/storage/innobase/handler/handler0alter.cc:6126 #7 0x0000000004a0e6b5 in ha_innobase::inplace_alter_table (this=0x7f6d2009c9c8, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, old_dd_tab=0x7f6d18021900, new_dd_tab=0x7f6d20024580) at /MySQL_sources/mysql-8.0.25/storage/innobase/handler/handler0alter.cc:1281 #8 0x00000000033bbc41 in handler::ha_inplace_alter_table (this=0x7f6d2009c9c8, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, old_table_def=0x7f6d18021900, new_table_def=0x7f6d20024580) at /MySQL_sources/mysql-8.0.25/sql/handler.h:5859 #9 0x000000000339f1ed in mysql_inplace_alter_table (thd=0x7f6d20006240, schema=..., new_schema=..., table_def=0x7f6d18021900, altered_table_def=0x7f6d20024580, table_list=0x7f6d2002a388, table=0x7f6d20011eb0, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, inplace_supported=HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE, alter_ctx=0x7f6e18112ef0, columns=std::set with 0 elements, fk_key_info=0x7f6d200be118, fk_key_count=0, fk_invalidator=0x7f6e18112e20) at /MySQL_sources/mysql-8.0.25/sql/sql_table.cc:13025 #10 0x00000000033aa8bc in mysql_alter_table (thd=0x7f6d20006240, new_db=0x7f6d2002a9a0 \"testdb\", new_name=0x7f6d20029ff8 \"tb_test\", create_info=0x7f6e18114380, table_list=0x7f6d2002a388, alter_info=0x7f6e18114210) at /MySQL_sources/mysql-8.0.25/sql/sql_table.cc:16924 #11 0x0000000003919803 in Sql_cmd_create_or_drop_index_base::execute (this=0x7f6d2002abe8, thd=0x7f6d20006240) at /MySQL_sources/mysql-8.0.25/sql/sql_cmd_ddl_table.cc:474 ======== thread connect \u0026\u0026 command parsing ======== #12 0x00000000032cdb32 in mysql_execute_command (thd=0x7f6d20006240, first_level=true) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:3426 #13 0x00000000032d2a43 in dispatch_sql_command (thd=0x7f6d20006240, parser_state=0x7f6e18115aa0) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:5000 #14 0x00000000032c93a0 in dispatch_command (thd=0x7f6d20006240, com_data=0x7f6e18116b40, command=COM_QUERY) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:1841 #15 0x00000000032c78f9 in do_command (thd=0x7f6d20006240) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:1320 #16 0x000000000349d601 in handle_connection (arg=0x9602cd0) at /MySQL_sources/mysql-8.0.25/sql/conn_handler/connection_handler_per_thread.cc:301 #17 0x0000000005096688 in pfs_spawn_thread (arg=0xb2f2c60) at /MySQL_sources/mysql-8.0.25/storage/perfschema/pfs.cc:2898 #18 0x00007f6e32f72ea5 in start_thread () from /lib64/libpthread.so.0 #19 0x00007f6e315619fd in clone () from /lib64/libc.so.6  mysqld를 gdb 로 trace를 찍어보면 위처럼 row를 merge\u0026sort 하는 작업이 계속 일어나는 것을 확인할 수 있음 row0merge, row_merge , sort 키워드를 힌트로 debugging 을 계속 진행함  innodb_sort_buffer_size = 1MB T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,0 EOF T@9: row0merge.cc: | | | | | | | | | | row_merge_write T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=0 T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,1 EOF T@9: row0merge.cc: | | | | | | | | | | row_merge_write T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=1048576 T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,2 EOF T@9: row0merge.cc: | | | | | | | | | | row_merge_write T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=2097152 . . . T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,10 EOF T@9: row0merge.cc: | | | | | | | | | | row_merge_write T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=10485760 . . . T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,100 EOF T@9: row0merge.cc: | | | | | | | | | | row_merge_write T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=104857600  index 생성을 위해 데이터 sorting 한 결과를 1MB 씩 처리하는 내부 동작을 확인할 수 있음  [root@1508b86c3e65 tmp]# lsof -p 624 | grep tmp | grep -v sock mysqld 624 root 41u REG 0,154 20971520 3303241 /usr/local/makayal/mysql/tmp/ibKhKV6x (deleted) mysqld 624 root 42u REG 0,154 0 3303242 /usr/local/makayal/mysql/tmp/ibpprcYS (deleted) [root@1508b86c3e65 tmp]# lsof -p 624 | grep tmp | grep -v sock mysqld 624 root 41u REG 0,154 33554432 3303241 /usr/local/makayal/mysql/tmp/ibKhKV6x (deleted) mysqld 624 root 42u REG 0,154 0 3303242 /usr/local/makayal/mysql/tmp/ibpprcYS (deleted) [root@1508b86c3e65 tmp]# lsof -p 624 | grep tmp | grep -v sock mysqld 624 root 41u REG 0,154 42991616 3303241 /usr/local/makayal/mysql/tmp/ibKhKV6x (deleted) mysqld 624 root 42u REG 0,154 0 3303242 /usr/local/makayal/mysql/tmp/ibpprcYS (deleted)  lsof로 mysql의 pid를 잡으면 innodb_tmpdir에 생성된 두개의 temporary file을 확인할 수 있음 index 생성 중에는 두개의 temporary file이 생성됨  하나는 sorting 작업 돌리고 merge 되는 파일, 하나는 앞의 작업 파일을 merge 받는 파일로 innodb_sort_buffer_size 1MB 씩 증가하는 것을 볼 수 있음    innodb_sort_buffer_size = 64MB T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bffff79,41,0 EOF T@7: row0merge.cc: | | | | | | | | | | row_merge_write T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=0 T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bffff79,41,1 EOF T@7: row0merge.cc: | | | | | | | | | | row_merge_write T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=67108864 T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bfffff1,41,2 EOF T@7: row0merge.cc: | | | | | | | | | | row_merge_write T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=134217728 . . . T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bfffff1,41,10 EOF T@7: row0merge.cc: | | | | | | | | | | row_merge_write T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=671088640 innodb_sort_buffer_size = 1MB 일 때와 달리 64MB씩 담아서 merge 하고 있음 [root@1508b86c3e65 tmp]# lsof -p 353 | grep tmp | grep -v sock mysqld 353 root 41u REG 0,154 805306368 3303240 /usr/local/makayal/mysql/tmp/ibd5CxlG (deleted) mysqld 353 root 42u REG 0,154 0 3303241 /usr/local/makayal/mysql/tmp/ibdcmt7k (deleted) [root@1508b86c3e65 tmp]# lsof -p 353 | grep tmp | grep -v sock mysqld 353 root 41u REG 0,154 872415232 3303240 /usr/local/makayal/mysql/tmp/ibd5CxlG (deleted) mysqld 353 root 42u REG 0,154 0 3303241 /usr/local/makayal/mysql/tmp/ibdcmt7k (deleted) [root@1508b86c3e65 tmp]# lsof -p 353 | grep tmp | grep -v sock mysqld 353 root 41u REG 0,154 939524096 3303240 /usr/local/makayal/mysql/tmp/ibd5CxlG (deleted) mysqld 353 root 42u REG 0,154 0 3303241 /usr/local/makayal/mysql/tmp/ibdcmt7k (deleted)  인덱스 생성 중 lsof 로 잡은 temporary file도 64MB 씩 증가하고 있음  ","wordCount":"2139","inLanguage":"en","datePublished":"2021-10-14T07:58:48+09:00","dateModified":"2021-10-14T07:58:48+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/innodb_sort_buffer_size/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL innodb_sort_buffer_size</h1><div class=post-meta>October 14, 2021&nbsp;·&nbsp;11 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%aa%a9%ec%a0%81 aria-label="테스트 목적">테스트 목적</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%99%98%ea%b2%bd aria-label="테스트 환경">테스트 환경</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%8c%80%ec%83%81-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0 aria-label="테스트 대상 파라미터">테스트 대상 파라미터</a></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a><ul><li><a href=#index-%ec%83%9d%ec%84%b1-%ec%86%8c%ec%9a%94%ec%8b%9c%ea%b0%84-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="index 생성 소요시간 테스트">index 생성 소요시간 테스트</a></li><li><a href=#online-ddl-%ec%a4%91-dml-qps-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="online DDL 중 DML QPS 테스트">online DDL 중 DML QPS 테스트</a></li><li><a href=#innodb_sort_buffer_size-%ec%97%90-%eb%94%b0%eb%a5%b8-resource-%ec%82%ac%ec%9a%a9%eb%9f%89 aria-label="innodb_sort_buffer_size 에 따른 resource 사용량 ">innodb_sort_buffer_size 에 따른 resource 사용량 </a><ul><li><a href=#%ec%83%9d%ec%84%b1-%ec%9d%b8%eb%8d%b1%ec%8a%a4 aria-label="생성 인덱스">생성 인덱스</a></li><li><a href=#innodb_sort_buffer_size--1mb aria-label="innodb_sort_buffer_size = 1MB">innodb_sort_buffer_size = 1MB</a></li><li><a href=#innodb_sort_buffer_size--64mb aria-label="innodb_sort_buffer_size = 64MB">innodb_sort_buffer_size = 64MB</a></li></ul></li><li><a href=#innodb_sort_buffer_size-%eb%8f%99%ec%9e%91-%eb%b0%a9%ec%8b%9d aria-label="innodb_sort_buffer_size 동작 방식">innodb_sort_buffer_size 동작 방식</a><ul><li><a href=#innodb_sort_buffer_size--1mb-1 aria-label="innodb_sort_buffer_size = 1MB">innodb_sort_buffer_size = 1MB</a></li><li><a href=#innodb_sort_buffer_size--64mb-1 aria-label="innodb_sort_buffer_size = 64MB">innodb_sort_buffer_size = 64MB</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=테스트-목적>테스트 목적<a hidden class=anchor aria-hidden=true href=#테스트-목적>#</a></h1><p>innodb_sort_buffer_size 를 크게 잡으면 index 생성 속도에 얼마나 도움이 될까?<br>online DDL 중 DML 성능 향상에도 도움이 될까?</p><h1 id=테스트-환경>테스트 환경<a hidden class=anchor aria-hidden=true href=#테스트-환경>#</a></h1><ul><li>5.7.mysql_aurora.2.04.9</li><li>r5.2xlarge writer 1대</li><li>테스트 대상 테이블 정보</li></ul><pre><code> CREATE TABLE `stock1` (
  `s_i_id` int(11) NOT NULL,
  `s_w_id` smallint(6) NOT NULL,
  `s_quantity` smallint(6) DEFAULT NULL,
  `s_dist_01` char(24) DEFAULT NULL,
  `s_dist_02` char(24) DEFAULT NULL,
  `s_dist_03` char(24) DEFAULT NULL,
  `s_dist_04` char(24) DEFAULT NULL,
  `s_dist_05` char(24) DEFAULT NULL,
  `s_dist_06` char(24) DEFAULT NULL,
  `s_dist_07` char(24) DEFAULT NULL,
  `s_dist_08` char(24) DEFAULT NULL,
  `s_dist_09` char(24) DEFAULT NULL,
  `s_dist_10` char(24) DEFAULT NULL,
  `s_ytd` decimal(8,0) DEFAULT NULL,
  `s_order_cnt` smallint(6) DEFAULT NULL,
  `s_remote_cnt` smallint(6) DEFAULT NULL,
  `s_data` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`s_w_id`,`s_i_id`),
  KEY `fkey_stock_21` (`s_i_id`),
  CONSTRAINT `fkey_stock_1_1` FOREIGN KEY (`s_w_id`) REFERENCES `warehouse1` (`w_id`),
  CONSTRAINT `fkey_stock_2_1` FOREIGN KEY (`s_i_id`) REFERENCES `item1` (`i_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4

+-------------+------------+---------------+----------------+
| table_name  | table_rows | DATA_SIZE(MB) | INDEX_SIZE(MB) |
+-------------+------------+---------------+----------------+
| stock1      |  192659975 |      70237.00 |        3991.00 |
+-------------+------------+---------------+----------------+
</code></pre><h1 id=테스트-대상-파라미터>테스트 대상 파라미터<a hidden class=anchor aria-hidden=true href=#테스트-대상-파라미터>#</a></h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Command-Line Format</td><td>&ndash;innodb-sort-buffer-size=#</td></tr><tr><td>System Variable</td><td>innodb_sort_buffer_size</td></tr><tr><td>Scope</td><td>Global</td></tr><tr><td>Dynamic</td><td>No</td></tr><tr><td>Type</td><td>Integer</td></tr><tr><td>Default Value</td><td>1048576</td></tr><tr><td>Minimum Value</td><td>65536</td></tr><tr><td>Maximum Value</td><td>67108864</td></tr></tbody></table><ul><li>index 생성 시 data sorting 하는 buffer의 크기를 정의하는 파라미터</li><li>innodb_sort_buffer에서 sorting 하고 disk로 내려쓰게 되며 buffer의 크기가 커질 수록 merge 횟수가 줄어들어 Disk I/O 등에서 성능 이점이 있음</li><li>online DDL 수행 중 발생하는 DML record를 담는 row log buffer 의 extend 단위로도 사용됨<br>(row log buffer 는 최대 innodb_online_alter_log_max_size 값만큼 증가할수있음 )</li></ul><h1 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h1><ul><li>default 1MB로 놓고 쓰자<ul><li>innodb_sort_buffer_size를 늘리면 인덱스 생성 속도는 아주 조금 향상되나 side effect가 크다<br>default 1MB에 → 최대값 64MB로 설정하는 건 큰 메리트가 없음. disk와 CPU의 성능이 좋을 수록 그 차이는 더 미비할 것</li><li>innodb_sort_buffer_size 를 늘릴 수록 인덱스 여러개를 한꺼번에 생성 했을 때 memory leak으로 보이는 현상이 심함</li><li>미세하지만 innodb_sort_buffer_size를 늘릴 수록 오히려 Online DDL 중 DML 성능이 떨어짐</li></ul></li></ul><h2 id=index-생성-소요시간-테스트>index 생성 소요시간 테스트<a hidden class=anchor aria-hidden=true href=#index-생성-소요시간-테스트>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/innodb_sort_buffer_size_1.png alt></p><p>default 1MB와 64MB의 차이가 크지 않음, 5%~10% 정도의 성능 차이</p><pre><code>#### innodb_sort_buffer_size = 64KB
mysql&gt; create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 );

Query OK, 0 rows affected (2 hours 48 min 47.72 sec)
Records: 0 Duplicates: 0 Warnings: 0


#### innodb_sort_buffer_size = 1MB
mysql&gt; create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 );

Query OK, 0 rows affected (2 hours 11 min 13.15 sec)
Records: 0 Duplicates: 0 Warnings: 0


#### innodb_sort_buffer_size = 8MB
mysql&gt; create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 );

Query OK, 0 rows affected (2 hours 8 min 51.46 sec)
Records: 0 Duplicates: 0 Warnings: 0


#### innodb_sort_buffer_size = 16MB
mysql&gt; create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 );

Query OK, 0 rows affected (2 hours 5 min 48.70 sec)
Records: 0 Duplicates: 0 Warnings: 0


#### innodb_sort_buffer_size = 32MB
mysql&gt; create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 );

Query OK, 0 rows affected (2 hours 4 min 59.64 sec)
Records: 0 Duplicates: 0 Warnings: 0


#### innodb_sort_buffer_size = 64MB
mysql&gt; create index idx_test_01 on stock1 ( s_dist_01, s_dist_02, s_dist_03, s_dist_04, s_dist_05, s_dist_06, s_dist_07, s_dist_08, s_dist_09, s_dist_10 );

Query OK, 0 rows affected (2 hours 4 min 48.03 sec)
Records: 0 Duplicates: 0 Warnings: 0
</code></pre><h2 id=online-ddl-중-dml-qps-테스트>online DDL 중 DML QPS 테스트<a hidden class=anchor aria-hidden=true href=#online-ddl-중-dml-qps-테스트>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/innodb_sort_buffer_size_2.png alt></p><ul><li>alter table stock1 add column test1 varchar(200),algorithm=inplace, lock=none; </li><li>위 DDL 수행 중 128 threads, Read 45 % Write 45% Others 10% 비율로 30초간 부하 테스트 7회 수행 후, 뒤의 4회로 평균 산출</li><li>유의미한 차이는 아니지만 innodb_buffer_size 가 클수록 오히려 QPS가 떨어지는 결과가 나옴 <ul><li>왜일까,,,,,,,
=> online DDL 수행 중 발생한 DML 데이터는 row_log_buffer ( innodb_online_alter_log_max_size ) 에 저장됨
이 때 row_log_buffer 는 여러 chunk 단위로 나뉘는데, 그 chunk 단위는 innodb_sort_buffer_size의 크기임
결국 innodb_sort_buffer_size의 크기가 클 수록 row log buffer 내 chunk extend 횟수가 줄어들기 때문에 DML 성능에 이점이 있을 수 있을 것이라고 기대했으나 반대의 결과가 나옴</li></ul></li></ul><p>sort_buffer_size , rnd_buffer_size 같은 버퍼도 일정 값 넘어서 설정하면 효과 없다는데 같은 맥락일듯</p><pre><code>#### NO DDL, DML ONLY
queries:                             1070494 (35579.24 per sec.)
queries:                             1079044 (35787.83 per sec.)
queries:                             1062181 (35277.79 per sec.)
queries:                             1085398 (35998.80 per sec.)

#### innodb_sort_buffer_size = 64K
queries:                             929224 (30728.81 per sec.)
queries:                             941740 (31165.30 per sec.)
queries:                             939693 (31183.89 per sec.)
queries:                             925846 (30745.61 per sec.)

#### innodb_sort_buffer_size = 1M
queries:                             914122 (30372.16 per sec.)
queries:                             931132 (30895.06 per sec.)
queries:                             920218 (30560.92 per sec.)
queries:                             929405 (30846.84 per sec.)

#### innodb_sort_buffer_size = 8M
queries:                             853290 (28358.40 per sec.)
queries:                             848449 (28159.97 per sec.)
queries:                             860407 (28521.78 per sec.)
queries:                             863537 (28674.37 per sec.)

#### innodb_sort_buffer_size = 16M
queries:                             855897 (28392.20 per sec.)
queries:                             835787 (27653.29 per sec.)
queries:                             851361 (28228.19 per sec.)
queries:                             849894 (28067.34 per sec.)

#### innodb_sort_buffer_size = 32M
queries:                             826788 (27398.12 per sec.)
queries:                             807663 (26799.70 per sec.)
queries:                             855277 (28415.28 per sec.)
queries:                             872884 (28964.68 per sec.)

#### innodb_sort_buffer_size = 64M
queries:                             873414 (27942.96 per sec.)
queries:                             846271 (28102.47 per sec.)
queries:                             838817 (27707.62 per sec.)
queries:                             850687 (28238.55 per sec.)
</code></pre><h2 id=innodb_sort_buffer_size-에-따른-resource-사용량>innodb_sort_buffer_size 에 따른 resource 사용량 <a hidden class=anchor aria-hidden=true href=#innodb_sort_buffer_size-에-따른-resource-사용량>#</a></h2><h3 id=생성-인덱스>생성 인덱스<a hidden class=anchor aria-hidden=true href=#생성-인덱스>#</a></h3><pre><code>mysql&gt; alter table stock1 add index idx01 (s_dist_01),
-&gt; add index idx02 (s_dist_02),
-&gt; add index idx03 (s_dist_03),
-&gt; add index idx04 (s_dist_04),
-&gt; add index idx05 (s_dist_05),
-&gt; add index idx06 (s_dist_06),
-&gt; add index idx07 (s_dist_07),
-&gt; add index idx08 (s_dist_08),
-&gt; add index idx09 (s_dist_09),
-&gt; add index idx10 (s_dist_10);
</code></pre><h3 id=innodb_sort_buffer_size--1mb>innodb_sort_buffer_size = 1MB<a hidden class=anchor aria-hidden=true href=#innodb_sort_buffer_size--1mb>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/innodb_sort_buffer_size_3.png alt></p><h3 id=innodb_sort_buffer_size--64mb>innodb_sort_buffer_size = 64MB<a hidden class=anchor aria-hidden=true href=#innodb_sort_buffer_size--64mb>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/innodb_sort_buffer_size_4.png alt></p><ul><li>innodb_sort_buffer_size = 1MB일 때와 64MB일 때 메모리 사용량 차이가 꽤 많이 나는 것을 볼 수 있음<ul><li>innodb_sort_buffer_size 가 DDL operation 단위로 할당되기 때문임</li></ul></li><li>tmp files 수치도 한번에 증가함, 11 = 1 + 10 (작업용 임시파일 1개 + index 10개 생성 각각 1개씩)<ul><li>Created_tmp_tables , Create_tmp_disk_files 지표는 select ,dml 같은 query 처리 시 사용되는 개념으로 본 테스트와는 상관없음</li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/internal-temporary-tables.html>https://dev.mysql.com/doc/refman/8.0/en/internal-temporary-tables.html</a></li></ul></li><li>USABLE MEMORY 12,600 MB => 10,000 MB => 11,500MB , index 생성 중 2,600MB 사용됐다가 완료 후 1,500MB 반환됨. 일부 반환 안되는 메모리가 있는듯</li><li>innodb_sort_buffer_size 사용 공식</li></ul><pre><code>(6 /*FTS_NUM_AUX_INDEX*/ * (3*@@GLOBAL.innodb_sort_buffer_size) + 2 * number_of_partitions * number_of_secondary_indexes_created * (@@GLOBAL.innodb_sort_buffer_size/dict_index_get_min_size(index)*/) * 8 /*64-bit sizeof *buf-&gt;tuples*/&quot;)
</code></pre><h2 id=innodb_sort_buffer_size-동작-방식>innodb_sort_buffer_size 동작 방식<a hidden class=anchor aria-hidden=true href=#innodb_sort_buffer_size-동작-방식>#</a></h2><p>innodb_sort_buffer_size 크기가 sort & merge 동작에 어떻게 영향을 주는지 확인해보자</p><pre><code>======== data sort&amp;merge ========
#0  row_merge_tuple_sort (index=0x7f6d200c8590, n_uniq=5, n_field=5, dup=0x0, tuples=0x7f6d202488c0, aux=0x7f6d204488c0, low=0, high=1899)
    at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:986
#1  0x0000000004bab1aa in row_merge_tuple_sort (index=0x7f6d200c8590, n_uniq=5, n_field=5, dup=0x0, tuples=0x7f6d202488c0, aux=0x7f6d204488c0, low=0, high=3799)
    at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:989
#2  0x0000000004bab1aa in row_merge_tuple_sort (index=0x7f6d200c8590, n_uniq=5, n_field=5, dup=0x0, tuples=0x7f6d202488c0, aux=0x7f6d204488c0, low=0, high=7598)
    at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:989
#3  0x0000000004bab43a in row_merge_buf_sort (buf=0x7f6d200c5b50, dup=0x0) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:999
#4  0x0000000004baf16a in row_merge_read_clustered_index (trx=0x7f6e21433078, table=0x7f6d200b8e30, old_table=0x7f6d180f5a80, new_table=0x7f6d180f5a80, online=true, index=0x7f6d200c80a0,
    fts_sort_idx=0x0, psort_info=0x0, files=0x7f6d200c5a40, key_numbers=0x7f6d200c80c8, n_index=1, add_cols=0x0, add_v=0x0, col_map=0x0, add_autoinc=18446744073709551615, sequence=...,
    block=0x7f6d0bd00000 &quot;&quot;, skip_pk_sort=false, tmpfd=0x7f6e1811116c, stage=0x7f6d200c8330, eval_table=0x7f6d200b8e30) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:2271


======== index 생성을 위한 buffer 할당 등 index 생성 준비 단계 ========
#5  0x0000000004bb34c3 in row_merge_build_indexes (trx=0x7f6e21433078, old_table=0x7f6d180f5a80, new_table=0x7f6d180f5a80, online=true, indexes=0x7f6d200c80a0, key_numbers=0x7f6d200c80c8,
    n_indexes=1, table=0x7f6d200b8e30, add_cols=0x0, col_map=0x0, add_autoinc=18446744073709551615, sequence=..., skip_pk_sort=false, stage=0x7f6d200c8330, add_v=0x0,
    eval_table=0x7f6d200b8e30) at /MySQL_sources/mysql-8.0.25/storage/innobase/row/row0merge.cc:3753


======== inplace 로 DDL 처리 함수 호출 ========
#6  0x0000000004a34194 in ha_innobase::inplace_alter_table_impl&lt;dd::Table&gt; (this=0x7f6d2009c9c8, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, old_dd_tab=0x7f6d18021900,
    new_dd_tab=0x7f6d20024580) at /MySQL_sources/mysql-8.0.25/storage/innobase/handler/handler0alter.cc:6126
#7  0x0000000004a0e6b5 in ha_innobase::inplace_alter_table (this=0x7f6d2009c9c8, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, old_dd_tab=0x7f6d18021900,
    new_dd_tab=0x7f6d20024580) at /MySQL_sources/mysql-8.0.25/storage/innobase/handler/handler0alter.cc:1281
#8  0x00000000033bbc41 in handler::ha_inplace_alter_table (this=0x7f6d2009c9c8, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, old_table_def=0x7f6d18021900,
    new_table_def=0x7f6d20024580) at /MySQL_sources/mysql-8.0.25/sql/handler.h:5859
#9  0x000000000339f1ed in mysql_inplace_alter_table (thd=0x7f6d20006240, schema=..., new_schema=..., table_def=0x7f6d18021900, altered_table_def=0x7f6d20024580, table_list=0x7f6d2002a388,
    table=0x7f6d20011eb0, altered_table=0x7f6d200b8e30, ha_alter_info=0x7f6e18112010, inplace_supported=HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE, alter_ctx=0x7f6e18112ef0,
    columns=std::set with 0 elements, fk_key_info=0x7f6d200be118, fk_key_count=0, fk_invalidator=0x7f6e18112e20) at /MySQL_sources/mysql-8.0.25/sql/sql_table.cc:13025
#10 0x00000000033aa8bc in mysql_alter_table (thd=0x7f6d20006240, new_db=0x7f6d2002a9a0 &quot;testdb&quot;, new_name=0x7f6d20029ff8 &quot;tb_test&quot;, create_info=0x7f6e18114380, table_list=0x7f6d2002a388,
    alter_info=0x7f6e18114210) at /MySQL_sources/mysql-8.0.25/sql/sql_table.cc:16924
#11 0x0000000003919803 in Sql_cmd_create_or_drop_index_base::execute (this=0x7f6d2002abe8, thd=0x7f6d20006240) at /MySQL_sources/mysql-8.0.25/sql/sql_cmd_ddl_table.cc:474


======== thread connect &amp;&amp; command parsing ========
#12 0x00000000032cdb32 in mysql_execute_command (thd=0x7f6d20006240, first_level=true) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:3426
#13 0x00000000032d2a43 in dispatch_sql_command (thd=0x7f6d20006240, parser_state=0x7f6e18115aa0) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:5000
#14 0x00000000032c93a0 in dispatch_command (thd=0x7f6d20006240, com_data=0x7f6e18116b40, command=COM_QUERY) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:1841
#15 0x00000000032c78f9 in do_command (thd=0x7f6d20006240) at /MySQL_sources/mysql-8.0.25/sql/sql_parse.cc:1320
#16 0x000000000349d601 in handle_connection (arg=0x9602cd0) at /MySQL_sources/mysql-8.0.25/sql/conn_handler/connection_handler_per_thread.cc:301
#17 0x0000000005096688 in pfs_spawn_thread (arg=0xb2f2c60) at /MySQL_sources/mysql-8.0.25/storage/perfschema/pfs.cc:2898
#18 0x00007f6e32f72ea5 in start_thread () from /lib64/libpthread.so.0
#19 0x00007f6e315619fd in clone () from /lib64/libc.so.6
</code></pre><ul><li>mysqld를 gdb 로 trace를 찍어보면 위처럼 row를 merge&sort 하는 작업이 계속 일어나는 것을 확인할 수 있음</li><li>row0merge, row_merge , sort 키워드를 힌트로 debugging 을 계속 진행함</li></ul><h3 id=innodb_sort_buffer_size--1mb-1>innodb_sort_buffer_size = 1MB<a hidden class=anchor aria-hidden=true href=#innodb_sort_buffer_size--1mb-1>#</a></h3><pre><code>T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,0 EOF
T@9: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@9: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=0

T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,1 EOF
T@9: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@9: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=1048576

T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,2 EOF
T@9: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@9: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=2097152
.
.
.
T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,10 EOF
T@9: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@9: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=10485760
.
.
.
T@9: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7fa94c58ffcd,41,100 EOF
T@9: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@9: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@9: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=104857600
</code></pre><ul><li>index 생성을 위해 데이터 sorting 한 결과를 1MB 씩 처리하는 내부 동작을 확인할 수 있음</li></ul><pre><code>[root@1508b86c3e65 tmp]# lsof -p 624 | grep tmp | grep -v sock
mysqld 624 root 41u REG 0,154 20971520 3303241 /usr/local/makayal/mysql/tmp/ibKhKV6x (deleted)
mysqld 624 root 42u REG 0,154 0 3303242 /usr/local/makayal/mysql/tmp/ibpprcYS (deleted)

[root@1508b86c3e65 tmp]# lsof -p 624 | grep tmp | grep -v sock
mysqld 624 root 41u REG 0,154 33554432 3303241 /usr/local/makayal/mysql/tmp/ibKhKV6x (deleted)
mysqld 624 root 42u REG 0,154 0 3303242 /usr/local/makayal/mysql/tmp/ibpprcYS (deleted)

[root@1508b86c3e65 tmp]# lsof -p 624 | grep tmp | grep -v sock
mysqld 624 root 41u REG 0,154 42991616 3303241 /usr/local/makayal/mysql/tmp/ibKhKV6x (deleted)
mysqld 624 root 42u REG 0,154 0 3303242 /usr/local/makayal/mysql/tmp/ibpprcYS (deleted)
</code></pre><ul><li>lsof로 mysql의 pid를 잡으면 innodb_tmpdir에 생성된 두개의 temporary file을 확인할 수 있음</li><li>index 생성 중에는 두개의 temporary file이 생성됨<ul><li>하나는 sorting 작업 돌리고 merge 되는 파일, 하나는 앞의 작업 파일을 merge 받는 파일로 innodb_sort_buffer_size 1MB 씩 증가하는 것을 볼 수 있음</li></ul></li></ul><h3 id=innodb_sort_buffer_size--64mb-1>innodb_sort_buffer_size = 64MB<a hidden class=anchor aria-hidden=true href=#innodb_sort_buffer_size--64mb-1>#</a></h3><pre><code>T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bffff79,41,0 EOF
T@7: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@7: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=0

T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bffff79,41,1 EOF
T@7: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@7: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=67108864

T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bfffff1,41,2 EOF
T@7: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@7: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=134217728
.
.
.

T@7: row0merge.cc: 1038: | | | | | | | | | | | ib_merge_sort: write 0x7f4f9bfffff1,41,10 EOF
T@7: row0merge.cc: | | | | | | | | | | &lt;row_merge_buf_write
T@7: row0merge.cc: 1112: | | | | | | | | | | &gt;row_merge_write
T@7: row0merge.cc: 1113: | | | | | | | | | | | ib_merge_sort: fd=41 ofs=671088640
innodb_sort_buffer_size = 1MB 일 때와 달리 64MB씩 담아서 merge 하고 있음
[root@1508b86c3e65 tmp]# lsof -p 353 | grep tmp | grep -v sock
mysqld 353 root 41u REG 0,154 805306368 3303240 /usr/local/makayal/mysql/tmp/ibd5CxlG (deleted)
mysqld 353 root 42u REG 0,154 0 3303241 /usr/local/makayal/mysql/tmp/ibdcmt7k (deleted)

[root@1508b86c3e65 tmp]# lsof -p 353 | grep tmp | grep -v sock
mysqld 353 root 41u REG 0,154 872415232 3303240 /usr/local/makayal/mysql/tmp/ibd5CxlG (deleted)
mysqld 353 root 42u REG 0,154 0 3303241 /usr/local/makayal/mysql/tmp/ibdcmt7k (deleted)

[root@1508b86c3e65 tmp]# lsof -p 353 | grep tmp | grep -v sock
mysqld 353 root 41u REG 0,154 939524096 3303240 /usr/local/makayal/mysql/tmp/ibd5CxlG (deleted)
mysqld 353 root 42u REG 0,154 0 3303241 /usr/local/makayal/mysql/tmp/ibdcmt7k (deleted)
</code></pre><ul><li>인덱스 생성 중 lsof 로 잡은 temporary file도 64MB 씩 증가하고 있음</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/architecture/>architecture</a></li></ul><nav class=paginav><a class=next href=/mysql/mysqlshell_dump/><span class=title>Next Page »</span><br><span>MySQL Shell을 통한 Table dump&load</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>