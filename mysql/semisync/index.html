<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL lossless semi-sync replication | kimDuBiA</title><meta name=keywords content="mysql,replication,architecture"><meta name=description content="MySQL lossless semi-sync replication MySQL은 ORACLE 과는 HighAvailibility를 충족시키는 방법이 다릅니다.
하나의 스토리지에 데이터를 이중화,삼중화해서 저장하고 이를 여러 인스턴스가 공유하는 ORACLE의 RAC와는 달리
MySQL은 Master-Slave의 개념으로 Master의 데이터를 Slave 서버로 복제하고 MHA나 MMM 같은 솔루션을 통해 Master가 down 되었을 때 실시간으로 복제해둔 Slave를 Master로 승격시키는 방식입니다.
이 방식에는 한가지 문제점이 있는데요.
바로 Slave가 Master의 데이터를 모두 복제하지 못한채로 Master로 승격이 되는 경우입니다.
이 문제점을 해결하기 위해서는 단순하게는 Sync 방식으로 복제를 해오면 되겠지만 Slave에도 반영이 되어야 Master의 트랜잭션도 처리가 된다는 점에서 성능 이슈가 발생할 수 있습니다."><meta name=author content="kimdubi"><link rel=canonical href=/mysql/semisync/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL lossless semi-sync replication"><meta property="og:description" content="MySQL lossless semi-sync replication MySQL은 ORACLE 과는 HighAvailibility를 충족시키는 방법이 다릅니다.
하나의 스토리지에 데이터를 이중화,삼중화해서 저장하고 이를 여러 인스턴스가 공유하는 ORACLE의 RAC와는 달리
MySQL은 Master-Slave의 개념으로 Master의 데이터를 Slave 서버로 복제하고 MHA나 MMM 같은 솔루션을 통해 Master가 down 되었을 때 실시간으로 복제해둔 Slave를 Master로 승격시키는 방식입니다.
이 방식에는 한가지 문제점이 있는데요.
바로 Slave가 Master의 데이터를 모두 복제하지 못한채로 Master로 승격이 되는 경우입니다.
이 문제점을 해결하기 위해서는 단순하게는 Sync 방식으로 복제를 해오면 되겠지만 Slave에도 반영이 되어야 Master의 트랜잭션도 처리가 된다는 점에서 성능 이슈가 발생할 수 있습니다."><meta property="og:type" content="article"><meta property="og:url" content="/mysql/semisync/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2021-10-04T03:39:53+09:00"><meta property="article:modified_time" content="2021-10-04T03:39:53+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL lossless semi-sync replication"><meta name=twitter:description content="MySQL lossless semi-sync replication MySQL은 ORACLE 과는 HighAvailibility를 충족시키는 방법이 다릅니다.
하나의 스토리지에 데이터를 이중화,삼중화해서 저장하고 이를 여러 인스턴스가 공유하는 ORACLE의 RAC와는 달리
MySQL은 Master-Slave의 개념으로 Master의 데이터를 Slave 서버로 복제하고 MHA나 MMM 같은 솔루션을 통해 Master가 down 되었을 때 실시간으로 복제해둔 Slave를 Master로 승격시키는 방식입니다.
이 방식에는 한가지 문제점이 있는데요.
바로 Slave가 Master의 데이터를 모두 복제하지 못한채로 Master로 승격이 되는 경우입니다.
이 문제점을 해결하기 위해서는 단순하게는 Sync 방식으로 복제를 해오면 되겠지만 Slave에도 반영이 되어야 Master의 트랜잭션도 처리가 된다는 점에서 성능 이슈가 발생할 수 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL lossless semi-sync replication","item":"/mysql/semisync/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL lossless semi-sync replication","name":"MySQL lossless semi-sync replication","description":"MySQL lossless semi-sync replication MySQL은 ORACLE 과는 HighAvailibility를 충족시키는 방법이 다릅니다.\n하나의 스토리지에 데이터를 이중화,삼중화해서 저장하고 이를 여러 인스턴스가 공유하는 ORACLE의 RAC와는 달리\nMySQL은 Master-Slave의 개념으로 Master의 데이터를 Slave 서버로 복제하고 MHA나 MMM 같은 솔루션을 통해 Master가 down 되었을 때 실시간으로 복제해둔 Slave를 Master로 승격시키는 방식입니다.\n이 방식에는 한가지 문제점이 있는데요.\n바로 Slave가 Master의 데이터를 모두 복제하지 못한채로 Master로 승격이 되는 경우입니다.\n이 문제점을 해결하기 위해서는 단순하게는 Sync 방식으로 복제를 해오면 되겠지만 Slave에도 반영이 되어야 Master의 트랜잭션도 처리가 된다는 점에서 성능 이슈가 발생할 수 있습니다.","keywords":["mysql","replication","architecture"],"articleBody":"MySQL lossless semi-sync replication MySQL은 ORACLE 과는 HighAvailibility를 충족시키는 방법이 다릅니다.\n하나의 스토리지에 데이터를 이중화,삼중화해서 저장하고 이를 여러 인스턴스가 공유하는 ORACLE의 RAC와는 달리\nMySQL은 Master-Slave의 개념으로 Master의 데이터를 Slave 서버로 복제하고 MHA나 MMM 같은 솔루션을 통해 Master가 down 되었을 때 실시간으로 복제해둔 Slave를 Master로 승격시키는 방식입니다.\n이 방식에는 한가지 문제점이 있는데요.\n바로 Slave가 Master의 데이터를 모두 복제하지 못한채로 Master로 승격이 되는 경우입니다.\n이 문제점을 해결하기 위해서는 단순하게는 Sync 방식으로 복제를 해오면 되겠지만 Slave에도 반영이 되어야 Master의 트랜잭션도 처리가 된다는 점에서 성능 이슈가 발생할 수 있습니다.\n그래서 MySQL은 5.5버전부터 Semi-sync라는 방식을 지원하고 5.7버전에는 lossless semi-sync라는 거창한 이름의 복제방식이 나왔는데요.\n이번 글에서는 이전의 semi-sync와 lossless semi-sync방식의 차이점에 대해 알아보겠습니다.\n기본 설정  sync_binlog = 1 = binlog commit 단계에서 바로 file로 Fsync 처리 innodb_flush_log_at_trx_commit = 1 =engine commit 단계에서 redo log file로 Flush 처리 innodb_support_xa = 1 = 트랜잭션 commit 이 engine prepare - binlog commit - engine commit 으로 2PC commit 으로 수행되게 하여 binlog 와 redo log의 sync를 manage함  semi-sync 5.7 이전 (AFTER_COMMIT)  User transaction commit Engine prepare Binlog flush Binlog commit Engine commit Binlog dump thread send event with ACK Request semi-sync wait (AFTER_COMMIT) User Commit OK  문제점  7번 Slave가 data를 받았다는 응답을 기다리는 도중 Master가 down 된다면?  Master에서는 이미 Engine commit 까지 된 상황이기 때문에 새로 승격될 Slave에는 데이터가 없지만 Old Master에는 데이터가 존재하여 정합성이 깨짐   5번 engine commit 이 된 시점부터 다른 세션에서는 변경된 데이터를 읽을 수 있음 SLAVE로의 복제가 실패하면 이 트랜잭션은 Master에서 수동으로 rollback 처리해야함  lossless semi-sync 5.7 이후 (AFTER_SYNC)  User transaction commit Engine prepare Binlog flush Binlog commit Binlog dump thread send event with ACK Request loss-less semisync wait (AFTER_SYNC) Engine commit User Commit OK   6번 Slave의 응답을 기다리는 도중 Master가 down 되어도 Master에서 engine commit이 처리되지 않았으므로 유실되는 데이터는 없음  5.7 이전 버전(AFTER_COMMIT) 데이터 유실 시나리오 테스트  AFTER_COMMIT 확인   mysql show global variables like 'rpl_semi_sync_master_wait_point'; +---------------------------------+--------------+ | Variable_name | Value | +---------------------------------+--------------+ | rpl_semi_sync_master_wait_point | AFTER_COMMIT | +---------------------------------+--------------+ 1 row in set (0.01 sec)  insert 작업 전 binary log 파일 사이즈 확인   ### master -rw-r----- 1 root root 195 Mar 15 11:37 master-bin.000035 ### slave -rw-r----- 1 root root 315 Mar 15 11:37 slave-relay.000021  insert 수행   ./sysbench --mysql-user=sbtest --mysql-password='qhdks123' --mysql-db=sbtest --mysql-host=localhost --mysql-port=3306 --mysql-socket=/engn001/mysql/data/mysql.sock --threads=10 --time=300 --report-interval=10 /engn001/sysbench-master/share/sysbench/oltp_insert.lua run  sysbench.out \u0026  수행 도중 Master kill   [root@8429d3d8f01b data]# kill -9 298 [root@8429d3d8f01b data]# [1]+ Killed /engn001/mysql/bin/mysqld --defaults-file=/engn001/mysql/my.cnf  insert 작업 후 binary log 파일 사이즈 확인   ### master -rw-r----- 1 root root 3573155 Mar 15 11:38 master-bin.000035 ### slave -rw-r----- 1 root root 3572728 Mar 15 11:38 slave-relay.000021 = 맨 처음 120bytes 이상으로 binary log / relay log 간 사이즈 차이 확인\n 데이터 확인   ### master mysql select max(id) from sbtest1; +---------+ | max(id) | +---------+ | 13000 | +---------+ 1 row in set (0.00 sec) ### slave mysql select max(id) from sbtest1; +---------+ | max(id) | +---------+ | 12999 | +---------+ 1 row in set (0.00 sec) = 데이터 유실 발생\n5.7 이후 (AFTER_SYNC) 테스트  AFTER_SYNC 확인   mysql show global variables like 'rpl_semi_sync_master_wait_point'; +---------------------------------+--------------+ | Variable_name | Value | +---------------------------------+--------------+ | rpl_semi_sync_master_wait_point | AFTER_SYNC | +---------------------------------+--------------+ 1 row in set (0.01 sec)  insert 작업 전 binary log 파일 사이즈 확인   ### master -rw-r----- 1 root root 195 Mar 15 11:26 master-bin.000033 ### slave -rw-r----- 1 root root 315 Mar 15 11:26 slave-relay.000017  insert 수행   ./sysbench --mysql-user=sbtest --mysql-password='qhdks123' --mysql-db=sbtest --mysql-host=localhost --mysql-port=3306 --mysql-socket=/engn001/mysql/data/mysql.sock --tables=5 --threads=10 --time=300 --report-interval=10 /engn001/sysbench-master/share/sysbench/oltp_insert.lua run  sysbench.out \u0026  수행 도중 Master kill   [root@8429d3d8f01b data]# kill -9 296 [root@8429d3d8f01b data]# [1]+ Killed /engn001/mysql/bin/mysqld --defaults-file=/engn001/mysql/my.cnf  insert 작업 후 binary log 파일 사이즈 확인   ### master -rw-r----- 1 root root 3515364 Mar 15 11:38 master-bin.000033 ### slave -rw-r----- 1 root root 3515484 Mar 15 11:38 slave-relay.000017 = 초기 binary / relay log file 120bytes 만큼만 차이남\n 데이터 확인   ### master mysql select max(id) from sbtest1; +---------+ | max(id) | +---------+ | 10840 | +---------+ 1 row in set (0.00 sec) ### slave mysql select max(id) from sbtest1; +---------+ | max(id) | +---------+ | 10840 | +---------+ 1 row in set (0.00 sec) 결론 AFTER_COMMIT 방식을 사용하는 5.7 이전의 semi-sync는 Slave로부터 ACK를 받기도 전에 engine commit을 처리하기 때문에 도중에 Master가 crash 되면 Slave data 유실 되는 케이스가 종종 발생합니다.\n이를 AFTER_SYNC 방식의 lossless semi-sync 로 변경하면 Slave로 부터 ACK를 받은 후 engine commit이 발생하기 때문에 Slave의 data 유실이 발생하지 않습니다.\nhttps://percona.community/blog/2018/08/23/question-about-semi-synchronous-replication-answer-with-all-the-details/\n","wordCount":"704","inLanguage":"en","datePublished":"2021-10-04T03:39:53+09:00","dateModified":"2021-10-04T03:39:53+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/semisync/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL lossless semi-sync replication</h1><div class=post-meta>October 4, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mysql-lossless-semi-sync-replication aria-label="MySQL lossless semi-sync replication">MySQL lossless semi-sync replication</a></li><li><a href=#%ea%b8%b0%eb%b3%b8-%ec%84%a4%ec%a0%95 aria-label="기본 설정">기본 설정</a></li><li><a href=#semi-sync-57-%ec%9d%b4%ec%a0%84-after_commit aria-label="semi-sync 5.7 이전 (AFTER_COMMIT)">semi-sync 5.7 이전 (AFTER_COMMIT)</a><ul><li><a href=#%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label=문제점>문제점</a></li></ul></li><li><a href=#lossless-semi-sync-57-%ec%9d%b4%ed%9b%84-after_sync aria-label="lossless semi-sync 5.7 이후 (AFTER_SYNC)">lossless semi-sync 5.7 이후 (AFTER_SYNC)</a></li><li><a href=#57-%ec%9d%b4%ec%a0%84-%eb%b2%84%ec%a0%84after_commit-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%9c%a0%ec%8b%a4-%ec%8b%9c%eb%82%98%eb%a6%ac%ec%98%a4-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="5.7 이전 버전(AFTER_COMMIT) 데이터 유실 시나리오 테스트">5.7 이전 버전(AFTER_COMMIT) 데이터 유실 시나리오 테스트</a></li><li><a href=#57-%ec%9d%b4%ed%9b%84-after_sync-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="5.7 이후 (AFTER_SYNC) 테스트">5.7 이후 (AFTER_SYNC) 테스트</a><ul><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=mysql-lossless-semi-sync-replication>MySQL lossless semi-sync replication<a hidden class=anchor aria-hidden=true href=#mysql-lossless-semi-sync-replication>#</a></h2><p>MySQL은 ORACLE 과는 HighAvailibility를 충족시키는 방법이 다릅니다.<br>하나의 스토리지에 데이터를 이중화,삼중화해서 저장하고 이를 여러 인스턴스가 공유하는 ORACLE의 RAC와는 달리<br>MySQL은 Master-Slave의 개념으로 Master의 데이터를 Slave 서버로 복제하고 MHA나 MMM 같은 솔루션을 통해 Master가 down 되었을 때 실시간으로 복제해둔 Slave를 Master로 승격시키는 방식입니다.<br>이 방식에는 한가지 문제점이 있는데요.<br>바로 Slave가 Master의 데이터를 모두 복제하지 못한채로 Master로 승격이 되는 경우입니다.<br>이 문제점을 해결하기 위해서는 단순하게는 Sync 방식으로 복제를 해오면 되겠지만 Slave에도 반영이 되어야 Master의 트랜잭션도 처리가 된다는 점에서 성능 이슈가 발생할 수 있습니다.<br>그래서 MySQL은 5.5버전부터 Semi-sync라는 방식을 지원하고 5.7버전에는 lossless semi-sync라는 거창한 이름의 복제방식이 나왔는데요.<br>이번 글에서는 이전의 semi-sync와 lossless semi-sync방식의 차이점에 대해 알아보겠습니다.</p><h2 id=기본-설정>기본 설정<a hidden class=anchor aria-hidden=true href=#기본-설정>#</a></h2><ul><li>sync_binlog = 1 => binlog commit 단계에서 바로 file로 Fsync 처리</li><li>innodb_flush_log_at_trx_commit = 1 =>engine commit 단계에서 redo log file로 Flush 처리</li><li>innodb_support_xa = 1 => 트랜잭션 commit 이 engine prepare - binlog commit - engine commit 으로 2PC commit 으로 수행되게 하여 binlog 와 redo log의 sync를 manage함</li></ul><h2 id=semi-sync-57-이전-after_commit>semi-sync 5.7 이전 (AFTER_COMMIT)<a hidden class=anchor aria-hidden=true href=#semi-sync-57-이전-after_commit>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/after_commit.png alt></p><ol><li>User transaction commit</li><li>Engine prepare</li><li>Binlog flush</li><li>Binlog commit</li><li>Engine commit</li><li>Binlog dump thread send event with ACK Request</li><li>semi-sync wait (AFTER_COMMIT)</li><li>User Commit OK</li></ol><h3 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h3><ul><li>7번 Slave가 data를 받았다는 응답을 기다리는 도중 Master가 down 된다면?<ul><li>Master에서는 이미 Engine commit 까지 된 상황이기 때문에 새로 승격될 Slave에는 데이터가 없지만 Old Master에는 데이터가 존재하여 정합성이 깨짐</li></ul></li><li>5번 engine commit 이 된 시점부터 다른 세션에서는 변경된 데이터를 읽을 수 있음 SLAVE로의 복제가 실패하면 이 트랜잭션은 Master에서 수동으로 rollback 처리해야함</li></ul><h2 id=lossless-semi-sync-57-이후-after_sync>lossless semi-sync 5.7 이후 (AFTER_SYNC)<a hidden class=anchor aria-hidden=true href=#lossless-semi-sync-57-이후-after_sync>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/after_sync.png alt></p><ol><li>User transaction commit</li><li>Engine prepare</li><li>Binlog flush</li><li>Binlog commit</li><li>Binlog dump thread send event with ACK Request</li><li>loss-less semisync wait (AFTER_SYNC)</li><li>Engine commit</li><li>User Commit OK</li></ol><ul><li>6번 Slave의 응답을 기다리는 도중 Master가 down 되어도 Master에서 engine commit이 처리되지 않았으므로 유실되는 데이터는 없음</li></ul><h2 id=57-이전-버전after_commit-데이터-유실-시나리오-테스트>5.7 이전 버전(AFTER_COMMIT) 데이터 유실 시나리오 테스트<a hidden class=anchor aria-hidden=true href=#57-이전-버전after_commit-데이터-유실-시나리오-테스트>#</a></h2><ul><li>AFTER_COMMIT 확인</li></ul><pre><code>    mysql&gt; show global variables like 'rpl_semi_sync_master_wait_point';
    +---------------------------------+--------------+
    | Variable_name                   | Value        |
    +---------------------------------+--------------+
    | rpl_semi_sync_master_wait_point | AFTER_COMMIT |
    +---------------------------------+--------------+
    1 row in set (0.01 sec)
</code></pre><ul><li>insert 작업 전 binary log 파일 사이즈 확인</li></ul><pre><code>    ### master
    -rw-r----- 1 root root       195 Mar 15 11:37 master-bin.000035
    
    ### slave
    -rw-r----- 1 root root       315 Mar 15 11:37 slave-relay.000021
</code></pre><ul><li>insert 수행</li></ul><pre><code>    ./sysbench --mysql-user=sbtest --mysql-password='qhdks123' --mysql-db=sbtest --mysql-host=localhost --mysql-port=3306 --mysql-socket=/engn001/mysql/data/mysql.sock --threads=10 --time=300 --report-interval=10 /engn001/sysbench-master/share/sysbench/oltp_insert.lua run &gt; sysbench.out &amp;
</code></pre><ul><li>수행 도중 Master kill</li></ul><pre><code>    [root@8429d3d8f01b data]# kill -9 298
    [root@8429d3d8f01b data]#
    [1]+  Killed                  /engn001/mysql/bin/mysqld --defaults-file=/engn001/mysql/my.cnf
</code></pre><ul><li>insert 작업 후 binary log 파일 사이즈 확인</li></ul><pre><code>    ### master
    -rw-r----- 1 root root   3573155 Mar 15 11:38 master-bin.000035
    
    ### slave
    -rw-r----- 1 root root   3572728 Mar 15 11:38 slave-relay.000021
</code></pre><p>=> 맨 처음 120bytes 이상으로 binary log / relay log 간 사이즈 차이 확인</p><ul><li>데이터 확인</li></ul><pre><code>    ### master
    mysql&gt; select max(id) from sbtest1;
    +---------+
    | max(id) |
    +---------+
    |   13000 |
    +---------+
    1 row in set (0.00 sec)
    
    ### slave
    
    mysql&gt; select max(id) from sbtest1;
    +---------+
    | max(id) |
    +---------+
    |   12999 |
    +---------+
    1 row in set (0.00 sec)
</code></pre><p>=> 데이터 유실 발생</p><h2 id=57-이후-after_sync-테스트>5.7 이후 (AFTER_SYNC) 테스트<a hidden class=anchor aria-hidden=true href=#57-이후-after_sync-테스트>#</a></h2><ul><li>AFTER_SYNC 확인</li></ul><pre><code>    mysql&gt; show global variables like 'rpl_semi_sync_master_wait_point';
    +---------------------------------+--------------+
    | Variable_name                   | Value        |
    +---------------------------------+--------------+
    | rpl_semi_sync_master_wait_point | AFTER_SYNC   |
    +---------------------------------+--------------+
    1 row in set (0.01 sec)
</code></pre><ul><li>insert 작업 전 binary log 파일 사이즈 확인</li></ul><pre><code>    ### master
    -rw-r----- 1 root root       195 Mar 15 11:26 master-bin.000033
    
    ### slave
    -rw-r----- 1 root root       315 Mar 15 11:26 slave-relay.000017
</code></pre><ul><li>insert 수행</li></ul><pre><code>    ./sysbench --mysql-user=sbtest --mysql-password='qhdks123' --mysql-db=sbtest --mysql-host=localhost --mysql-port=3306 --mysql-socket=/engn001/mysql/data/mysql.sock --tables=5 --threads=10 --time=300 --report-interval=10 /engn001/sysbench-master/share/sysbench/oltp_insert.lua run &gt; sysbench.out &amp;
</code></pre><ul><li>수행 도중 Master kill</li></ul><pre><code>    [root@8429d3d8f01b data]# kill -9 296
    [root@8429d3d8f01b data]#
    [1]+  Killed                  /engn001/mysql/bin/mysqld --defaults-file=/engn001/mysql/my.cnf
</code></pre><ul><li>insert 작업 후 binary log 파일 사이즈 확인</li></ul><pre><code>    ### master
    -rw-r----- 1 root root   3515364 Mar 15 11:38 master-bin.000033
    
    ### slave
    -rw-r----- 1 root root   3515484 Mar 15 11:38 slave-relay.000017
</code></pre><p>=> 초기 binary / relay log file 120bytes 만큼만 차이남</p><ul><li>데이터 확인</li></ul><pre><code>    ### master
    mysql&gt; select max(id) from sbtest1;
    +---------+
    | max(id) |
    +---------+
    |   10840 |
    +---------+
    1 row in set (0.00 sec)
    
    ### slave
    
    mysql&gt; select max(id) from sbtest1;
    +---------+
    | max(id) |
    +---------+
    |  10840  |
    +---------+
    1 row in set (0.00 sec)
</code></pre><h3 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h3><p>AFTER_COMMIT 방식을 사용하는 5.7 이전의 semi-sync는 Slave로부터 ACK를 받기도 전에 engine commit을 처리하기 때문에 도중에 Master가 crash 되면 Slave data 유실 되는 케이스가 종종 발생합니다.<br>이를 AFTER_SYNC 방식의 lossless semi-sync 로 변경하면 Slave로 부터 ACK를 받은 후 engine commit이 발생하기 때문에 Slave의 data 유실이 발생하지 않습니다.</p><p><a href=https://percona.community/blog/2018/08/23/question-about-semi-synchronous-replication-answer-with-all-the-details/>https://percona.community/blog/2018/08/23/question-about-semi-synchronous-replication-answer-with-all-the-details/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/replication/>replication</a></li><li><a href=/tags/architecture/>architecture</a></li></ul><nav class=paginav><a class=prev href=/mysql/online_schema_change/><span class=title>« Prev Page</span><br><span>MySQL online DDL을 위한 TOOL 비교 ( pt-osc & gh-ost )</span></a>
<a class=next href=/mysql/xtrabackup8_info/><span class=title>Next Page »</span><br><span>Xtrabackup8.0 잡다구리 정보</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>