<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes에서 redis cluster를 돌려보자 - Service | kimDuBiA</title><meta name=keywords content="kubernetes,redis"><meta name=description content="Service? Service 개념  Pod는 deployment, replicaset, statefulset 같은 controller에 의해 관리되기 때문에 새로 생겨나거나 없어지기도 하고 한 Node에만 떠있는 게 아니라 여러 Node를 옮겨다닐 수 있음 Pod는 이렇듯 동적으로 변하여 고정된 endpoint로의 호출이 어려운데 (Pod의 IP,hostname이 변하니까 ) 이러한 이슈를 해결하기 위한 오브젝트가 Service임 Client는 클러스터 안에서 Pod IP가 바뀌던 없어지건 새로 생기건 신경쓸 필요 없이 Service만 바라보면 고정된 endpoint로 접근이 가능함 Service는 크게 아래와 같이 네가지 Type으로 나뉨  ClusterIp : kubernets cluster 내부에서 사용하는 service."><meta name=author content="kimdubi"><link rel=canonical href=/cloud/k8s_redis_cluster_service/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><link rel=preload href=/apple-touch-icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="Kubernetes에서 redis cluster를 돌려보자 - Service"><meta property="og:description" content="Service? Service 개념  Pod는 deployment, replicaset, statefulset 같은 controller에 의해 관리되기 때문에 새로 생겨나거나 없어지기도 하고 한 Node에만 떠있는 게 아니라 여러 Node를 옮겨다닐 수 있음 Pod는 이렇듯 동적으로 변하여 고정된 endpoint로의 호출이 어려운데 (Pod의 IP,hostname이 변하니까 ) 이러한 이슈를 해결하기 위한 오브젝트가 Service임 Client는 클러스터 안에서 Pod IP가 바뀌던 없어지건 새로 생기건 신경쓸 필요 없이 Service만 바라보면 고정된 endpoint로 접근이 가능함 Service는 크게 아래와 같이 네가지 Type으로 나뉨  ClusterIp : kubernets cluster 내부에서 사용하는 service."><meta property="og:type" content="article"><meta property="og:url" content="/cloud/k8s_redis_cluster_service/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="cloud"><meta property="article:published_time" content="2021-10-06T17:58:13+09:00"><meta property="article:modified_time" content="2021-10-06T17:58:13+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kubernetes에서 redis cluster를 돌려보자 - Service"><meta name=twitter:description content="Service? Service 개념  Pod는 deployment, replicaset, statefulset 같은 controller에 의해 관리되기 때문에 새로 생겨나거나 없어지기도 하고 한 Node에만 떠있는 게 아니라 여러 Node를 옮겨다닐 수 있음 Pod는 이렇듯 동적으로 변하여 고정된 endpoint로의 호출이 어려운데 (Pod의 IP,hostname이 변하니까 ) 이러한 이슈를 해결하기 위한 오브젝트가 Service임 Client는 클러스터 안에서 Pod IP가 바뀌던 없어지건 새로 생기건 신경쓸 필요 없이 Service만 바라보면 고정된 endpoint로 접근이 가능함 Service는 크게 아래와 같이 네가지 Type으로 나뉨  ClusterIp : kubernets cluster 내부에서 사용하는 service."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Clouds","item":"/cloud/"},{"@type":"ListItem","position":3,"name":"Kubernetes에서 redis cluster를 돌려보자 - Service","item":"/cloud/k8s_redis_cluster_service/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes에서 redis cluster를 돌려보자 - Service","name":"Kubernetes에서 redis cluster를 돌려보자 - Service","description":"Service? Service 개념  Pod는 deployment, replicaset, statefulset 같은 controller에 의해 관리되기 때문에 새로 생겨나거나 없어지기도 하고 한 Node에만 떠있는 게 아니라 여러 Node를 옮겨다닐 수 있음 Pod는 이렇듯 동적으로 변하여 고정된 endpoint로의 호출이 어려운데 (Pod의 IP,hostname이 변하니까 ) 이러한 이슈를 해결하기 위한 오브젝트가 Service임 Client는 클러스터 안에서 Pod IP가 바뀌던 없어지건 새로 생기건 신경쓸 필요 없이 Service만 바라보면 고정된 endpoint로 접근이 가능함 Service는 크게 아래와 같이 네가지 Type으로 나뉨  ClusterIp : kubernets cluster 내부에서 사용하는 service.","keywords":["kubernetes","redis"],"articleBody":" Service? Service 개념  Pod는 deployment, replicaset, statefulset 같은 controller에 의해 관리되기 때문에 새로 생겨나거나 없어지기도 하고 한 Node에만 떠있는 게 아니라 여러 Node를 옮겨다닐 수 있음 Pod는 이렇듯 동적으로 변하여 고정된 endpoint로의 호출이 어려운데 (Pod의 IP,hostname이 변하니까 ) 이러한 이슈를 해결하기 위한 오브젝트가 Service임 Client는 클러스터 안에서 Pod IP가 바뀌던 없어지건 새로 생기건 신경쓸 필요 없이 Service만 바라보면 고정된 endpoint로 접근이 가능함 Service는 크게 아래와 같이 네가지 Type으로 나뉨  ClusterIp : kubernets cluster 내부에서 사용하는 service. 외부에선 접근할 수 없음 LoadBalancer : 토클,aws,gcp 등 퍼블릭 클라우드 서비스를 이용할 때 사용가능한 type으로 loadbalancer의 IP를 이용하여 외부에서 접근가능함 NodePort : kubernetes cluster의 각 노드의 지정된 port를 service에 할당함. node의 port를 이용하기 때문에 외부에서도 접근가능함 ExternalName : kubernetes cluster 내부에서 외부로 접근하는 경우 사용, Service를 ExternalName 으로 설정하여 CNAME을 타고 외부로 접근함   이 글에서 다루는 redis-cluster 에서는 ClusterIP type의 service를 사용하고 있음 ( DB는 내부통신만 하면 되니까)  Service 사용현황 $ kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kimdubi-test-redis-cluster ClusterIP 10.254.8.60  6379/TCP 6d kimdubi-test-redis-cluster-headless ClusterIP None  6379/TCP,16379/TCP 6d kubernetes ClusterIP 10.254.0.1  443/TCP 6d1h   kubernetes cluster 내부에서 Pod 간 연결을 위해 사용하는 ClusterIP type의 kimdubi-test-redis-cluster 라는 이름의 service ClusterIP type이지만 IP가 설정되지 않은 kimdubi-test-redis-cluster-headless 라는 이름의 service, headless service라고 함 두개의 service가 생성되었지만 실제로는 kimdubi-test-redis-cluster-headless 서비스가 사용됨  headless service란?  kimdubi-test-redis-cluster 같은 보통의 service는 받은 요청을 매핑된 Pod들에게 loadbalancing 형태로 뿌려주는데 이는 stateless 한 web server 처럼, 어떤 web server로 요청이 가도 동일한 결과를 내는 구조에서 의미가 있음  DB처럼 Master / Slave 같은 stateful 한 구성에서는 loadbalancing 형태로 뿌려주는 게 아니라 Master 인지 Slave인지 파악하여 특정한 Pod에 요청을 뿌려줘야함 이처럼 loadbalancing이 필요없고 client 에서 모든 Pod에 접근해야하는 구성에서는 headless service를 사용하며 아래와 같은 특징이 있음  headless service는 IP 대신 dns 를 가짐 headless service의 dns에 대해 nslookup을 수행하면 binding 된 모든 Pod들의 IP를 return 함 Client는 return 받은 모든 Pod의 IP를 통해 원하는 Pod 에 직접 접근할 수 있음    # nslookup kimdubi-test-redis-cluster-headless Server:\t10.254.0.10 Address:\t10.254.0.10#53 Name:\tkimdubi-test-redis-cluster-headless.default.svc.cluster.local Address: 10.100.71.3 Name:\tkimdubi-test-redis-cluster-headless.default.svc.cluster.local Address: 10.100.14.7 Name:\tkimdubi-test-redis-cluster-headless.default.svc.cluster.local Address: 10.100.79.12 Name:\tkimdubi-test-redis-cluster-headless.default.svc.cluster.local Address: 10.100.14.8 Name:\tkimdubi-test-redis-cluster-headless.default.svc.cluster.local Address: 10.100.79.11 Name:\tkimdubi-test-redis-cluster-headless.default.svc.cluster.local Address: 10.100.71.4 = kimdubi-test-redis-cluster-headless service에 대해 nslookup 수행 이 service에 binding 된 모든 Pod의 IP를 return 받음\nService 생성 template을 살펴보자 kimdubi-test-redis-cluster $ kubectl get service kimdubi-test-redis-cluster -o yaml apiVersion: v1 kind: Service metadata: annotations: meta.helm.sh/release-name: kimdubi-test meta.helm.sh/release-namespace: default creationTimestamp: \"2021-02-21T07:33:55Z\" labels: app.kubernetes.io/instance: kimdubi-test app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: redis-cluster helm.sh/chart: redis-cluster-4.3.0 name: kimdubi-test-redis-cluster namespace: default resourceVersion: \"24613\" selfLink: /api/v1/namespaces/default/services/kimdubi-test-redis-cluster uid: c7a73d74-a532-4689-8d9e-45287df887b3 spec: clusterIP: 10.254.8.60 ports: - name: tcp-redis port: 6379 protocol: TCP targetPort: tcp-redis selector: app.kubernetes.io/instance: kimdubi-test app.kubernetes.io/name: redis-cluster sessionAffinity: None type: ClusterIP status: loadBalancer: {}  .spec.clusterIP  clusterIP type으로 생성된 service를 지정한 IP로 생성되도록 설정 이 service는 10.254.8.60 IP를 할당받게됨  .spec.ports[]  해당 서비스의 label selector 에 매치되는 Pod의 특정 Port (targetPort) 를 service의 6379 port에 매핑시킴  .spec.selector  해당 service가 연결해야하는 대상 Pod의 label 조건 kimdubi-test , redis-cluster 의 label이 달린 Pod는 이 service를 통해 접근할 수 있음  .spec.sessionAffinity  특정 클라이언트가 특정 Pod에 붙어야할 때 사용하는 설정  .spec.type  service의 type으로 default는 ClusterIP  kimdubi-test-redis-cluster-headless $ kubectl get service kimdubi-test-redis-cluster-headless -o yaml apiVersion: v1 kind: Service metadata: annotations: meta.helm.sh/release-name: kimdubi-test meta.helm.sh/release-namespace: default creationTimestamp: \"2021-02-21T07:33:55Z\" labels: app.kubernetes.io/instance: kimdubi-test app.kubernetes.io/managed-by: Helm app.kubernetes.io/name: redis-cluster helm.sh/chart: redis-cluster-4.3.0 name: kimdubi-test-redis-cluster-headless namespace: default resourceVersion: \"24611\" selfLink: /api/v1/namespaces/default/services/kimdubi-test-redis-cluster-headless uid: eb2da26a-9264-46a7-91f1-7a3cfa241889 spec: clusterIP: None ports: - name: tcp-redis port: 6379 protocol: TCP targetPort: tcp-redis - name: tcp-redis-bus port: 16379 protocol: TCP targetPort: tcp-redis-bus publishNotReadyAddresses: true selector: app.kubernetes.io/instance: kimdubi-test app.kubernetes.io/name: redis-cluster sessionAffinity: None type: ClusterIP status: loadBalancer: {}  .spec.clusterIP  위에서 본 kimdubi-test-redis-cluster service와는 다르게 clusterIP 값이 None 으로 설정하여 headless service를 생성함  .spec.ports[]  해당 서비스의 label selector 에 매치되는 Pod의 특정 Port (targetPort) 를 service의 6379 port에 매핑시킴  .spec.selector  해당 service가 연결해야하는 대상 Pod의 label 조건 kimdubi-test , redis-cluster 의 label이 달린 Pod는 이 service를 통해 접근할 수 있음  ","wordCount":"613","inLanguage":"en","datePublished":"2021-10-06T17:58:13+09:00","dateModified":"2021-10-06T17:58:13+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/cloud/k8s_redis_cluster_service/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/cloud/>Clouds</a></div><h1 class=post-title>Kubernetes에서 redis cluster를 돌려보자 - Service</h1><div class=post-meta>October 6, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#service aria-label=Service?>Service?</a><ul><li><a href=#service-%ea%b0%9c%eb%85%90 aria-label="Service 개념">Service 개념</a></li><li><a href=#service-%ec%82%ac%ec%9a%a9%ed%98%84%ed%99%a9 aria-label="Service 사용현황">Service 사용현황</a><ul><li><a href=#headless-service%eb%9e%80 aria-label="headless service란?">headless service란?</a></li></ul></li></ul></li><li><a href=#service-%ec%83%9d%ec%84%b1-template%ec%9d%84-%ec%82%b4%ed%8e%b4%eb%b3%b4%ec%9e%90 aria-label="Service 생성 template을 살펴보자">Service 생성 template을 살펴보자</a><ul><li><a href=#kimdubi-test-redis-cluster aria-label=kimdubi-test-redis-cluster>kimdubi-test-redis-cluster</a><ul><li><a href=#specclusterip aria-label=.spec.clusterIP>.spec.clusterIP</a></li><li><a href=#specports aria-label=.spec.ports[]>.spec.ports[]</a></li><li><a href=#specselector aria-label=.spec.selector>.spec.selector</a></li><li><a href=#specsessionaffinity aria-label=.spec.sessionAffinity>.spec.sessionAffinity</a></li><li><a href=#spectype aria-label=.spec.type>.spec.type</a></li></ul></li><li><a href=#kimdubi-test-redis-cluster-headless aria-label=kimdubi-test-redis-cluster-headless>kimdubi-test-redis-cluster-headless</a><ul><li><a href=#specclusterip-1 aria-label=.spec.clusterIP>.spec.clusterIP</a></li><li><a href=#specports-1 aria-label=.spec.ports[]>.spec.ports[]</a></li><li><a href=#specselector-1 aria-label=.spec.selector>.spec.selector</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><hr><h1 id=service>Service?<a hidden class=anchor aria-hidden=true href=#service>#</a></h1><h2 id=service-개념>Service 개념<a hidden class=anchor aria-hidden=true href=#service-개념>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/cloud/k8s/k8s_redis_svc01.png alt></p><ul><li>Pod는 deployment, replicaset, statefulset 같은 controller에 의해 관리되기 때문에 새로 생겨나거나 없어지기도 하고 한 Node에만 떠있는 게 아니라 여러 Node를 옮겨다닐 수 있음</li><li>Pod는 이렇듯 동적으로 변하여 고정된 endpoint로의 호출이 어려운데 (Pod의 IP,hostname이 변하니까 ) 이러한 이슈를 해결하기 위한 오브젝트가 Service임</li><li>Client는 클러스터 안에서 Pod IP가 바뀌던 없어지건 새로 생기건 신경쓸 필요 없이 Service만 바라보면 고정된 endpoint로 접근이 가능함</li><li>Service는 크게 아래와 같이 네가지 Type으로 나뉨<ul><li>ClusterIp : kubernets cluster 내부에서 사용하는 service. 외부에선 접근할 수 없음</li><li>LoadBalancer : 토클,aws,gcp 등 퍼블릭 클라우드 서비스를 이용할 때 사용가능한 type으로 loadbalancer의 IP를 이용하여 외부에서 접근가능함</li><li>NodePort : kubernetes cluster의 각 노드의 지정된 port를 service에 할당함. node의 port를 이용하기 때문에 외부에서도 접근가능함</li><li>ExternalName : kubernetes cluster 내부에서 외부로 접근하는 경우 사용, Service를 ExternalName 으로 설정하여 CNAME을 타고 외부로 접근함</li></ul></li><li>이 글에서 다루는 redis-cluster 에서는 ClusterIP type의 service를 사용하고 있음 ( DB는 내부통신만 하면 되니까)</li></ul><h2 id=service-사용현황>Service 사용현황<a hidden class=anchor aria-hidden=true href=#service-사용현황>#</a></h2><pre><code>$ kubectl get service
NAME                                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)              AGE
kimdubi-test-redis-cluster            ClusterIP   10.254.8.60   &lt;none&gt;        6379/TCP             6d
kimdubi-test-redis-cluster-headless   ClusterIP   None          &lt;none&gt;        6379/TCP,16379/TCP   6d
kubernetes                            ClusterIP   10.254.0.1    &lt;none&gt;        443/TCP              6d1h
</code></pre><ul><li>kubernetes cluster 내부에서 Pod 간 연결을 위해 사용하는 ClusterIP type의 kimdubi-test-redis-cluster 라는 이름의 service</li><li>ClusterIP type이지만 IP가 설정되지 않은 kimdubi-test-redis-cluster-headless 라는 이름의 service, headless service라고 함</li><li>두개의 service가 생성되었지만 실제로는 kimdubi-test-redis-cluster-headless 서비스가 사용됨</li></ul><h3 id=headless-service란>headless service란?<a hidden class=anchor aria-hidden=true href=#headless-service란>#</a></h3><ul><li>kimdubi-test-redis-cluster 같은 보통의 service는 받은 요청을 매핑된 Pod들에게 loadbalancing 형태로 뿌려주는데 이는 stateless 한 web server 처럼, 어떤 web server로 요청이 가도 동일한 결과를 내는 구조에서 의미가 있음 </li><li>DB처럼 Master / Slave 같은 stateful 한 구성에서는 loadbalancing 형태로 뿌려주는 게 아니라 Master 인지 Slave인지 파악하여 특정한 Pod에 요청을 뿌려줘야함</li><li>이처럼 loadbalancing이 필요없고 client 에서 모든 Pod에 접근해야하는 구성에서는 headless service를 사용하며 아래와 같은 특징이 있음<ul><li>headless service는 IP 대신 dns 를 가짐</li><li>headless service의 dns에 대해 nslookup을 수행하면 binding 된 모든 Pod들의 IP를 return 함</li><li>Client는 return 받은 모든 Pod의 IP를 통해 원하는 Pod 에 직접 접근할 수 있음</li></ul></li></ul><pre><code># nslookup kimdubi-test-redis-cluster-headless
Server:		10.254.0.10
Address:	10.254.0.10#53
    
Name:	kimdubi-test-redis-cluster-headless.default.svc.cluster.local
Address: 10.100.71.3
Name:	kimdubi-test-redis-cluster-headless.default.svc.cluster.local
Address: 10.100.14.7
Name:	kimdubi-test-redis-cluster-headless.default.svc.cluster.local
Address: 10.100.79.12
Name:	kimdubi-test-redis-cluster-headless.default.svc.cluster.local
Address: 10.100.14.8
Name:	kimdubi-test-redis-cluster-headless.default.svc.cluster.local
Address: 10.100.79.11
Name:	kimdubi-test-redis-cluster-headless.default.svc.cluster.local
Address: 10.100.71.4
</code></pre><p>=> kimdubi-test-redis-cluster-headless service에 대해 nslookup 수행 이 service에 binding 된 모든 Pod의 IP를 return 받음</p><h1 id=service-생성-template을-살펴보자>Service 생성 template을 살펴보자<a hidden class=anchor aria-hidden=true href=#service-생성-template을-살펴보자>#</a></h1><h2 id=kimdubi-test-redis-cluster>kimdubi-test-redis-cluster<a hidden class=anchor aria-hidden=true href=#kimdubi-test-redis-cluster>#</a></h2><pre><code>$ kubectl get service kimdubi-test-redis-cluster -o yaml
apiVersion: v1
kind: Service
metadata:
  annotations:
    meta.helm.sh/release-name: kimdubi-test
    meta.helm.sh/release-namespace: default
  creationTimestamp: &quot;2021-02-21T07:33:55Z&quot;
  labels:
    app.kubernetes.io/instance: kimdubi-test
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-4.3.0
  name: kimdubi-test-redis-cluster
  namespace: default
  resourceVersion: &quot;24613&quot;
  selfLink: /api/v1/namespaces/default/services/kimdubi-test-redis-cluster
  uid: c7a73d74-a532-4689-8d9e-45287df887b3
spec:
  clusterIP: 10.254.8.60
  ports:
  - name: tcp-redis
    port: 6379
    protocol: TCP
    targetPort: tcp-redis
  selector:
    app.kubernetes.io/instance: kimdubi-test
    app.kubernetes.io/name: redis-cluster
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
</code></pre><h3 id=specclusterip>.spec.clusterIP<a hidden class=anchor aria-hidden=true href=#specclusterip>#</a></h3><ul><li>clusterIP type으로 생성된 service를 지정한 IP로 생성되도록 설정</li><li>이 service는 10.254.8.60 IP를 할당받게됨</li></ul><h3 id=specports>.spec.ports[]<a hidden class=anchor aria-hidden=true href=#specports>#</a></h3><ul><li>해당 서비스의 label selector 에 매치되는 Pod의 특정 Port (targetPort) 를 service의 6379 port에 매핑시킴</li></ul><h3 id=specselector>.spec.selector<a hidden class=anchor aria-hidden=true href=#specselector>#</a></h3><ul><li>해당 service가 연결해야하는 대상 Pod의 label 조건</li><li>kimdubi-test , redis-cluster 의 label이 달린 Pod는 이 service를 통해 접근할 수 있음</li></ul><h3 id=specsessionaffinity>.spec.sessionAffinity<a hidden class=anchor aria-hidden=true href=#specsessionaffinity>#</a></h3><ul><li>특정 클라이언트가 특정 Pod에 붙어야할 때 사용하는 설정</li></ul><h3 id=spectype>.spec.type<a hidden class=anchor aria-hidden=true href=#spectype>#</a></h3><ul><li>service의 type으로 default는 ClusterIP</li></ul><h2 id=kimdubi-test-redis-cluster-headless>kimdubi-test-redis-cluster-headless<a hidden class=anchor aria-hidden=true href=#kimdubi-test-redis-cluster-headless>#</a></h2><pre><code>$ kubectl get service kimdubi-test-redis-cluster-headless -o yaml

apiVersion: v1
kind: Service
metadata:
  annotations:
    meta.helm.sh/release-name: kimdubi-test
    meta.helm.sh/release-namespace: default
  creationTimestamp: &quot;2021-02-21T07:33:55Z&quot;
  labels:
    app.kubernetes.io/instance: kimdubi-test
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: redis-cluster
    helm.sh/chart: redis-cluster-4.3.0
  name: kimdubi-test-redis-cluster-headless
  namespace: default
  resourceVersion: &quot;24611&quot;
  selfLink: /api/v1/namespaces/default/services/kimdubi-test-redis-cluster-headless
  uid: eb2da26a-9264-46a7-91f1-7a3cfa241889
spec:
  clusterIP: None
  ports:
  - name: tcp-redis
    port: 6379
    protocol: TCP
    targetPort: tcp-redis
  - name: tcp-redis-bus
    port: 16379
    protocol: TCP
    targetPort: tcp-redis-bus
  publishNotReadyAddresses: true
  selector:
    app.kubernetes.io/instance: kimdubi-test
    app.kubernetes.io/name: redis-cluster
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
</code></pre><h3 id=specclusterip-1>.spec.clusterIP<a hidden class=anchor aria-hidden=true href=#specclusterip-1>#</a></h3><ul><li>위에서 본 kimdubi-test-redis-cluster service와는 다르게 clusterIP 값이 None 으로 설정하여 headless service를 생성함</li></ul><h3 id=specports-1>.spec.ports[]<a hidden class=anchor aria-hidden=true href=#specports-1>#</a></h3><ul><li>해당 서비스의 label selector 에 매치되는 Pod의 특정 Port (targetPort) 를 service의 6379 port에 매핑시킴</li></ul><h3 id=specselector-1>.spec.selector<a hidden class=anchor aria-hidden=true href=#specselector-1>#</a></h3><ul><li>해당 service가 연결해야하는 대상 Pod의 label 조건</li><li>kimdubi-test , redis-cluster 의 label이 달린 Pod는 이 service를 통해 접근할 수 있음</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/kubernetes/>kubernetes</a></li><li><a href=/tags/redis/>redis</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>