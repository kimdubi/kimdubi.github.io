<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 5.7 vs 8 replication 비교 | kimDuBiA</title><meta name=keywords content="mysql,replication"><meta name=description content="MySQL 스터디에서 공유했던 MySQL 8과 5.7 간 replication 기능의 차이점 위주로 정리한 내용입니다.
복제관련해서 무언가 기존엔 없던 새로운 기능이 생겨난 게 아니라 기존 기능에서 좀 더 개선된 사항들이 나왔다.
 MSR replicate_rewrite_db 필터 적용 범위 개선 (global -> channel) crash safe replication을 위한 파라미터의 변경 semi-sync의 동작방식에 대한 변경 binary log 트랜잭션 압축 기능 추가 multi threaded replication에서 writeset 기능 추가  multi source replication 변경사항 : multi source replication에서 replication filter 중 REPLICATE_REWRITE_DB가 global이 아닌 channel 별로 적용됨 mysql 5."><meta name=author content="kimdubi"><link rel=canonical href=/mysql/replication_8/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL 5.7 vs 8 replication 비교"><meta property="og:description" content="MySQL 스터디에서 공유했던 MySQL 8과 5.7 간 replication 기능의 차이점 위주로 정리한 내용입니다.
복제관련해서 무언가 기존엔 없던 새로운 기능이 생겨난 게 아니라 기존 기능에서 좀 더 개선된 사항들이 나왔다.
 MSR replicate_rewrite_db 필터 적용 범위 개선 (global -> channel) crash safe replication을 위한 파라미터의 변경 semi-sync의 동작방식에 대한 변경 binary log 트랜잭션 압축 기능 추가 multi threaded replication에서 writeset 기능 추가  multi source replication 변경사항 : multi source replication에서 replication filter 중 REPLICATE_REWRITE_DB가 global이 아닌 channel 별로 적용됨 mysql 5."><meta property="og:type" content="article"><meta property="og:url" content="/mysql/replication_8/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2022-01-24T11:28:44+09:00"><meta property="article:modified_time" content="2022-01-24T11:28:44+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL 5.7 vs 8 replication 비교"><meta name=twitter:description content="MySQL 스터디에서 공유했던 MySQL 8과 5.7 간 replication 기능의 차이점 위주로 정리한 내용입니다.
복제관련해서 무언가 기존엔 없던 새로운 기능이 생겨난 게 아니라 기존 기능에서 좀 더 개선된 사항들이 나왔다.
 MSR replicate_rewrite_db 필터 적용 범위 개선 (global -> channel) crash safe replication을 위한 파라미터의 변경 semi-sync의 동작방식에 대한 변경 binary log 트랜잭션 압축 기능 추가 multi threaded replication에서 writeset 기능 추가  multi source replication 변경사항 : multi source replication에서 replication filter 중 REPLICATE_REWRITE_DB가 global이 아닌 channel 별로 적용됨 mysql 5."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL 5.7 vs 8 replication 비교","item":"/mysql/replication_8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 5.7 vs 8 replication 비교","name":"MySQL 5.7 vs 8 replication 비교","description":"MySQL 스터디에서 공유했던 MySQL 8과 5.7 간 replication 기능의 차이점 위주로 정리한 내용입니다.\n복제관련해서 무언가 기존엔 없던 새로운 기능이 생겨난 게 아니라 기존 기능에서 좀 더 개선된 사항들이 나왔다.\n MSR replicate_rewrite_db 필터 적용 범위 개선 (global -\u0026gt; channel) crash safe replication을 위한 파라미터의 변경 semi-sync의 동작방식에 대한 변경 binary log 트랜잭션 압축 기능 추가 multi threaded replication에서 writeset 기능 추가  multi source replication 변경사항 : multi source replication에서 replication filter 중 REPLICATE_REWRITE_DB가 global이 아닌 channel 별로 적용됨 mysql 5.","keywords":["mysql","replication"],"articleBody":"MySQL 스터디에서 공유했던 MySQL 8과 5.7 간 replication 기능의 차이점 위주로 정리한 내용입니다.\n복제관련해서 무언가 기존엔 없던 새로운 기능이 생겨난 게 아니라 기존 기능에서 좀 더 개선된 사항들이 나왔다.\n MSR replicate_rewrite_db 필터 적용 범위 개선 (global - channel) crash safe replication을 위한 파라미터의 변경 semi-sync의 동작방식에 대한 변경 binary log 트랜잭션 압축 기능 추가 multi threaded replication에서 writeset 기능 추가  multi source replication 변경사항 : multi source replication에서 replication filter 중 REPLICATE_REWRITE_DB가 global이 아닌 channel 별로 적용됨 mysql 5.7 버전부터 multi-source replication 기능이 생기면서 유용하게 사용되고 있지만 두대 이상의 Master 에서 같은 이름의 database를 구분 지어 다른 db명으로 변경해서 replication 설정은 불가능했음 MySQL 8.0부터 MSR 구성에서 REPLICATE_REWRITE_DB 설정이 global 이 아닌, channel 별로 가능해짐\nmysql 5.7 Master 1: kimdubi_db = Slave : kimdubi_db Master 2: kimdubi_db = Slave : kimdubi_db  Master server들의 논리DB명이 같으면 Slave 서버에서는 이를 구분해서 각각 받아올 수가 없음 change replication filter replicate_do_db=(master1,master2), replicate_rewrite_db=((kimdubi_test,master1),(kimdubi_test,master2));  이렇게 해도 replicate_rewrite_db 설정이 channel 별이 아닌 global로 적용되어서 master1로 데이터를 받게됨 만약 Master 1번 서버에서 delete 를 했다? binlog format=ROW 가 아니면 복제가 깨질 수 있음    mysql 8.0 Master 1: kimdubi_db = Slave : kimdubi_db1 Master 2: kimdubi_db = Slave : kimdubi_db2  MySQL 5.7과 달리 Master서버들의 논리DB가 같아도 채널별로 논리DB를 rewrite해서 받아올 수 있음  mysql CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db1), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db1)) FOR CHANNEL 'master_1'; mysql CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db2), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db2)) FOR CHANNEL 'master_2';  REPLICATE_REWRITE_DB = kimdubi_db,kimdubi_db2  앞의 kimdubi_db는 source DB의 논리DB, 뒤의 kimdubi_db2는 앞의 kimdubi_db를 rewrite 치환해서 slave에서 replication 받는 DB relay log에서 kimdubi_db로 들어오고 sql_thread가 relaylog를 읽고 DB에 반영하면서 kimdubi_db2로 바꾸어 읽게 됨    구성방법 mysql show variables like '%repository%'; +---------------------------+-------+ | Variable_name | Value | +---------------------------+-------+ | master_info_repository | TABLE | | relay_log_info_repository | TABLE | +---------------------------+-------+  MSR 설정을 위해서는 replication 관련 정보 repository 를 TABLE 에 저장해야함 master_info_repository=TABLE 의미는 Slave가 복제하는 MASTER DB의 status와 connection inforamtion 정보를 mysql.slave_master_info 에 저장하겠다는 의미 relay_log_info_repository=TABLE = 복제 관련 파일 및 포지션 정보를 mysql.slave_relay_log_info 에 저장 8.0부터 default TABLE  replication channel 구성 mysql change master to - master_host='172.17.0.6', - master_port=3306, - master_user='replUser', - master_password='!dlatl00', - master_log_file='mysql-bin.000011', - master_log_pos=789 - for channel 'master_1'; change master to - master_host='172.17.0.7', - master_port=3306, - master_user='replUser', - master_password='!dlatl00', - master_log_file='mysql-bin.000010', - master_log_pos=1099 - for channel 'master_2'; CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db1), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db1)) FOR CHANNEL 'master_1'; Query OK, 0 rows affected (0.01 sec) mysql CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db2), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db2)) FOR CHANNEL 'master_2'; Query OK, 0 rows affected (0.01 sec) mysql show slave status\\G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 172.17.0.6 Master_User: replUser Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000011 Read_Master_Log_Pos: 992 Relay_Log_File: relay-bin-master_1.000003 Relay_Log_Pos: 322 Relay_Master_Log_File: mysql-bin.000011 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: kimdubi_db1 Exec_Master_Log_Pos: 992 Relay_Log_Space: 903 Until_Condition: None Master_Server_Id: 64 Master_UUID: ba315763-e7e8-11e9-9c29-0242ac110002 Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Replicate_Rewrite_DB: (kimdubi_db,kimdubi_db1) Channel_Name: master_1 *************************** 2. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 172.17.0.7 Master_User: replUser Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000010 Read_Master_Log_Pos: 1302 Relay_Log_File: relay-bin-master_2.000004 Relay_Log_Pos: 322 Relay_Master_Log_File: mysql-bin.000010 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: kimdubi_db2 Exec_Master_Log_Pos: 1302 Relay_Log_Space: 903 Master_Server_Id: 2 Master_UUID: ba315763-e7e8-11e9-9c29-0242ac110002 Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Replicate_Rewrite_DB: (kimdubi_db,kimdubi_db2) Channel_Name: master_2 2 rows in set (0.00 sec) 복제 테스트  MySQL 8.0  ### MASTER_1 에서 수행 mysql use kimdubi_db; Database changed mysql create table test (t int); Query OK, 0 rows affected (0.09 sec) mysql insert into test values(1); Query OK, 1 row affected (0.05 sec) ### MASTER_2 에서 수행 mysql use kimdubi_db; Database changed mysql create table test (t int); Query OK, 0 rows affected (0.07 sec) mysql insert into test values(2); Query OK, 1 row affected (0.03 sec) ### SLAVE에서 데이터 확인 mysql select * from kimdubi_db1.test; +------+ | t | +------+ | 1 | +------+ 1 row in set (0.01 sec) mysql select * from kimdubi_db2.test; +------+ | t | +------+ | 2 | +------+ 1 row in set (0.00 sec)  MySQL 5.7  ### MASTER_1 에서 수행 mysql use kimdubi_db; Database changed mysql create table test (t int); Query OK, 0 rows affected (0.09 sec) mysql insert into test values(1111111); Query OK, 1 row affected (0.05 sec) ### MASTER_2 에서 수행 mysql use kimdubi_db; Database changed mysql create table test (t int); Query OK, 0 rows affected (0.07 sec) mysql insert into test values(222222); Query OK, 1 row affected (0.03 sec) ### slave에서 조회 mysql select * from kimdubi_db2.tb_test; Empty set (0.01 sec) mysql select * from kimdubi_db1.tb_test; +---------+ | a | +---------+ | 222222 | | 1111111 | +---------+ 2 rows in set (0.01 sec) ### 데이터 깨짐 현상 ### master_1 mysql select * from tb_test; +---------+ | a | +---------+ | 1111111 | +---------+ 1 row in set (0.00 sec) ### 복제DB mysql select * from tb_test; +---------+ | a | +---------+ | 22222 | | 1111111 | +---------+ 2 rows in set (0.00 sec) ### master_1 mysql set session binlog_format='STATEMENT'; Query OK, 0 rows affected (0.00 sec) mysql delete from tb_test where a select * from tb_test; Empty set (0.00 sec) = master_2 에서 받은 데이터도 모두 날아간 상태에서 master_2에서 해당 데이터에 대해 DML이 들어오면? mysql show slave status\\G; *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 172.17.0.4 Master_User: root Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 4046 Relay_Log_File: 8bb84cc87d63-relay-bin-master_1.000005 Relay_Log_Pos: 856 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: No Replicate_Do_DB: master1,master2 Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 1032 Last_Error: Could not execute Delete_rows event on table master1.tb_test; Can't find record in 'tb_test', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000001, end_log_pos 4015 crash safe replication 변경사항 : crash_safe replication의 필수 설정 중 하나인 relay_log_info_repository 설정의 default 값이 FILE - TABLE로 변경됨 MySQL 서버가 예기치 못한 장애로 인해 비정상 종료 되는 경우, SLAVE를 재기동 했을 때 복제가 원활하게 재개될수 있도록 하는 여러 설정 조합의 효과\n I/O thread가 relay log에 복제할 event를 기록하고 sync_master_info 파일에 기록하기 전에 MySQL서버가 비정상 종료되면, MySQL을 재기동한 뒤 I/O thread가 위의 이벤트를 relay log에 또다시 기록해서 복제 duplicate 날 수 있음 SQL thread가 relay log에 기록된 트랜잭션을 커밋한 후 sync_relay_log_info 파일에 포지션 정보를 기록하기 전에 MySQL서버가 비정상 종료되면, MySQL을 재기동한 뒤 위의 동일한 트랜잭션을 또 replay할 수 있음  crash-safe Replicaion 설정 필수  relay_log_info_repository=TABLE relay_log_recovery = on  그 외 상황별 필요 파라미터    variable MySQL 5.7 (default) MySQL 8.0 (default) comment     relay_log_recovery OFF OFF 필수 ON   relay_log_info_repository FILE TABLE GTID 복제 시엔 필요없음 (mysql.gtid_executed가 대체)   sync_relay_log 10000 10000 MTS + slave_preserve_commit_order=0 일 땐 sync_relay_log = 1 필요   slave_preserve_commit_order OFF OFF / ON (MySQL 8.0.27이상부터는 ON) 권장값 ON (트랜잭션 갭 메울 필요 없어짐)   sync_binlog 1 1 GTID 복제 시 sync_binlog = 1 필요 (replica서버에서)   innodb_flush_log_at_trx_commit 1 1 GTID 복제 시 innodb_flush_log_at_trx_commit =1 필요 (replica서버에서)    동작 방식 ### relay_log_info_repository = TABLE begin; insert into tb_test values(1); update mysql.slave_relay_log_info set Relay_log_name='./relay-bin.000006',replay_log_pos=1356; commit; ### relay_log_recovery = ON 2020-05-03T12:19:21.402872Z 0 [Warning] [MY-010539] [Repl] Recovery from master pos 1142 and file mysql-bin.000003 for channel ''. Previous relay log pos and relay log file had been set to 322, ./relay-bin.000014 respectively.  relay_log_info_repository = TABLE 설정 시 위 처럼, SQL thread가 position 정보 업데이트와 실제 트랜잭션 처리를 원자적으로 수행함 반면 I/O thread는 실제 relay log 파일에도 쓰고, mysql.slave_master_info 테이블에도 update하는 작업을 sql thread처럼 원자적으로 수행할 수 없음  relay_log_recovery = ON 설정 시 I/O thread의 포지션을 SQL thread가 마지막으로 실행했던 포지션으로 초기화 하고 새로운 relay log 파일을 생성해서 sql thread가 읽어야할 relay log position을 초기화하는 식으로 동작하게 하여 I/O thread의 문제를 해결할 수 있음    mysql.slave_master_info, mysql.slave_relay_log_info 테이블 내용 mysql select * from slave_relay_log_info; +-----------------+------------------------------------------+---------------+------------------+----------------+-----------+-------------------+----+--------------+ | Number_of_lines | Relay_log_name | Relay_log_pos | Master_log_name | Master_log_pos | Sql_delay | Number_of_workers | Id | Channel_name | +-----------------+------------------------------------------+---------------+------------------+----------------+-----------+-------------------+----+--------------+ | 7 | ./8bb84cc87d63-relay-bin-master_1.000005 | 856 | mysql-bin.000001 | 3763 | 0 | 0 | 1 | master_1 | | 7 | ./8bb84cc87d63-relay-bin-master_2.000004 | 1124 | mysql-bin.000001 | 3493 | 0 | 0 | 1 | master_2 | +-----------------+------------------------------------------+---------------+------------------+----------------+-----------+-------------------+----+--------------+ 2 rows in set (0.00 sec) mysql select * from slave_master_info; +-----------------+------------------+----------------+------------+-----------+---------------+------+---------------+-------------+--------+------------+----------+------------+---------+------------------------+-----------+------+--------------------+--------------------------------------+-------------+---------+-------------+-----------------------+--------------+-------------+ | Number_of_lines | Master_log_name | Master_log_pos | Host | User_name | User_password | Port | Connect_retry | Enabled_ssl | Ssl_ca | Ssl_capath | Ssl_cert | Ssl_cipher | Ssl_key | Ssl_verify_server_cert | Heartbeat | Bind | Ignored_server_ids | Uuid | Retry_count | Ssl_crl | Ssl_crlpath | Enabled_auto_position | Channel_name | Tls_version | +-----------------+------------------+----------------+------------+-----------+---------------+------+---------------+-------------+--------+------------+----------+------------+---------+------------------------+-----------+------+--------------------+--------------------------------------+-------------+---------+-------------+-----------------------+--------------+-------------+ | 25 | mysql-bin.000001 | 3227 | 172.17.0.4 | root | qhdks123 | 3306 | 60 | 0 | | | | | | 0 | 30 | | 0 | 6ee46ea8-753f-11ec-be3b-0242ac110004 | 86400 | | | 0 | master_1 | | | 25 | mysql-bin.000001 | 2689 | 172.17.0.5 | root | qhdks123 | 3306 | 60 | 0 | | | | | | 0 | 30 | | 0 | bfe2850b-753f-11ec-8148-0242ac110005 | 86400 | | | 0 | master_2 | | +-----------------+------------------+----------------+------------+-----------+---------------+------+---------------+-------------+--------+------------+----------+------------+---------+------------------------+-----------+------+--------------------+--------------------------------------+-------------+---------+-------------+-----------------------+--------------+-------------+ 2 rows in set (0.00 sec) semi-sync 변경사항 : semi-sync의 동작방식이 after_commit - after_sync로 변경됨\nafter_commit  User transaction commit Engine prepare Binlog flush Binlog commit Engine commit Binlog dump thread send event with ACK Request semi-sync wait (AFTER_COMMIT) User Commit OK   7번 Slave가 data를 받았다는 응답을 기다리는 도중 Master가 down 되면 Master에서는 이미 Engine commit 까지 된 상황이기 때문에 새로 승격될 Slave에는 데이터가 없지만 Old Master에는 데이터가 존재하여 정합성이 깨짐 5번 engine commit 이 된 시점부터 다른 세션에서는 변경된 데이터를 읽을 수 있음 (phantom read) SLAVE로의 복제가 실패하면 이 트랜잭션은 Master에서 수동으로 rollback 처리해야함  after_sync  User transaction commit Engine prepare Binlog flush Binlog commit Binlog dump thread send event with ACK Request loss-less semisync wait (AFTER_SYNC) Engine commit User Commit OK   after_sync에서는 레플리카 서버에 복제되지 않았다면, 소스 서버에서도 engine commit까지 될 수 없기 때문에 after_commit의 phantom read 같은 경우가 발생하지 않음 engine commit이 늦춰져서 semi-sync에 대한 부담감이 높아질 수 있음  아래 파라미터를 적절하게 변경해보자 rpl_semi_sync_master_timeout (default 10초) rpl_semi_sync_master_wait_for_slave_count (default 1)    binary log 트랜잭션 압축 변경사항 : binlog_format = ROW으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압축해서 바이너리 로그에 기록하는 기능이 추가도미\n 트랜잭션에서 변경한 데이터를 zstd 알고리즘으로 압축 transaction_payload_event라는 이벤트로 바이너리 로그에 기록 압축된 상태로 레플리카 서버의 relay log에 기록됨 압축 해제 후 레플리카 서버에 반영됨 마스터 뿐만 아니라 리플리카도 압축 기능을 지원하는 MySQL 버전을 사용해야함 효과는 압축률 50%정도, 네트워크 사용량은 1/3 정도, CPU는 조금 더 쓰는 정도  관련 파라미터  binlog_transaction_compression (default OFF ) binlog_transaction_compression_level_zstd (default 3) performance-schema-instrument=“stage/sql/%compressing_transaction_changes.=ON” protocol_compression_algorithms=‘zlib,zstd,uncompressed’;  limitation  GTID 설정 관련 이벤트 복제 구성에서 heartbeat 관련 이벤트 복제 실패 / 데이터 불일치를 발생시킬 수 있는 incident 타입의 이벤트(?) 트랜잭션을 지원하지 않는 스토리지 엔진에 대한 이벤트 binlog_format = statement 로 기록되는 이벤트  구성 방법 mysql change master to - master_host='172.17.0.6', - master_port=3306, - master_user='replUser', - master_password='!dlatl00', - master_log_file='mysql-bin.000011', - master_log_pos=789 - source_compression_algorithms='zstd', - source_zstd_compression_level=7; delayed replication 변경사항 : binary log에 OCT, ICT timestamp가 추가되었고 특히 ICT는 delayed replication의 기준으로 작용함\noriginal_commit_timestamp (OCT)  트랜잭션이 원본 소스 서버에서 커밋된 시각  immediate_commit_timestamp (ICT)  트랜잭션이직계 소스 서버에서 커밋된 시각  어디에 쓰이는고  체인 복제 구성 + delayed replication의 구조에서 의미가 있는 듯 원본 소스 서버에서는 OCT == ICT 레플리카 서버(log_slave_updates = ON)에서는 ICT 값이 복제된 트랜잭션이 커밋된 시점으로 기록되기 때문에 OCT != ICT MySQL 8.0 미만의 체인복제 구성에서 delayed replication의 지연 측정 기준이 원본 소스의 시각으로 측정되던 부분이 직계 소스 서버를 기준으로 할 수 있도록 개선되었음  multi-threaded replication 변경사항 : multi-thread-replication의 slave_parallel_type=‘logical_clock’ 방식 중 writeset 방식이 추가됨\n관련 파라미터    variable MySQL 5.7 (default) MySQL 8.0 (default) comment     slave_parallel_type DATABASE 8.0.27 = LOGICAL_CLOCK / 미만 DATABASE    slave_parallel_workers 1 8.0.27 = 4 / 미만 1    slave_pending_jobs_size_max 16MB 128MB max_allowed_packet 보다 클 수 없음   binlog_transaction_dependency_tracking COMMIT_ORDER COMMIT_ORDER    slave_preserve_commit_order OFF 8.0.27 = ON / 미만 OFF mysql 8.0.18 이하 버전에서 ON 하려면 log_slave_updates =ON 설정도 필요함   binlog_order_commits ON ON replication source 서버에 설정   binlog_format ROW ROW writeset을 사용하기 위해서는 ROW 포맷 필요    ## slave_pending_jobs_size_max가 작을 때 발생 가능 에러 Cannot schedule event Update_rows, relay-log relay-bin.0000,position 0000 to Worker thread because its size 21206802 exceeds 16777216 of slave_pending_jobs_size_max ## slave_preserve_commit_order ON 꼬였을 때 발생 가능 에러 ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR slave-preserve-commit-order가 활성화되었을 때 적어도 하나의 이전 작업자에 오류가 발생한 후 슬레이브 작업자가 중지되었습니다. 커밋 순서를 유지하기 위해 이 스레드에서 실행한 마지막 트랜잭션이 커밋되지 않았습니다. 실패한 스레드를 수정한 후 슬레이브를 다시 시작할 때 이 작업자도 수정해야 합니다. database  처음 multi threaded replication이 도입되었을 때 지원하던 방식으로 논리DB 단위로 병렬처리를 수행함 MySQL 서버에 논리DB가 하나밖에 존재하지 않거나, 각 논리DB별 쓰기 부하가 일정하지 않으면 효과가 없거나 떨어짐 slave_parallel_type=‘DATABASE’  logical  소스 서버에서 트랜잭션들이 binary log로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해 레플리카 서버에서 트랜잭션의 순번 값을 바탕으로 병렬 복제 수행하는 기능 database type과는 달리 동일 논리DB여도 병렬 복제 가능  group commit 단위로 할당하기 때문   commit-parent 기반 logical clock  MySQL 5.7.2 ~ 5.7.5버전에서 사용됨 소스서버에서 커밋 시점이 같은 트랜잭션들을 병렬 복제 처리함 커밋 시점이 같은 트랜잭션인지 식별은 commit_seq_no 값을 binary log에 같이 기록해서 식별함   lock 기반 logical clock  MySQL 5.7.6 버전 ~ commit_seq_no 값이 달라도 커밋 처리 시점이 겹친다면 레플리카 서버에서 병렬 복제처리 가능 이를 위해 binary log에 sequence_number, last_committed라는 값을 함께 기록함  sequence_number : 커밋된 트랜잭션에 대한 논리적인 순번 값 last_committed : 현 트랜잭션 이전의 가장 최근의 트랜잭션의 sequence_number 실행하려는 트랜잭션의 last_committed 값 예시에서는 txn+1의 C     커밋시점이 겹치는 트랜잭션들을 늘려 병렬 복제 트랜잭션을 늘리기 위해 binlog_group_commit_sync_delay / binlog_group_commit_sync_no_delay_count를 같은 파라미터를 적절히 설정하기도함  # at 4485 #220118 13:41:09 server id 1 end_log_pos 4550 CRC32 0x2ad8ee5f Anonymous_GTID last_committed=17 sequence_number=18 SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/; writeset logical_clock 의 방식 중 하나\n binlog_transaction_dependency_tracking  commit_order : 기존 MySQL 5.7의 lock 기반 logical clock으로 동작 writeset : 서로 다른 데이터를 변경한 트랜잭션들은 모두 병렬로 처리할 수 있음 (base는 commit_order지만 last_committed 부분을 처리하는 부분이 다름 p.536 ) wrtieset_session : 동일한 세션에서 실행된 트랜잭션들을 제외한 트랜잭션만 병렬 처리   소스 서버의 트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬 처리 가능 여부를 결정함  변경된 데이터를 hashing해서 writeset 으로 표현함  table에 존재하는 unique한 key의 개수 만큼 생성됨      writeset=hash(index_name,db_name,db_name_length,table_name,table_name_length,value,value_length) mysql use test; mysql show create table jj10 \\G *************************** 1. row *************************** Table: jj10 Create Table: CREATE TABLE `jj10` ( `id1` int(11) DEFAULT NULL, `id2` int(11) DEFAULT NULL, `id3` int(11) NOT NULL, PRIMARY KEY (`id3`), UNIQUE KEY `id1` (`id1`), KEY `id2` (`id2`) $ insert into jj10 values(36,36,36); ### pk (gdb) p pke $1 = \"PRIMARY?test?4jj10?40 ### UK (gdb) p pke $4 = \"id1?test?4jj10?436?2\" = 이거를 해싱하여 writeset으로 변환  위에서 생성된 writeset과 해당 데이터를 변경한 트랜잭션의 sequence_number 값이 key-value 형태로 해시맵 테이블에 저장됨 writeset으로 구성된 새로운 트랜잭션이 실행되면 위의 writeset 히스토리 테이블과 비교하여 충돌되는 wirteset이 있는지 비교하고 last_committed 값을 보정함 writeset 변환을 위한 추가 리소스, writeset 히스토리 테이블 구성을 위한 추가 메모리가 필요  ","wordCount":"2420","inLanguage":"en","datePublished":"2022-01-24T11:28:44+09:00","dateModified":"2022-01-24T11:28:44+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/replication_8/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL 5.7 vs 8 replication 비교</h1><div class=post-meta>January 24, 2022&nbsp;·&nbsp;12 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#multi-source-replication aria-label="multi source replication">multi source replication</a><ul><li><a href=#mysql-57 aria-label="mysql 5.7">mysql 5.7</a></li><li><a href=#mysql-80 aria-label="mysql 8.0">mysql 8.0</a></li><li><a href=#%ea%b5%ac%ec%84%b1%eb%b0%a9%eb%b2%95 aria-label=구성방법>구성방법</a><ul><li><a href=#replication-channel-%ea%b5%ac%ec%84%b1 aria-label="replication channel 구성">replication channel 구성</a></li><li><a href=#%eb%b3%b5%ec%a0%9c-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="복제 테스트">복제 테스트</a></li></ul></li></ul></li><li><a href=#crash-safe-replication aria-label="crash safe replication">crash safe replication</a><ul><li><a href=#crash-safe-replicaion-%ec%84%a4%ec%a0%95 aria-label="crash-safe Replicaion 설정">crash-safe Replicaion 설정</a><ul><li><a href=#%ed%95%84%ec%88%98 aria-label=필수>필수</a></li><li><a href=#%ea%b7%b8-%ec%99%b8-%ec%83%81%ed%99%a9%eb%b3%84-%ed%95%84%ec%9a%94-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0 aria-label="그 외 상황별 필요 파라미터">그 외 상황별 필요 파라미터</a></li><li><a href=#%eb%8f%99%ec%9e%91-%eb%b0%a9%ec%8b%9d aria-label="동작 방식">동작 방식</a></li><li><a href=#mysqlslave_master_info-mysqlslave_relay_log_info-%ed%85%8c%ec%9d%b4%eb%b8%94-%eb%82%b4%ec%9a%a9 aria-label="mysql.slave_master_info, mysql.slave_relay_log_info 테이블 내용">mysql.slave_master_info, mysql.slave_relay_log_info 테이블 내용</a></li></ul></li></ul></li><li><a href=#semi-sync aria-label=semi-sync>semi-sync</a><ul><li><a href=#after_commit aria-label=after_commit>after_commit</a></li><li><a href=#after_sync aria-label=after_sync>after_sync</a></li></ul></li><li><a href=#binary-log-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98-%ec%95%95%ec%b6%95 aria-label="binary log 트랜잭션 압축">binary log 트랜잭션 압축</a><ul><ul><li><a href=#%ea%b4%80%eb%a0%a8-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0 aria-label="관련 파라미터">관련 파라미터</a></li><li><a href=#limitation aria-label=limitation>limitation</a></li><li><a href=#%ea%b5%ac%ec%84%b1-%eb%b0%a9%eb%b2%95 aria-label="구성 방법">구성 방법</a></li></ul></ul></li><li><a href=#delayed-replication aria-label="delayed replication">delayed replication</a><ul><ul><li><a href=#original_commit_timestamp-oct aria-label="original_commit_timestamp (OCT)">original_commit_timestamp (OCT)</a></li><li><a href=#immediate_commit_timestamp-ict aria-label="immediate_commit_timestamp (ICT)">immediate_commit_timestamp (ICT)</a></li><li><a href=#%ec%96%b4%eb%94%94%ec%97%90-%ec%93%b0%ec%9d%b4%eb%8a%94%ea%b3%a0 aria-label="어디에 쓰이는고">어디에 쓰이는고</a></li></ul></ul></li><li><a href=#multi-threaded-replication aria-label="multi-threaded replication">multi-threaded replication</a><ul><ul><li><a href=#%ea%b4%80%eb%a0%a8-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0-1 aria-label="관련 파라미터">관련 파라미터</a></li><li><a href=#database aria-label=database>database</a></li><li><a href=#logical aria-label=logical>logical</a></li><li><a href=#writeset aria-label=writeset>writeset</a></li></ul></ul></li></ul></div></details></div><div class=post-content><p>MySQL 스터디에서 공유했던 MySQL 8과 5.7 간 replication 기능의 차이점 위주로 정리한 내용입니다.</p><p>복제관련해서 무언가 기존엔 없던 새로운 기능이 생겨난 게 아니라 기존 기능에서 좀 더 개선된 사항들이 나왔다.</p><ul><li>MSR replicate_rewrite_db 필터 적용 범위 개선 (global -> channel)</li><li>crash safe replication을 위한 파라미터의 변경</li><li>semi-sync의 동작방식에 대한 변경</li><li>binary log 트랜잭션 압축 기능 추가</li><li>multi threaded replication에서 writeset 기능 추가</li></ul><h1 id=multi-source-replication>multi source replication<a hidden class=anchor aria-hidden=true href=#multi-source-replication>#</a></h1><p><img loading=lazy src="https://github.com/kimdubi/kimdubi.github.io/blob/master/images/mysql/multi_1.png?raw=true" alt>
변경사항 : multi source replication에서 replication filter 중 REPLICATE_REWRITE_DB가 global이 아닌 channel 별로 적용됨
mysql 5.7 버전부터 multi-source replication 기능이 생기면서 유용하게 사용되고 있지만
두대 이상의 Master 에서 같은 이름의 database를 구분 지어 다른 db명으로 변경해서 replication 설정은 불가능했음
MySQL 8.0부터 MSR 구성에서 REPLICATE_REWRITE_DB 설정이 global 이 아닌, channel 별로 가능해짐</p><h2 id=mysql-57>mysql 5.7<a hidden class=anchor aria-hidden=true href=#mysql-57>#</a></h2><pre><code>Master 1: kimdubi_db =&gt; Slave : kimdubi_db
Master 2: kimdubi_db =&gt; Slave : kimdubi_db
</code></pre><ul><li>Master server들의 논리DB명이 같으면 Slave 서버에서는 이를 구분해서 각각 받아올 수가 없음</li><li>change replication filter replicate_do_db=(master1,master2), replicate_rewrite_db=((kimdubi_test,master1),(kimdubi_test,master2));<ul><li>이렇게 해도 replicate_rewrite_db 설정이 channel 별이 아닌 global로 적용되어서 master1로 데이터를 받게됨</li><li>만약 Master 1번 서버에서 delete 를 했다? binlog format=ROW 가 아니면 복제가 깨질 수 있음</li></ul></li></ul><h2 id=mysql-80>mysql 8.0<a hidden class=anchor aria-hidden=true href=#mysql-80>#</a></h2><pre><code>Master 1: kimdubi_db =&gt; Slave : kimdubi_db1
Master 2: kimdubi_db =&gt; Slave : kimdubi_db2
</code></pre><ul><li>MySQL 5.7과 달리 Master서버들의 논리DB가 같아도 채널별로 논리DB를 rewrite해서 받아올 수 있음</li></ul><pre><code>mysql&gt; CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db1), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db1)) FOR CHANNEL 'master_1';
mysql&gt; CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db2), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db2)) FOR CHANNEL 'master_2';
</code></pre><ul><li>REPLICATE_REWRITE_DB = kimdubi_db,kimdubi_db2<ul><li>앞의 kimdubi_db는 source DB의 논리DB, 뒤의 kimdubi_db2는 앞의 kimdubi_db를 rewrite 치환해서 slave에서 replication 받는 DB</li><li>relay log에서 kimdubi_db로 들어오고 sql_thread가 relaylog를 읽고 DB에 반영하면서 kimdubi_db2로 바꾸어 읽게 됨</li></ul></li></ul><h2 id=구성방법>구성방법<a hidden class=anchor aria-hidden=true href=#구성방법>#</a></h2><pre><code>mysql&gt; show variables like '%repository%';
+---------------------------+-------+
| Variable_name             | Value |
+---------------------------+-------+
| master_info_repository    | TABLE |
| relay_log_info_repository | TABLE |
+---------------------------+-------+
</code></pre><ul><li>MSR 설정을 위해서는 replication 관련 정보 repository 를 TABLE 에 저장해야함</li><li>master_info_repository=TABLE 의미는 Slave가 복제하는 MASTER DB의 status와 connection inforamtion 정보를 mysql.slave_master_info 에 저장하겠다는 의미</li><li>relay_log_info_repository=TABLE => 복제 관련 파일 및 포지션 정보를 mysql.slave_relay_log_info 에 저장</li><li>8.0부터 default TABLE</li></ul><h3 id=replication-channel-구성>replication channel 구성<a hidden class=anchor aria-hidden=true href=#replication-channel-구성>#</a></h3><pre><code>mysql&gt; change master to
    -&gt; master_host='172.17.0.6',
    -&gt; master_port=3306,
    -&gt; master_user='replUser',
    -&gt; master_password='!dlatl00',
    -&gt; master_log_file='mysql-bin.000011',
    -&gt; master_log_pos=789
    -&gt; for channel 'master_1';      &lt;============= 채널
Query OK, 0 rows affected, 2 warnings (0.05 sec)

mysql&gt; change master to
    -&gt; master_host='172.17.0.7',
    -&gt; master_port=3306,
    -&gt; master_user='replUser',
    -&gt; master_password='!dlatl00',
    -&gt; master_log_file='mysql-bin.000010',
    -&gt; master_log_pos=1099
    -&gt; for channel 'master_2';     &lt;============= 채널
Query OK, 0 rows affected, 2 warnings (0.04 sec)

mysql&gt; CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db1), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db1)) FOR CHANNEL 'master_1';
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CHANGE REPLICATION FILTER REPLICATE_DO_DB = (kimdubi_db2), REPLICATE_REWRITE_DB = (kimdubi_db, kimdubi_db2)) FOR CHANNEL 'master_2';
Query OK, 0 rows affected (0.01 sec)



mysql&gt; show slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 172.17.0.6
                  Master_User: replUser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000011
          Read_Master_Log_Pos: 992
               Relay_Log_File: relay-bin-master_1.000003
                Relay_Log_Pos: 322
        Relay_Master_Log_File: mysql-bin.000011
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes

              Replicate_Do_DB: kimdubi_db1

          Exec_Master_Log_Pos: 992
              Relay_Log_Space: 903
              Until_Condition: None

             Master_Server_Id: 64
                  Master_UUID: ba315763-e7e8-11e9-9c29-0242ac110002
             Master_Info_File: mysql.slave_master_info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
           Master_Retry_Count: 86400

         Replicate_Rewrite_DB: (kimdubi_db,kimdubi_db1)
                 Channel_Name: master_1

*************************** 2. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 172.17.0.7
                  Master_User: replUser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000010
          Read_Master_Log_Pos: 1302
               Relay_Log_File: relay-bin-master_2.000004
                Relay_Log_Pos: 322
        Relay_Master_Log_File: mysql-bin.000010
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: kimdubi_db2

          Exec_Master_Log_Pos: 1302
              Relay_Log_Space: 903

             Master_Server_Id: 2
                  Master_UUID: ba315763-e7e8-11e9-9c29-0242ac110002
             Master_Info_File: mysql.slave_master_info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
           Master_Retry_Count: 86400

         Replicate_Rewrite_DB: (kimdubi_db,kimdubi_db2)
                 Channel_Name: master_2

2 rows in set (0.00 sec)
</code></pre><h3 id=복제-테스트>복제 테스트<a hidden class=anchor aria-hidden=true href=#복제-테스트>#</a></h3><ul><li>MySQL 8.0</li></ul><pre><code>### MASTER_1 에서 수행
mysql&gt; use kimdubi_db;
Database changed

mysql&gt; create table test (t int);
Query OK, 0 rows affected (0.09 sec)

mysql&gt; insert into test values(1);
Query OK, 1 row affected (0.05 sec)


### MASTER_2 에서 수행
mysql&gt; use kimdubi_db;
Database changed
mysql&gt; create table test (t int);
Query OK, 0 rows affected (0.07 sec)

mysql&gt; insert into test values(2);
Query OK, 1 row affected (0.03 sec)


### SLAVE에서 데이터 확인
mysql&gt; select * from kimdubi_db1.test;
+------+
| t    |
+------+
|    1 |
+------+
1 row in set (0.01 sec)

mysql&gt; select * from kimdubi_db2.test;
+------+
| t    |
+------+
|    2 |
+------+
1 row in set (0.00 sec)
</code></pre><ul><li>MySQL 5.7</li></ul><pre><code>### MASTER_1 에서 수행
mysql&gt; use kimdubi_db;
Database changed

mysql&gt; create table test (t int);
Query OK, 0 rows affected (0.09 sec)

mysql&gt; insert into test values(1111111);
Query OK, 1 row affected (0.05 sec)


### MASTER_2 에서 수행
mysql&gt; use kimdubi_db;
Database changed
mysql&gt; create table test (t int);
Query OK, 0 rows affected (0.07 sec)

mysql&gt; insert into test values(222222);
Query OK, 1 row affected (0.03 sec)


### slave에서 조회
mysql&gt; select * from kimdubi_db2.tb_test;
Empty set (0.01 sec)

mysql&gt; select * from kimdubi_db1.tb_test;
+---------+
| a       |
+---------+
|  222222 |
| 1111111 |
+---------+
2 rows in set (0.01 sec)


### 데이터 깨짐 현상

### master_1
mysql&gt; select * from tb_test;
+---------+
| a       |
+---------+
| 1111111 |
+---------+
1 row in set (0.00 sec)

### 복제DB
mysql&gt; select * from tb_test;
+---------+
| a       |
+---------+
|   22222 |
| 1111111 |
+---------+
2 rows in set (0.00 sec)

### master_1
mysql&gt; set session binlog_format='STATEMENT';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; delete from tb_test where a &lt; 11111111;
Query OK, 1 row affected (0.01 sec)

### 복제DB
mysql&gt; select * from tb_test;
Empty set (0.00 sec)

=&gt; master_2 에서 받은 데이터도 모두 날아간 상태에서 master_2에서 해당 데이터에 대해 DML이 들어오면?

mysql&gt; show slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 172.17.0.4
                  Master_User: root
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000001
          Read_Master_Log_Pos: 4046
               Relay_Log_File: 8bb84cc87d63-relay-bin-master_1.000005
                Relay_Log_Pos: 856
        Relay_Master_Log_File: mysql-bin.000001
             Slave_IO_Running: Yes
            Slave_SQL_Running: No
              Replicate_Do_DB: master1,master2
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 1032
                   Last_Error: Could not execute Delete_rows event on table master1.tb_test; Can't find record in 'tb_test', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000001, end_log_pos 4015

</code></pre><h1 id=crash-safe-replication>crash safe replication<a hidden class=anchor aria-hidden=true href=#crash-safe-replication>#</a></h1><p><img loading=lazy src="https://github.com/kimdubi/kimdubi.github.io/blob/master/images/mysql/crash-safe.png?raw=true" alt>
변경사항 : crash_safe replication의 필수 설정 중 하나인 relay_log_info_repository 설정의 default 값이 FILE -> TABLE로 변경됨
MySQL 서버가 예기치 못한 장애로 인해 비정상 종료 되는 경우, SLAVE를 재기동 했을 때 복제가 원활하게 재개될수 있도록 하는 여러 설정 조합의 효과</p><ul><li>I/O thread가 relay log에 복제할 event를 기록하고 sync_master_info 파일에 기록하기 전에 MySQL서버가 비정상 종료되면,
MySQL을 재기동한 뒤 I/O thread가 위의 이벤트를 relay log에 또다시 기록해서 복제 duplicate 날 수 있음</li><li>SQL thread가 relay log에 기록된 트랜잭션을 커밋한 후 sync_relay_log_info 파일에 포지션 정보를 기록하기 전에 MySQL서버가 비정상 종료되면,
MySQL을 재기동한 뒤 위의 동일한 트랜잭션을 또 replay할 수 있음</li></ul><h2 id=crash-safe-replicaion-설정>crash-safe Replicaion 설정<a hidden class=anchor aria-hidden=true href=#crash-safe-replicaion-설정>#</a></h2><h3 id=필수>필수<a hidden class=anchor aria-hidden=true href=#필수>#</a></h3><ul><li>relay_log_info_repository=TABLE</li><li>relay_log_recovery = on</li></ul><h3 id=그-외-상황별-필요-파라미터>그 외 상황별 필요 파라미터<a hidden class=anchor aria-hidden=true href=#그-외-상황별-필요-파라미터>#</a></h3><table><thead><tr><th>variable</th><th>MySQL 5.7 (default)</th><th>MySQL 8.0 (default)</th><th>comment</th></tr></thead><tbody><tr><td>relay_log_recovery</td><td>OFF</td><td>OFF</td><td>필수 ON</td></tr><tr><td>relay_log_info_repository</td><td>FILE</td><td>TABLE</td><td>GTID 복제 시엔 필요없음 (mysql.gtid_executed가 대체)</td></tr><tr><td>sync_relay_log</td><td>10000</td><td>10000</td><td>MTS + slave_preserve_commit_order=0 일 땐 sync_relay_log = 1 필요</td></tr><tr><td>slave_preserve_commit_order</td><td>OFF</td><td>OFF / ON (MySQL 8.0.27이상부터는 ON)</td><td>권장값 ON (트랜잭션 갭 메울 필요 없어짐)</td></tr><tr><td>sync_binlog</td><td>1</td><td>1</td><td>GTID 복제 시 sync_binlog = 1 필요 (replica서버에서)</td></tr><tr><td>innodb_flush_log_at_trx_commit</td><td>1</td><td>1</td><td>GTID 복제 시 innodb_flush_log_at_trx_commit =1 필요 (replica서버에서)</td></tr></tbody></table><h3 id=동작-방식>동작 방식<a hidden class=anchor aria-hidden=true href=#동작-방식>#</a></h3><pre><code>### relay_log_info_repository = TABLE
begin;
insert into tb_test values(1);
update mysql.slave_relay_log_info set Relay_log_name='./relay-bin.000006',replay_log_pos=1356;
commit;

### relay_log_recovery = ON
2020-05-03T12:19:21.402872Z 0 [Warning] [MY-010539] [Repl] Recovery from master pos 1142 and file mysql-bin.000003 for channel ''. Previous relay log pos and relay log file had been set to 322, ./relay-bin.000014 respectively.
</code></pre><ul><li>relay_log_info_repository = TABLE 설정 시 위 처럼, SQL thread가 position 정보 업데이트와 실제 트랜잭션 처리를 원자적으로 수행함</li><li>반면 I/O thread는 실제 relay log 파일에도 쓰고, mysql.slave_master_info 테이블에도 update하는 작업을 sql thread처럼 원자적으로 수행할 수 없음<ul><li>relay_log_recovery = ON 설정 시 I/O thread의 포지션을 SQL thread가 마지막으로 실행했던 포지션으로 초기화 하고
새로운 relay log 파일을 생성해서 sql thread가 읽어야할 relay log position을 초기화하는 식으로 동작하게 하여
I/O thread의 문제를 해결할 수 있음</li></ul></li></ul><h3 id=mysqlslave_master_info-mysqlslave_relay_log_info-테이블-내용>mysql.slave_master_info, mysql.slave_relay_log_info 테이블 내용<a hidden class=anchor aria-hidden=true href=#mysqlslave_master_info-mysqlslave_relay_log_info-테이블-내용>#</a></h3><pre><code>mysql&gt; select * from slave_relay_log_info;
+-----------------+------------------------------------------+---------------+------------------+----------------+-----------+-------------------+----+--------------+
| Number_of_lines | Relay_log_name                           | Relay_log_pos | Master_log_name  | Master_log_pos | Sql_delay | Number_of_workers | Id | Channel_name |
+-----------------+------------------------------------------+---------------+------------------+----------------+-----------+-------------------+----+--------------+
|               7 | ./8bb84cc87d63-relay-bin-master_1.000005 |           856 | mysql-bin.000001 |           3763 |         0 |                 0 |  1 | master_1     |
|               7 | ./8bb84cc87d63-relay-bin-master_2.000004 |          1124 | mysql-bin.000001 |           3493 |         0 |                 0 |  1 | master_2     |
+-----------------+------------------------------------------+---------------+------------------+----------------+-----------+-------------------+----+--------------+
2 rows in set (0.00 sec)

mysql&gt; select * from slave_master_info;
+-----------------+------------------+----------------+------------+-----------+---------------+------+---------------+-------------+--------+------------+----------+------------+---------+------------------------+-----------+------+--------------------+--------------------------------------+-------------+---------+-------------+-----------------------+--------------+-------------+
| Number_of_lines | Master_log_name  | Master_log_pos | Host       | User_name | User_password | Port | Connect_retry | Enabled_ssl | Ssl_ca | Ssl_capath | Ssl_cert | Ssl_cipher | Ssl_key | Ssl_verify_server_cert | Heartbeat | Bind | Ignored_server_ids | Uuid                                 | Retry_count | Ssl_crl | Ssl_crlpath | Enabled_auto_position | Channel_name | Tls_version |
+-----------------+------------------+----------------+------------+-----------+---------------+------+---------------+-------------+--------+------------+----------+------------+---------+------------------------+-----------+------+--------------------+--------------------------------------+-------------+---------+-------------+-----------------------+--------------+-------------+
|              25 | mysql-bin.000001 |           3227 | 172.17.0.4 | root      | qhdks123      | 3306 |            60 |           0 |        |            |          |            |         |                      0 |        30 |      | 0                  | 6ee46ea8-753f-11ec-be3b-0242ac110004 |       86400 |         |             |                     0 | master_1     |             |
|              25 | mysql-bin.000001 |           2689 | 172.17.0.5 | root      | qhdks123      | 3306 |            60 |           0 |        |            |          |            |         |                      0 |        30 |      | 0                  | bfe2850b-753f-11ec-8148-0242ac110005 |       86400 |         |             |                     0 | master_2     |             |
+-----------------+------------------+----------------+------------+-----------+---------------+------+---------------+-------------+--------+------------+----------+------------+---------+------------------------+-----------+------+--------------------+--------------------------------------+-------------+---------+-------------+-----------------------+--------------+-------------+
2 rows in set (0.00 sec)
</code></pre><h1 id=semi-sync>semi-sync<a hidden class=anchor aria-hidden=true href=#semi-sync>#</a></h1><p>변경사항 : semi-sync의 동작방식이 after_commit -> after_sync로 변경됨</p><h2 id=after_commit>after_commit<a hidden class=anchor aria-hidden=true href=#after_commit>#</a></h2><p><img loading=lazy src="https://github.com/kimdubi/kimdubi.github.io/blob/master/images/mysql/after_commit.png?raw=true" alt></p><ol><li>User transaction commit</li><li>Engine prepare</li><li>Binlog flush</li><li>Binlog commit</li><li>Engine commit</li><li>Binlog dump thread send event with ACK Request</li><li>semi-sync wait (AFTER_COMMIT)</li><li>User Commit OK</li></ol><ul><li>7번 Slave가 data를 받았다는 응답을 기다리는 도중 Master가 down 되면
Master에서는 이미 Engine commit 까지 된 상황이기 때문에 새로 승격될 Slave에는 데이터가 없지만
Old Master에는 데이터가 존재하여 정합성이 깨짐</li><li>5번 engine commit 이 된 시점부터 다른 세션에서는 변경된 데이터를 읽을 수 있음 (phantom read) SLAVE로의 복제가 실패하면 이 트랜잭션은 Master에서 수동으로 rollback 처리해야함</li></ul><h2 id=after_sync>after_sync<a hidden class=anchor aria-hidden=true href=#after_sync>#</a></h2><p><img loading=lazy src="https://github.com/kimdubi/kimdubi.github.io/blob/master/images/mysql/after_sync.png?raw=true" alt></p><ol><li>User transaction commit</li><li>Engine prepare</li><li>Binlog flush</li><li>Binlog commit</li><li>Binlog dump thread send event with ACK Request</li><li>loss-less semisync wait (AFTER_SYNC)</li><li>Engine commit</li><li>User Commit OK</li></ol><ul><li>after_sync에서는 레플리카 서버에 복제되지 않았다면, 소스 서버에서도 engine commit까지 될 수 없기 때문에
after_commit의 phantom read 같은 경우가 발생하지 않음</li><li>engine commit이 늦춰져서 semi-sync에 대한 부담감이 높아질 수 있음<ul><li>아래 파라미터를 적절하게 변경해보자</li><li>rpl_semi_sync_master_timeout (default 10초)</li><li>rpl_semi_sync_master_wait_for_slave_count (default 1)</li></ul></li></ul><h1 id=binary-log-트랜잭션-압축>binary log 트랜잭션 압축<a hidden class=anchor aria-hidden=true href=#binary-log-트랜잭션-압축>#</a></h1><p>변경사항 : binlog_format = ROW으로 기록되는 트랜잭션에 대해 트랜잭션에서 변경한 데이터를 압축해서 바이너리 로그에 기록하는 기능이 추가도미</p><ul><li>트랜잭션에서 변경한 데이터를 zstd 알고리즘으로 압축</li><li>transaction_payload_event라는 이벤트로 바이너리 로그에 기록</li><li>압축된 상태로 레플리카 서버의 relay log에 기록됨</li><li>압축 해제 후 레플리카 서버에 반영됨</li><li>마스터 뿐만 아니라 리플리카도 압축 기능을 지원하는 MySQL 버전을 사용해야함</li><li>효과는 압축률 50%정도, 네트워크 사용량은 1/3 정도, CPU는 조금 더 쓰는 정도</li></ul><h3 id=관련-파라미터>관련 파라미터<a hidden class=anchor aria-hidden=true href=#관련-파라미터>#</a></h3><ul><li>binlog_transaction_compression (default OFF )</li><li>binlog_transaction_compression_level_zstd (default 3)</li><li>performance-schema-instrument=&ldquo;stage/sql/%compressing_transaction_changes.=ON&rdquo;</li><li>protocol_compression_algorithms=&lsquo;zlib,zstd,uncompressed&rsquo;;</li></ul><h3 id=limitation>limitation<a hidden class=anchor aria-hidden=true href=#limitation>#</a></h3><ul><li>GTID 설정 관련 이벤트</li><li>복제 구성에서 heartbeat 관련 이벤트</li><li>복제 실패 / 데이터 불일치를 발생시킬 수 있는 incident 타입의 이벤트(?)</li><li>트랜잭션을 지원하지 않는 스토리지 엔진에 대한 이벤트</li><li>binlog_format = statement 로 기록되는 이벤트</li></ul><h3 id=구성-방법>구성 방법<a hidden class=anchor aria-hidden=true href=#구성-방법>#</a></h3><pre><code>mysql&gt; change master to
    -&gt; master_host='172.17.0.6',
    -&gt; master_port=3306,
    -&gt; master_user='replUser',
    -&gt; master_password='!dlatl00',
    -&gt; master_log_file='mysql-bin.000011',
    -&gt; master_log_pos=789
    -&gt; source_compression_algorithms='zstd',
    -&gt; source_zstd_compression_level=7;
</code></pre><h1 id=delayed-replication>delayed replication<a hidden class=anchor aria-hidden=true href=#delayed-replication>#</a></h1><p>변경사항 : binary log에 OCT, ICT timestamp가 추가되었고 특히 ICT는 delayed replication의 기준으로 작용함</p><h3 id=original_commit_timestamp-oct>original_commit_timestamp (OCT)<a hidden class=anchor aria-hidden=true href=#original_commit_timestamp-oct>#</a></h3><ul><li>트랜잭션이 원본 소스 서버에서 커밋된 시각</li></ul><h3 id=immediate_commit_timestamp-ict>immediate_commit_timestamp (ICT)<a hidden class=anchor aria-hidden=true href=#immediate_commit_timestamp-ict>#</a></h3><ul><li>트랜잭션이직계 소스 서버에서 커밋된 시각</li></ul><h3 id=어디에-쓰이는고>어디에 쓰이는고<a hidden class=anchor aria-hidden=true href=#어디에-쓰이는고>#</a></h3><ul><li>체인 복제 구성 + delayed replication의 구조에서 의미가 있는 듯</li><li>원본 소스 서버에서는 OCT == ICT</li><li>레플리카 서버(log_slave_updates = ON)에서는 ICT 값이 복제된 트랜잭션이 커밋된 시점으로 기록되기 때문에 OCT != ICT
MySQL 8.0 미만의 체인복제 구성에서 delayed replication의 지연 측정 기준이 원본 소스의 시각으로 측정되던 부분이 직계 소스 서버를 기준으로 할 수 있도록 개선되었음</li></ul><h1 id=multi-threaded-replication>multi-threaded replication<a hidden class=anchor aria-hidden=true href=#multi-threaded-replication>#</a></h1><p>변경사항 : multi-thread-replication의 slave_parallel_type=&lsquo;logical_clock&rsquo; 방식 중 writeset 방식이 추가됨</p><h3 id=관련-파라미터-1>관련 파라미터<a hidden class=anchor aria-hidden=true href=#관련-파라미터-1>#</a></h3><table><thead><tr><th>variable</th><th>MySQL 5.7 (default)</th><th>MySQL 8.0 (default)</th><th>comment</th></tr></thead><tbody><tr><td>slave_parallel_type</td><td>DATABASE</td><td>8.0.27 >= LOGICAL_CLOCK / 미만 DATABASE</td><td></td></tr><tr><td>slave_parallel_workers</td><td>1</td><td>8.0.27 >= 4 / 미만 1</td><td></td></tr><tr><td>slave_pending_jobs_size_max</td><td>16MB</td><td>128MB</td><td>max_allowed_packet 보다 클 수 없음</td></tr><tr><td>binlog_transaction_dependency_tracking</td><td>COMMIT_ORDER</td><td>COMMIT_ORDER</td><td></td></tr><tr><td>slave_preserve_commit_order</td><td>OFF</td><td>8.0.27 >= ON / 미만 OFF</td><td>mysql 8.0.18 이하 버전에서 ON 하려면 log_slave_updates =ON 설정도 필요함</td></tr><tr><td>binlog_order_commits</td><td>ON</td><td>ON</td><td>replication source 서버에 설정</td></tr><tr><td>binlog_format</td><td>ROW</td><td>ROW</td><td>writeset을 사용하기 위해서는 ROW 포맷 필요</td></tr></tbody></table><pre><code>## slave_pending_jobs_size_max가 작을 때 발생 가능 에러

Cannot schedule event Update_rows, relay-log relay-bin.0000,position 0000 to Worker thread because its size 21206802 exceeds 16777216 of slave_pending_jobs_size_max

## slave_preserve_commit_order ON 꼬였을 때 발생 가능 에러

ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR
slave-preserve-commit-order가 활성화되었을 때 적어도 하나의 이전 작업자에 오류가 발생한 후 슬레이브 작업자가 중지되었습니다. 커밋 순서를 유지하기 위해 이 스레드에서 실행한 마지막 트랜잭션이 커밋되지 않았습니다. 실패한 스레드를 수정한 후 슬레이브를 다시 시작할 때 이 작업자도 수정해야 합니다.
</code></pre><h3 id=database>database<a hidden class=anchor aria-hidden=true href=#database>#</a></h3><ul><li>처음 multi threaded replication이 도입되었을 때 지원하던 방식으로 논리DB 단위로 병렬처리를 수행함</li><li>MySQL 서버에 논리DB가 하나밖에 존재하지 않거나, 각 논리DB별 쓰기 부하가 일정하지 않으면 효과가 없거나 떨어짐</li><li>slave_parallel_type=&lsquo;DATABASE&rsquo;</li></ul><h3 id=logical>logical<a hidden class=anchor aria-hidden=true href=#logical>#</a></h3><ul><li>소스 서버에서 트랜잭션들이 binary log로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해 레플리카 서버에서 트랜잭션의 순번 값을 바탕으로 병렬 복제 수행하는 기능</li><li>database type과는 달리 동일 논리DB여도 병렬 복제 가능<ul><li>group commit 단위로 할당하기 때문</li></ul></li><li>commit-parent 기반 logical clock<ul><li>MySQL 5.7.2 ~ 5.7.5버전에서 사용됨</li><li>소스서버에서 커밋 시점이 같은 트랜잭션들을 병렬 복제 처리함</li><li>커밋 시점이 같은 트랜잭션인지 식별은 commit_seq_no 값을 binary log에 같이 기록해서 식별함</li></ul></li><li>lock 기반 logical clock<ul><li>MySQL 5.7.6 버전 ~</li><li>commit_seq_no 값이 달라도 커밋 처리 시점이 겹친다면 레플리카 서버에서 병렬 복제처리 가능</li><li>이를 위해 binary log에 sequence_number, last_committed라는 값을 함께 기록함<ul><li>sequence_number : 커밋된 트랜잭션에 대한 논리적인 순번 값</li><li>last_committed : 현 트랜잭션 이전의 가장 최근의 트랜잭션의 sequence_number</li><li>실행하려는 트랜잭션의 last_committed 값 &lt; 현재 실행 중인 트랜잭션들이 가지는 가장 작은 sequence_number 를 만족하는 트랜잭션들을 병렬처리함</li><li>예시에서는 txn+1의 C &lt; txn 의 S 일때 병렬복제 가능</li></ul></li></ul></li><li>커밋시점이 겹치는 트랜잭션들을 늘려 병렬 복제 트랜잭션을 늘리기 위해 binlog_group_commit_sync_delay / binlog_group_commit_sync_no_delay_count를 같은 파라미터를 적절히 설정하기도함</li></ul><pre><code># at 4485
#220118 13:41:09 server id 1  end_log_pos 4550 CRC32 0x2ad8ee5f         Anonymous_GTID  last_committed=17       sequence_number=18
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
</code></pre><h3 id=writeset>writeset<a hidden class=anchor aria-hidden=true href=#writeset>#</a></h3><p>logical_clock 의 방식 중 하나</p><ul><li>binlog_transaction_dependency_tracking<ul><li>commit_order : 기존 MySQL 5.7의 lock 기반 logical clock으로 동작</li><li>writeset : 서로 다른 데이터를 변경한 트랜잭션들은 모두 병렬로 처리할 수 있음 (base는 commit_order지만 last_committed 부분을 처리하는 부분이 다름 p.536 )</li><li>wrtieset_session : 동일한 세션에서 실행된 트랜잭션들을 제외한 트랜잭션만 병렬 처리</li></ul></li><li>소스 서버의 트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬 처리 가능 여부를 결정함<ul><li>변경된 데이터를 hashing해서 writeset 으로 표현함<ul><li>table에 존재하는 unique한 key의 개수 만큼 생성됨</li></ul></li></ul></li></ul><pre><code>writeset=hash(index_name,db_name,db_name_length,table_name,table_name_length,value,value_length)

mysql&gt; use test;
mysql&gt; show create table jj10 \G
*************************** 1. row ***************************
       Table: jj10
Create Table: CREATE TABLE `jj10` (
  `id1` int(11) DEFAULT NULL,
  `id2` int(11) DEFAULT NULL,
  `id3` int(11) NOT NULL,
  PRIMARY KEY (`id3`),
  UNIQUE KEY `id1` (`id1`),
  KEY `id2` (`id2`)

$ insert into jj10 values(36,36,36);


### pk
(gdb) p pke
$1 = &quot;PRIMARY?test?4jj10?40

### UK
(gdb) p pke
$4 = &quot;id1?test?4jj10?436?2&quot;
=&gt; 이거를 해싱하여 writeset으로 변환
</code></pre><ul><li>위에서 생성된 writeset과 해당 데이터를 변경한 트랜잭션의 sequence_number 값이 key-value 형태로 해시맵 테이블에 저장됨</li><li>writeset으로 구성된 새로운 트랜잭션이 실행되면 위의 writeset 히스토리 테이블과 비교하여 충돌되는 wirteset이 있는지 비교하고 last_committed 값을 보정함</li><li>writeset 변환을 위한 추가 리소스, writeset 히스토리 테이블 구성을 위한 추가 메모리가 필요</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/replication/>replication</a></li></ul><nav class=paginav><a class=next href=/mysql/innodb_sort_buffer_size/><span class=title>Next Page »</span><br><span>MySQL innodb_sort_buffer_size</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>