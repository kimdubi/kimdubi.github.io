<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 대용량 테이블 DDL할 때 주의할 사항들 | kimDuBiA</title><meta name=keywords content="mysql,gdb,ddl,debugging"><meta name=description content="배경 pt-osc를 사용하지 않은 대용량 테이블 DDL 작업 시 실패할 수 있는 시나리오를 정리하고 각 케이스 별 준비사항과 모니터링 방법을 확인한다
실패하는 케이스는 아니어도, 무심코 놓치면 위험한 케이스도 정리하였다
요약    300GB가 넘는 테이블 작업은 피할 수 있다면 피하자
 컬럼 추가 같이 rebuild 가 필요한 작업은 child 테이블 생성 후 join 해서 쓰는 모델링 관점으로 풀도록 개발팀에 안내한다    pt-osc를 사용하는 경우 DB부하는 훨씬 줄어들지만 시간 예측이 더 어려울 수 있으니 꼼꼼히 확인해보자"><meta name=author content="kimdubi"><link rel=canonical href=/mysql/ddl_failcase/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.2dbef8664bbfb3e83a0a44fd4a8fc5010240dbcd1dbc1400753b928b497b8f5e.css integrity="sha256-Lb74Zku/s+g6CkT9So/FAQJA280dvBQAdTuSi0l7j14=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="MySQL 대용량 테이블 DDL할 때 주의할 사항들"><meta property="og:description" content="배경 pt-osc를 사용하지 않은 대용량 테이블 DDL 작업 시 실패할 수 있는 시나리오를 정리하고 각 케이스 별 준비사항과 모니터링 방법을 확인한다
실패하는 케이스는 아니어도, 무심코 놓치면 위험한 케이스도 정리하였다
요약    300GB가 넘는 테이블 작업은 피할 수 있다면 피하자
 컬럼 추가 같이 rebuild 가 필요한 작업은 child 테이블 생성 후 join 해서 쓰는 모델링 관점으로 풀도록 개발팀에 안내한다    pt-osc를 사용하는 경우 DB부하는 훨씬 줄어들지만 시간 예측이 더 어려울 수 있으니 꼼꼼히 확인해보자"><meta property="og:type" content="article"><meta property="og:url" content="/mysql/ddl_failcase/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="mysql"><meta property="article:published_time" content="2024-07-28T14:28:05+09:00"><meta property="article:modified_time" content="2024-07-28T14:28:05+09:00"><meta property="og:site_name" content="kimDuBiA"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="MySQL 대용량 테이블 DDL할 때 주의할 사항들"><meta name=twitter:description content="배경 pt-osc를 사용하지 않은 대용량 테이블 DDL 작업 시 실패할 수 있는 시나리오를 정리하고 각 케이스 별 준비사항과 모니터링 방법을 확인한다
실패하는 케이스는 아니어도, 무심코 놓치면 위험한 케이스도 정리하였다
요약    300GB가 넘는 테이블 작업은 피할 수 있다면 피하자
 컬럼 추가 같이 rebuild 가 필요한 작업은 child 테이블 생성 후 join 해서 쓰는 모델링 관점으로 풀도록 개발팀에 안내한다    pt-osc를 사용하는 경우 DB부하는 훨씬 줄어들지만 시간 예측이 더 어려울 수 있으니 꼼꼼히 확인해보자"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Mysqls","item":"/mysql/"},{"@type":"ListItem","position":3,"name":"MySQL 대용량 테이블 DDL할 때 주의할 사항들","item":"/mysql/ddl_failcase/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 대용량 테이블 DDL할 때 주의할 사항들","name":"MySQL 대용량 테이블 DDL할 때 주의할 사항들","description":"배경 pt-osc를 사용하지 않은 대용량 테이블 DDL 작업 시 실패할 수 있는 시나리오를 정리하고 각 케이스 별 준비사항과 모니터링 방법을 확인한다\n실패하는 케이스는 아니어도, 무심코 놓치면 위험한 케이스도 정리하였다\n요약    300GB가 넘는 테이블 작업은 피할 수 있다면 피하자\n 컬럼 추가 같이 rebuild 가 필요한 작업은 child 테이블 생성 후 join 해서 쓰는 모델링 관점으로 풀도록 개발팀에 안내한다    pt-osc를 사용하는 경우 DB부하는 훨씬 줄어들지만 시간 예측이 더 어려울 수 있으니 꼼꼼히 확인해보자","keywords":["mysql","gdb","ddl","debugging"],"articleBody":"배경 pt-osc를 사용하지 않은 대용량 테이블 DDL 작업 시 실패할 수 있는 시나리오를 정리하고 각 케이스 별 준비사항과 모니터링 방법을 확인한다\n실패하는 케이스는 아니어도, 무심코 놓치면 위험한 케이스도 정리하였다\n요약    300GB가 넘는 테이블 작업은 피할 수 있다면 피하자\n 컬럼 추가 같이 rebuild 가 필요한 작업은 child 테이블 생성 후 join 해서 쓰는 모델링 관점으로 풀도록 개발팀에 안내한다    pt-osc를 사용하는 경우 DB부하는 훨씬 줄어들지만 시간 예측이 더 어려울 수 있으니 꼼꼼히 확인해보자\n 테이블 사이즈 뿐만 아니라 PK의 big int / UUID 여부 , auto increment가 어디까지 할당되어있는지, 테이블의 건 수 등도 큰 영향을 끼친다    설득이 실패한 경우 공통 준비사항\n DB 설정     set session lock_wait_timeout = 120; = 단, 이 설정으로 인해 서비스쿼리들이 메타락 대기로 쭉 밀릴 수 있기 때문에 주의할 것. 롱쿼리,롱트래잭션이 없는 서비스라면 기존 5초 설정도 충분함 innodb_online_alter_log_max_size = 10737418240 (클러스터 파라미터그룹) = 온라인 dml 버퍼 1GB → 10GB 증가시켜 놓고 작업할것 innodb_adaptive_hash_index = OFF = DDL 수행 시 hash index 메모리에 있던 대상 테이블의 데이터들이 한번 쭉 비워짐 이때 hash index가 클수록 그 부하가 커지고 디비 전체가 행 걸리는 것 같은 이슈가 발생하면서 세션이 순간적으로 쭉 밀리는 현상이 발생할 수 있음  인덱스 추가 시  작업시간 산정 : 테이블 사이즈 (data) 1GB 당 30초 (파티션 테이블의 경우 파티션 개수마다 차이가 있지만 보통 1.5배로 계산) 테이블 사이즈 만큼의 Free Local Storage(tmpdir) 를 확보한다 부족하면 스펙업할 것  스펙 별 local storage    instance class\tlocal storage(GB) db.r6i.32xlarge\t2560 db.r6i.24xlarge\t1920 db.r6i.16xlarge\t1,280 db.r6i.12xlarge\t960 db.r6i.8xlarge\t640 db.r6i.4xlarge\t320 db.r6i.2xlarge\t160 db.r6i.xlarge\t80 db.r6i.large\t32 db.t4g.xlarge\t32 db.t4g.medium\t32 db.t3.large\t32 db.t3.medium\t32 db.t3.small\t32 db.t2.medium\t32 db.t2.small\t32  컬럼 추가 등 기타 inplace  작업시간 산정 : 테이블 사이즈 (data + index) 1GB 당 1분 (파티션 테이블의 경우 파티션 개수마다 차이가 있지만 보통 1.5배로 계산)   varchar 컬럼 길이 변경 시엔 반드시 인덱스에 포함된 컬럼인지 확인할것(aurora 2 한정)  mysql 5.7.12 버전의 버그로 metadata만 변경하고 바로 완료되는 구간이어도 inplace로 동작하게됨    모니터링 DB 리소스 측면에서는 아래 두 메트릭을 확인한다\n이 중 Freeable Memory는 index 추가, 컬럼 추가 등 모든 DDL 공통으로 사용하고\nFree Local Storage는 index 작업시에만 사용한다. (onpremise mysql에서 /tmpdir 을 사용하는 것과 동일하다)\n두 메트릭 중 하나라도 소진하는 경우 작업이 실패하게 되고\n특히 Freeable Memory는 작업이 끝나도 작업시 사용한 메모리가 모두 반환되는 게 아니기 때문에\n이 메모리가 부족한 경우엔 DB재기동 등을 통해 회수해주는 것이 좋다\n쿼리 측면에서는 DDL 진행도를 파악하여 쿼리 예상 종료시간을 예측해볼 수 있다\n### 사전 준비 mysql UPDATE performance_schema.setup_instruments SET ENABLED = 'YES' WHERE NAME LIKE 'stage/innodb/alter%'; mysql UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' WHERE NAME LIKE 'events_stages%'; ### DDL 진행도 파악 mysql SELECT esc.THREAD_ID , esc.SQL_TEXT , estc.EVENT_NAME , estc.WORK_COMPLETED , estc.WORK_ESTIMATED , ( 100 * estc.WORK_COMPLETED / estc.WORK_ESTIMATED ) AS 'Progress_%' FROM performance_schema.events_statements_current esc, performance_schema.events_stages_current estc WHERE estc.THREAD_ID = esc.THREAD_ID AND estc.NESTING_EVENT_ID = esc.EVENT_ID; +-----------+------------------------------------------------------------------+---------------------------------------+----------------+----------------+------------+ | THREAD_ID | SQL_TEXT | EVENT_NAME | WORK_COMPLETED | WORK_ESTIMATED | Progress_% | +-----------+------------------------------------------------------------------+---------------------------------------+----------------+----------------+------------+ | 79261 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) | 379860 | 554662 | 68.4850 | +-----------+------------------------------------------------------------------+---------------------------------------+----------------+----------------+------------+ 1 row in set (0.01 sec) == 379860 , 554662 숫자가 의미하는 건 테이블의 row 수가 아니라 작업량을 page 수로 표현한 의미라한다. ### 컬럼 추가 mysql SELECT pseshl.EVENT_ID - , pseshl.NESTING_EVENT_ID - , esh.SQL_TEXT - , pseshl.EVENT_NAME - , sys.format_time(pseshl.TIMER_WAIT) - FROM performance_schema.events_stages_history_long pseshl - , performance_schema.events_statements_history esh - WHERE pseshl.NESTING_EVENT_ID = esh.EVENT_ID - ORDER BY pseshl.NESTING_EVENT_ID, pseshl.TIMER_START - limit 5; +----------+------------------+----------------------------------------------------------------------+------------------------------------------------------+------------------------------------+ | EVENT_ID | NESTING_EVENT_ID | SQL_TEXT | EVENT_NAME | sys.format_time(pseshl.TIMER_WAIT) | +----------+------------------+----------------------------------------------------------------------+------------------------------------------------------+------------------------------------+ | 147 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) | 4.60 s | | 148 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (insert) | 4.24 s | | 149 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) | 5.43 s | | 150 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (insert) | 5.64 s | | 151 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) | 5.84 s | | 152 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (insert) | 5.71 s | | 153 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) | 6.30 s | | 154 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (insert) | 5.38 s | | 155 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (flush) | 5.64 us | | 156 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (log apply table) | 113.96 us | | 157 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (end) | 17.33 us | | 158 | 146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (log apply table) | 521.72 ms | ### 인덱스 추가 | 160 | 159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (read PK and internal sort) | 5.07 s | | 161 | 159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) | 4.47 s | 케이스 정리 실패 case 1. Free Local Storage 부족  index 추가 시엔 Local Storage를 사용하는데 이 때 작업 테이블 사이즈만큼의 공간을 필요로 하고, 부족한 경우엔 작업이 실패함\nadd column 같은 rebuild DDL은 local storage가 아니라 datadir (클러스터볼륨)을 사용하기 때문에 걱정이없다\n340GB 테이블에 인덱스를 추가할 때\n2xlarge의 경우 Free Local Storage 공간이 부족하여 작업이 실패하였고\n4xlarge의 경우 거의 300GB만큼의 공간을 사용한 뒤 성공하였음\nERROR 1878 (HY000) Temporary file write failure 발생\n실패 case 2. online dml buffer 부족 online DDL 수행 중 테이블의 변경사항은 innodb_online_alter_log_max_size 설정값(default 1GB) 만큼 innodb_online_alter_log buffer에 보관할 수 있게 되는데 이것이 부족한 경우 작업이 실패한다\n작업 초반부에 버퍼가 초과해도 바로 에러가 발생하는 게 아니라 작업 막바지에 buffer 데이터 반영하는 시점에 실패하게 되기 때문에 제일 가슴이 아픈 케이스다\n실패 case 3. metadata lock timeout +-------+-----------------+--------------------+------+-------------+--------+---------------------------------------------------------------+-----------------------------------------------------------------+ | Id | User | Host | db | Command | Time | State | Info | +-------+-----------------+--------------------+------+-------------+--------+---------------------------------------------------------------+-----------------------------------------------------------------+ | 79231 | master | 172.27.2.39:52353 | test | Query | 112 | Waiting for table metadata lock | alter table t1 add column t0720 int,algorithm=inplace,lock=none | | 79412 | master | 172.27.2.39:52920 | test | Sleep | 108 | NULL | NULL | | 79418 | master | 172.27.2.39:52925 | test | Query | 25 | Waiting for table metadata lock | select * from t1 limit 1 | | 79425 | master | 172.27.2.39:52935 | test | Query | 3 | Waiting for table metadata lock | select * from t1 limit 1 | | 79428 | master | 172.27.2.39:52937 | NULL | Query | 0 | starting | show processlist | +-------+-----------------+--------------------+------+-------------+--------+---------------------------------------------------------------+-----------------------------------------------------------------+ mysql alter table t1 add column t0720 int,algorithm=inplace,lock=none; ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 79412 세션이 t1 테이블에 대한 트랜잭션(롱 쿼리)을 유지하고 있어서 DDL이 메타락을 획득하지 못하고 대기하다가 timeout이 발생하는 케이스\n문제는 DDL 컬럼이 메타락을 획득하려고 시도하는 동안,\n그 뒤로 들어오는 해당 테이블을 사용하는 모든 쿼리들도 메타락 대기를 하게 되어 서비스 장애가 발생할 수 있기 때문에 제일 무서운 케이스라고 볼 수 있다\n실패 case 4. fulltext index 테이블에 online DDL 시도 CREATE TABLE `t1` ( `tid` int(11) NOT NULL AUTO_INCREMENT, `TABLE_NAME` varchar(64) DEFAULT NULL, `COLUMN_NAME` varchar(64) DEFAULT NULL, `ORDINAL_POSITION` int(11) DEFAULT NULL, `ttt` varchar(30) NOT NULL, `ttt2` varchar(20) DEFAULT NULL, `ttt3` varchar(10) DEFAULT NULL, `tttt2` int(11) DEFAULT NULL, `tttt444` int(11) DEFAULT NULL, `ttt55` varchar(20) NOT NULL, `ttt66` int(11) DEFAULT NULL, `t07202` int(11) DEFAULT NULL, PRIMARY KEY (`tid`,`ttt`), KEY `idx` (`ttt`), KEY `idx_0710` (`ttt55`), KEY `idx_0711` (`ttt55`), KEY `idx_0712` (`ttt55`), KEY `idx0720` (`t07202`), KEY `idx07202` (`t07202`), FULLTEXT KEY `idx1` (`ttt`) ) ENGINE=InnoDB AUTO_INCREMENT=1000000042 DEFAULT CHARSET=utf8mb4 mysql alter table t1 add column t07203 int,algorithm=inplace,lock=none; ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: InnoDB presently supports one FULLTEXT index creation at a time. Try ALGORITHM=COPY. mysql alter table t1 add index idx00 (t07202),algorithm=inplace,lock=none; Query OK, 0 rows affected, 1 warning (15.09 sec) 컬럼 추가 같은 rebuild 작업이 inplace로 안되는 모습\ninplace로 동작할줄알고 algorithm=inplace,lock=none; 구문 제외하는 순간 COPY방식으로 동작하여 장애가 날 수 있다\n반면 인덱스 추가는 inplace로 되는 모습\n실패 case 5. index걸린 컬럼 varchar size 변경 시도 (aurora2 , mysql 5.7.12 한정)  CREATE TABLE `t1` ( `tid` int(11) NOT NULL AUTO_INCREMENT, `TABLE_NAME` varchar(64) DEFAULT NULL, `COLUMN_NAME` varchar(64) DEFAULT NULL, `ORDINAL_POSITION` int(11) DEFAULT NULL, `ttt` varchar(30) NOT NULL, `ttt2` varchar(10) DEFAULT NULL, `ttt3` varchar(10) DEFAULT NULL, `tttt2` int(11) DEFAULT NULL, `tttt444` int(11) DEFAULT NULL, `ttt55` varchar(10) NOT NULL, `ttt66` int(11) DEFAULT NULL, `t07202` int(11) DEFAULT NULL, PRIMARY KEY (`tid`,`ttt`), KEY `idx` (`ttt`), KEY `idx_0710` (`ttt55`), KEY `idx_0711` (`ttt55`), KEY `idx_0712` (`ttt55`), KEY `idx0720` (`t07202`), KEY `idx07202` (`t07202`) ) ENGINE=InnoDB AUTO_INCREMENT=1000000042 DEFAULT CHARSET=utf8mb4 | +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.01 sec) mysql alter table t1 modify ttt2 varchar(20),algorithm=inplace,lock=none; Query OK, 0 rows affected (0.09 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql alter table t1 modify ttt55 varchar(20) not null,algorithm=inplace,lock=none; Query OK, 0 rows affected (46.57 sec) Records: 0 Duplicates: 0 Warnings: 0 인덱스가 걸려있지 않은 컬럼은 metadata만 변경해서 바로 되는 반면\n인덱스 걸려있는 컬럼은 inplace로 동작한다\n실패 case 6. 컬럼 추가한 뒤 바로 인덱스 걸어주는 경우 대용량 테이블에 컬럼을 추가와 해당 컬럼에 대해서만 인덱스 추가가 바로 진행되는 경우\n해당 인덱스의 카디날리티는 당연히 1 이다 (NULL값, 혹은 default값)\n인덱스가 생성됐다고 바로 쿼리가 배포되는 순간\n통계가 갱신되기 전 까지는 카디날리티가 1이기 때문에 인덱스를 못타고 풀스캔을 하게 된다\n그러나 통계가 갱신되려면 전체 테이블 Row의 10%만큼 해당되는 변화가 있어야하는데 자주 갱신되기는 쉽지않다. 이런 DDL 요청이 오는 경우 개발팀에 아래 사례를 공유하며 DDL과 쿼리 배포의 텀을 길게 하여 그 사이에 통계 갱신이 되도록 하거나 신규 컬럼 단일 인덱스를 생성하기 보다는 선별도 높은 다른 컬럼과 함께 쿼리와 인덱스에 추가하도록 한다\n","wordCount":"1758","inLanguage":"en","datePublished":"2024-07-28T14:28:05+09:00","dateModified":"2024-07-28T14:28:05+09:00","author":{"@type":"Person","name":"kimdubi"},"mainEntityOfPage":{"@type":"WebPage","@id":"/mysql/ddl_failcase/"},"publisher":{"@type":"Organization","name":"kimDuBiA","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Hi (Alt + H)">Hi</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=/ title=Home><span>Home</span></a></li><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/mysql/>Mysqls</a></div><h1 class=post-title>MySQL 대용량 테이블 DDL할 때 주의할 사항들</h1><div class=post-meta>July 28, 2024&nbsp;·&nbsp;9 min&nbsp;·&nbsp;kimdubi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%b0%b0%ea%b2%bd aria-label=배경>배경</a></li><li><a href=#%ec%9a%94%ec%95%bd aria-label=요약 >요약 </a></li><li><a href=#%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81 aria-label=모니터링>모니터링</a></li><li><a href=#%ec%bc%80%ec%9d%b4%ec%8a%a4-%ec%a0%95%eb%a6%ac aria-label="케이스 정리">케이스 정리</a><ul><li><a href=#%ec%8b%a4%ed%8c%a8-case-1-free-local-storage-%eb%b6%80%ec%a1%b1 aria-label="실패 case 1.  Free Local Storage 부족 ">실패 case 1.  Free Local Storage 부족 </a></li><li><a href=#%ec%8b%a4%ed%8c%a8-case-2-online-dml-buffer-%eb%b6%80%ec%a1%b1 aria-label="실패 case 2. online dml buffer 부족">실패 case 2. online dml buffer 부족</a></li><li><a href=#%ec%8b%a4%ed%8c%a8-case-3-metadata-lock-timeout aria-label="실패 case 3. metadata lock timeout">실패 case 3. metadata lock timeout</a></li><li><a href=#%ec%8b%a4%ed%8c%a8-case-4-fulltext-index-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-online-ddl-%ec%8b%9c%eb%8f%84 aria-label="실패 case 4. fulltext index 테이블에 online DDL 시도">실패 case 4. fulltext index 테이블에 online DDL 시도</a></li><li><a href=#%ec%8b%a4%ed%8c%a8-case-5-index%ea%b1%b8%eb%a6%b0-%ec%bb%ac%eb%9f%bc-varchar-size-%eb%b3%80%ea%b2%bd-%ec%8b%9c%eb%8f%84-aurora2--mysql-5712-%ed%95%9c%ec%a0%95 aria-label="실패 case 5.  index걸린 컬럼 varchar size 변경 시도 (aurora2 , mysql 5.7.12 한정)">실패 case 5.  index걸린 컬럼 varchar size 변경 시도 (aurora2 , mysql 5.7.12 한정)</a></li><li><a href=#%ec%8b%a4%ed%8c%a8-case-6-%ec%bb%ac%eb%9f%bc-%ec%b6%94%ea%b0%80%ed%95%9c-%eb%92%a4-%eb%b0%94%eb%a1%9c-%ec%9d%b8%eb%8d%b1%ec%8a%a4-%ea%b1%b8%ec%96%b4%ec%a3%bc%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="실패 case 6. 컬럼 추가한 뒤 바로 인덱스 걸어주는 경우">실패 case 6. 컬럼 추가한 뒤 바로 인덱스 걸어주는 경우</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h1><p>pt-osc를 사용하지 않은 대용량 테이블 DDL 작업 시 실패할 수 있는 시나리오를 정리하고 각 케이스 별 준비사항과 모니터링 방법을 확인한다<br>실패하는 케이스는 아니어도, 무심코 놓치면 위험한 케이스도 정리하였다</p><h1 id=요약>요약 <a hidden class=anchor aria-hidden=true href=#요약>#</a></h1><ul><li><p>300GB가 넘는 테이블 작업은 피할 수 있다면 피하자</p><ul><li>컬럼 추가 같이 rebuild 가 필요한 작업은 child 테이블 생성 후 join 해서 쓰는 모델링 관점으로 풀도록 개발팀에 안내한다</li></ul></li><li><p>pt-osc를 사용하는 경우 DB부하는 훨씬 줄어들지만 시간 예측이 더 어려울 수 있으니 꼼꼼히 확인해보자</p><ul><li>테이블 사이즈 뿐만 아니라 PK의 big int / UUID 여부 , auto increment가 어디까지 할당되어있는지, 테이블의 건 수 등도 큰 영향을 끼친다</li></ul></li><li><p>설득이 실패한 경우 공통 준비사항</p><ul><li>DB 설정 </li></ul></li></ul><pre><code>set session lock_wait_timeout = 120;
=&gt; 단, 이 설정으로 인해 서비스쿼리들이 메타락 대기로 쭉 밀릴 수 있기 때문에 주의할 것. 롱쿼리,롱트래잭션이 없는 서비스라면 기존 5초 설정도 충분함  

innodb_online_alter_log_max_size = 10737418240 (클러스터 파라미터그룹)
=&gt; 온라인 dml 버퍼 1GB → 10GB 증가시켜 놓고 작업할것  

innodb_adaptive_hash_index = OFF
=&gt; DDL 수행 시 hash index 메모리에 있던 대상 테이블의 데이터들이 한번 쭉 비워짐  
이때 hash index가 클수록 그 부하가 커지고 디비 전체가 행 걸리는 것 같은 이슈가 발생하면서 세션이 순간적으로 쭉 밀리는 현상이 발생할 수 있음  

</code></pre><ul><li>인덱스 추가 시 <ul><li>작업시간 산정 : 테이블 사이즈 (data) 1GB 당 30초 (파티션 테이블의 경우 파티션 개수마다 차이가 있지만 보통 1.5배로 계산)</li><li>테이블 사이즈 만큼의 Free Local Storage(tmpdir) 를 확보한다 부족하면 스펙업할 것 </li><li>스펙 별 local storage</li></ul></li></ul><pre><code>instance class	local storage(GB)
db.r6i.32xlarge	2560
db.r6i.24xlarge	1920
db.r6i.16xlarge	1,280
db.r6i.12xlarge	960
db.r6i.8xlarge	640
db.r6i.4xlarge	320
db.r6i.2xlarge	160
db.r6i.xlarge	80
db.r6i.large	32
db.t4g.xlarge	32
db.t4g.medium	32
db.t3.large	32
db.t3.medium	32
db.t3.small	32
db.t2.medium	32
db.t2.small	32
</code></pre><ul><li>컬럼 추가 등 기타 inplace<ul><li>작업시간 산정 : 테이블 사이즈 (data + index) 1GB 당 1분 (파티션 테이블의 경우 파티션 개수마다 차이가 있지만 보통 1.5배로 계산)</li></ul></li><li>varchar 컬럼 길이 변경 시엔 반드시 인덱스에 포함된 컬럼인지 확인할것(aurora 2 한정)<ul><li>mysql 5.7.12 버전의 버그로 metadata만 변경하고 바로 완료되는 구간이어도 inplace로 동작하게됨</li></ul></li></ul><h1 id=모니터링>모니터링<a hidden class=anchor aria-hidden=true href=#모니터링>#</a></h1><p>DB 리소스 측면에서는 아래 두 메트릭을 확인한다</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ddl_1.png alt><br>이 중 Freeable Memory는 index 추가, 컬럼 추가 등 모든 DDL 공통으로 사용하고<br>Free Local Storage는 index 작업시에만 사용한다. 
(onpremise mysql에서 /tmpdir 을 사용하는 것과 동일하다)</p><p>두 메트릭 중 하나라도 소진하는 경우 작업이 실패하게 되고<br>특히 Freeable Memory는 작업이 끝나도 작업시 사용한 메모리가 모두 반환되는 게 아니기 때문에<br>이 메모리가 부족한 경우엔 DB재기동 등을 통해 회수해주는 것이 좋다</p><p>쿼리 측면에서는 DDL 진행도를 파악하여 쿼리 예상 종료시간을 예측해볼 수 있다</p><pre><code>### 사전 준비 

mysql&gt; UPDATE performance_schema.setup_instruments SET ENABLED = 'YES' WHERE NAME LIKE 'stage/innodb/alter%';
mysql&gt; UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' WHERE NAME LIKE 'events_stages%';




### DDL 진행도 파악 

mysql&gt; SELECT 
  esc.THREAD_ID  , 
  esc.SQL_TEXT  , 
  estc.EVENT_NAME  , 
  estc.WORK_COMPLETED  , 
  estc.WORK_ESTIMATED  , 
  (
    100 * estc.WORK_COMPLETED / estc.WORK_ESTIMATED
  ) AS 'Progress_%' 
FROM 
  performance_schema.events_statements_current esc, 
  performance_schema.events_stages_current estc 
WHERE 
  estc.THREAD_ID = esc.THREAD_ID  AND estc.NESTING_EVENT_ID = esc.EVENT_ID;


+-----------+------------------------------------------------------------------+---------------------------------------+----------------+----------------+------------+
| THREAD_ID | SQL_TEXT                                                         | EVENT_NAME                            | WORK_COMPLETED | WORK_ESTIMATED | Progress_% |
+-----------+------------------------------------------------------------------+---------------------------------------+----------------+----------------+------------+
|     79261 | alter table t1 add column t07202 int,algorithm=inplace,lock=none | stage/innodb/alter table (merge sort) |         379860 |         554662 |    68.4850 |
+-----------+------------------------------------------------------------------+---------------------------------------+----------------+----------------+------------+
1 row in set (0.01 sec)




==&gt;   379860 , 554662 숫자가 의미하는 건 테이블의 row 수가 아니라  작업량을 page 수로 표현한 의미라한다.


### 컬럼 추가

mysql&gt; SELECT pseshl.EVENT_ID
    -&gt;  , pseshl.NESTING_EVENT_ID
    -&gt;  , esh.SQL_TEXT
    -&gt;  , pseshl.EVENT_NAME
    -&gt;  , sys.format_time(pseshl.TIMER_WAIT)
    -&gt; FROM performance_schema.events_stages_history_long pseshl
    -&gt; , performance_schema.events_statements_history esh
    -&gt; WHERE pseshl.NESTING_EVENT_ID = esh.EVENT_ID
    -&gt; ORDER BY pseshl.NESTING_EVENT_ID, pseshl.TIMER_START
    -&gt; limit 5;
+----------+------------------+----------------------------------------------------------------------+------------------------------------------------------+------------------------------------+
| EVENT_ID | NESTING_EVENT_ID | SQL_TEXT                                                             | EVENT_NAME                                           | sys.format_time(pseshl.TIMER_WAIT) |
+----------+------------------+----------------------------------------------------------------------+------------------------------------------------------+------------------------------------+
|      147 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (merge sort)                | 4.60 s                             |
|      148 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (insert)                    | 4.24 s                             |
|      149 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (merge sort)                | 5.43 s                             |
|      150 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (insert)                    | 5.64 s                             |
|      151 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (merge sort)                | 5.84 s                             |
|      152 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (insert)                    | 5.71 s                             |
|      153 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (merge sort)                | 6.30 s                             |
|      154 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (insert)                    | 5.38 s                             |
|      155 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (flush)                     | 5.64 us                            |
|      156 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (log apply table)           | 113.96 us                          |
|      157 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (end)                       | 17.33 us                           |
|      158 |              146 | alter table t1 add column t07202 int,algorithm=inplace,lock=none     | stage/innodb/alter table (log apply table)           | 521.72 ms                          | 





### 인덱스 추가

|      160 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (read PK and internal sort) | 5.07 s                             |
|      161 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (merge sort)                | 4.47 s                             |   &lt;---- 가장 오래걸리는 구간
|      162 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (insert)                    | 4.77 s                             |
|      163 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (flush)                     | 2.00 us                            |
|      164 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (log apply index)           | 507.75 us                          |
|      165 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (flush)                     | 86.97 us                           |
|      166 |              159 | alter table t1 add index idx0720(t07202),algorithm=inplace,lock=none | stage/innodb/alter table (end)                       | 50.85 ms                           |




### 사용 쿼리

SELECT esc.THREAD_ID
 , esc.SQL_TEXT
 , estc.EVENT_NAME
 , estc.WORK_COMPLETED
 , estc.WORK_ESTIMATED
 , (100 * estc.WORK_COMPLETED / estc.WORK_ESTIMATED) AS 'Progress_%'
FROM performance_schema.events_statements_current esc
,performance_schema.events_stages_current estc
WHERE estc.THREAD_ID = esc.THREAD_ID
 AND estc.NESTING_EVENT_ID = esc.EVENT_ID




SELECT pseshl.EVENT_ID
 , pseshl.NESTING_EVENT_ID
 , esh.SQL_TEXT
 , pseshl.EVENT_NAME
 , sys.format_time(pseshl.TIMER_WAIT)
FROM performance_schema.events_stages_history_long pseshl
, performance_schema.events_statements_history esh
WHERE pseshl.NESTING_EVENT_ID = esh.EVENT_ID
ORDER BY pseshl.NESTING_EVENT_ID, pseshl.TIMER_START
limit 5;

참고 : https://dev.mysql.com/doc/refman/8.0/en/monitor-alter-table-performance-schema.html

</code></pre><h1 id=케이스-정리>케이스 정리<a hidden class=anchor aria-hidden=true href=#케이스-정리>#</a></h1><h2 id=실패-case-1-free-local-storage-부족>실패 case 1.  Free Local Storage 부족 <a hidden class=anchor aria-hidden=true href=#실패-case-1-free-local-storage-부족>#</a></h2><p>index 추가 시엔 Local Storage를 사용하는데 이 때 작업 테이블 사이즈만큼의 공간을 필요로 하고, 부족한 경우엔 작업이 실패함<br>add column 같은 rebuild DDL은 local storage가 아니라 datadir (클러스터볼륨)을 사용하기 때문에 걱정이없다</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ddl_2.png alt></p><p>340GB 테이블에 인덱스를 추가할 때<br>2xlarge의 경우 Free Local Storage 공간이 부족하여 작업이 실패하였고<br>4xlarge의 경우 거의 300GB만큼의 공간을 사용한 뒤 성공하였음</p><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ddl_3.png alt><br>ERROR 1878 (HY000) Temporary file write failure 발생</p><h2 id=실패-case-2-online-dml-buffer-부족>실패 case 2. online dml buffer 부족<a hidden class=anchor aria-hidden=true href=#실패-case-2-online-dml-buffer-부족>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ddl_4.png alt><br>online DDL 수행 중 테이블의 변경사항은 innodb_online_alter_log_max_size 설정값(default 1GB) 만큼  
innodb_online_alter_log buffer에 보관할 수 있게 되는데 이것이 부족한 경우 작업이 실패한다<br>작업 초반부에 버퍼가 초과해도 바로 에러가 발생하는 게 아니라 작업 막바지에 buffer 데이터 반영하는 시점에 실패하게 되기 때문에 제일 가슴이 아픈 케이스다</p><h2 id=실패-case-3-metadata-lock-timeout>실패 case 3. metadata lock timeout<a hidden class=anchor aria-hidden=true href=#실패-case-3-metadata-lock-timeout>#</a></h2><pre><code>+-------+-----------------+--------------------+------+-------------+--------+---------------------------------------------------------------+-----------------------------------------------------------------+
| Id    | User            | Host               | db   | Command     | Time   | State                                                         | Info                                                            |
+-------+-----------------+--------------------+------+-------------+--------+---------------------------------------------------------------+-----------------------------------------------------------------+

| 79231 | master          | 172.27.2.39:52353  | test | Query       |    112 | Waiting for table metadata lock                               | alter table t1 add column t0720 int,algorithm=inplace,lock=none |
| 79412 | master          | 172.27.2.39:52920  | test | Sleep       |    108 | NULL                                                          | NULL                                                            |
| 79418 | master          | 172.27.2.39:52925  | test | Query       |     25 | Waiting for table metadata lock                               | select * from t1 limit 1                                        |
| 79425 | master          | 172.27.2.39:52935  | test | Query       |      3 | Waiting for table metadata lock                               | select * from t1 limit 1                                        |
| 79428 | master          | 172.27.2.39:52937  | NULL | Query       |      0 | starting                                                      | show processlist                                                |
+-------+-----------------+--------------------+------+-------------+--------+---------------------------------------------------------------+-----------------------------------------------------------------+



mysql&gt; alter table t1 add column t0720 int,algorithm=inplace,lock=none;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre><p>79412 세션이 t1 테이블에 대한 트랜잭션(롱 쿼리)을 유지하고 있어서 DDL이 메타락을 획득하지 못하고 대기하다가 timeout이 발생하는 케이스<br>문제는 DDL 컬럼이 메타락을 획득하려고 시도하는 동안,<br>그 뒤로 들어오는 해당 테이블을 사용하는 모든 쿼리들도 메타락 대기를 하게 되어 서비스 장애가 발생할 수 있기 때문에 
제일 무서운 케이스라고 볼 수 있다<br><img loading=lazy src=https://raw.githubusercontent.com/kimdubi/kimdubi.github.io/master/images/mysql/ddl_5.png alt></p><h2 id=실패-case-4-fulltext-index-테이블에-online-ddl-시도>실패 case 4. fulltext index 테이블에 online DDL 시도<a hidden class=anchor aria-hidden=true href=#실패-case-4-fulltext-index-테이블에-online-ddl-시도>#</a></h2><pre><code>CREATE TABLE `t1` (
  `tid` int(11) NOT NULL AUTO_INCREMENT,
  `TABLE_NAME` varchar(64) DEFAULT NULL,
  `COLUMN_NAME` varchar(64) DEFAULT NULL,
  `ORDINAL_POSITION` int(11) DEFAULT NULL,
  `ttt` varchar(30) NOT NULL,
  `ttt2` varchar(20) DEFAULT NULL,
  `ttt3` varchar(10) DEFAULT NULL,
  `tttt2` int(11) DEFAULT NULL,
  `tttt444` int(11) DEFAULT NULL,
  `ttt55` varchar(20) NOT NULL,
  `ttt66` int(11) DEFAULT NULL,
  `t07202` int(11) DEFAULT NULL,
  PRIMARY KEY (`tid`,`ttt`),
  KEY `idx` (`ttt`),
  KEY `idx_0710` (`ttt55`),
  KEY `idx_0711` (`ttt55`),
  KEY `idx_0712` (`ttt55`),
  KEY `idx0720` (`t07202`),
  KEY `idx07202` (`t07202`),
  FULLTEXT KEY `idx1` (`ttt`)
) ENGINE=InnoDB AUTO_INCREMENT=1000000042 DEFAULT CHARSET=utf8mb4



mysql&gt; alter table t1 add column t07203 int,algorithm=inplace,lock=none;
ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: InnoDB presently supports one FULLTEXT index creation at a time. Try ALGORITHM=COPY.




mysql&gt; alter table t1 add index idx00 (t07202),algorithm=inplace,lock=none;

Query OK, 0 rows affected, 1 warning (15.09 sec)
</code></pre><p>컬럼 추가 같은 rebuild 작업이 inplace로 안되는 모습<br>inplace로 동작할줄알고 algorithm=inplace,lock=none;  구문 제외하는 순간 COPY방식으로 동작하여 장애가 날 수 있다<br>반면 인덱스 추가는 inplace로 되는 모습</p><h2 id=실패-case-5-index걸린-컬럼-varchar-size-변경-시도-aurora2--mysql-5712-한정>실패 case 5.  index걸린 컬럼 varchar size 변경 시도 (aurora2 , mysql 5.7.12 한정)<a hidden class=anchor aria-hidden=true href=#실패-case-5-index걸린-컬럼-varchar-size-변경-시도-aurora2--mysql-5712-한정>#</a></h2><pre><code> CREATE TABLE `t1` (
  `tid` int(11) NOT NULL AUTO_INCREMENT,
  `TABLE_NAME` varchar(64) DEFAULT NULL,
  `COLUMN_NAME` varchar(64) DEFAULT NULL,
  `ORDINAL_POSITION` int(11) DEFAULT NULL,
  `ttt` varchar(30) NOT NULL,
  `ttt2` varchar(10) DEFAULT NULL,
  `ttt3` varchar(10) DEFAULT NULL,
  `tttt2` int(11) DEFAULT NULL,
  `tttt444` int(11) DEFAULT NULL,
  `ttt55` varchar(10) NOT NULL,
  `ttt66` int(11) DEFAULT NULL,
  `t07202` int(11) DEFAULT NULL,
  PRIMARY KEY (`tid`,`ttt`),
  KEY `idx` (`ttt`),
  KEY `idx_0710` (`ttt55`),
  KEY `idx_0711` (`ttt55`),
  KEY `idx_0712` (`ttt55`),
  KEY `idx0720` (`t07202`),
  KEY `idx07202` (`t07202`)
) ENGINE=InnoDB AUTO_INCREMENT=1000000042 DEFAULT CHARSET=utf8mb4 |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)

mysql&gt; alter table t1 modify ttt2 varchar(20),algorithm=inplace,lock=none;
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; alter table t1 modify ttt55 varchar(20) not null,algorithm=inplace,lock=none;
Query OK, 0 rows affected (46.57 sec)
Records: 0  Duplicates: 0  Warnings: 0
</code></pre><p>인덱스가 걸려있지 않은 컬럼은 metadata만 변경해서 바로 되는 반면<br>인덱스 걸려있는 컬럼은 inplace로 동작한다</p><h2 id=실패-case-6-컬럼-추가한-뒤-바로-인덱스-걸어주는-경우>실패 case 6. 컬럼 추가한 뒤 바로 인덱스 걸어주는 경우<a hidden class=anchor aria-hidden=true href=#실패-case-6-컬럼-추가한-뒤-바로-인덱스-걸어주는-경우>#</a></h2><p>대용량 테이블에 컬럼을 추가와 해당 컬럼에 대해서만 인덱스 추가가 바로 진행되는 경우<br>해당 인덱스의 카디날리티는 당연히 1 이다 (NULL값, 혹은 default값)</p><p>인덱스가 생성됐다고 바로 쿼리가 배포되는 순간<br>통계가 갱신되기 전 까지는 카디날리티가 1이기 때문에 인덱스를 못타고 풀스캔을 하게 된다<br>그러나 통계가 갱신되려면 전체 테이블 Row의 10%만큼 해당되는 변화가 있어야하는데 자주 갱신되기는 쉽지않다.  </p><p>이런 DDL 요청이 오는 경우 개발팀에 아래 사례를 공유하며 DDL과 쿼리 배포의 텀을 길게 하여 그 사이에 통계 갱신이 되도록 하거나<br>신규 컬럼 단일 인덱스를 생성하기 보다는 선별도 높은 다른 컬럼과 함께 쿼리와 인덱스에 추가하도록 한다</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/mysql/>mysql</a></li><li><a href=/tags/gdb/>gdb</a></li><li><a href=/tags/ddl/>ddl</a></li><li><a href=/tags/debugging/>debugging</a></li></ul><nav class=paginav><a class=prev href=/mysql/row_format/><span class=title>« Prev Page</span><br><span>MySQL row_format dynamic,compact에 대해서</span></a>
<a class=next href=/mysql/instant_ddl2/><span class=title>Next Page »</span><br><span>MySQL INSTANT DDL algorithm에 대해-2</span></a></nav></footer><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kimdubia';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href>kimDuBiA</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerText='copy';function copyingDone(){copybutton.innerText='copied!';setTimeout(()=>{copybutton.innerText='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>